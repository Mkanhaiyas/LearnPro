"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond";
exports.ids = ["vendor-chunks/filepond"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond/dist/filepond.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileOrigin: () => (/* binding */ FileOrigin$1),\n/* harmony export */   FileStatus: () => (/* binding */ FileStatus),\n/* harmony export */   OptionTypes: () => (/* binding */ OptionTypes),\n/* harmony export */   Status: () => (/* binding */ Status$1),\n/* harmony export */   create: () => (/* binding */ create$f),\n/* harmony export */   destroy: () => (/* binding */ destroy),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   getOptions: () => (/* binding */ getOptions$1),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   setOptions: () => (/* binding */ setOptions$1),\n/* harmony export */   supported: () => (/* binding */ supported)\n/* harmony export */ });\n/*!\n * FilePond 4.32.6\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\nconst isNode = value => value instanceof HTMLElement;\n\nconst createStore = (initialState, queries = [], actions = []) => {\n    // internal state\n    const state = {\n        ...initialState,\n    };\n\n    // contains all actions for next frame, is clear when actions are requested\n    const actionQueue = [];\n    const dispatchQueue = [];\n\n    // returns a duplicate of the current state\n    const getState = () => ({ ...state });\n\n    // returns a duplicate of the actions array and clears the actions array\n    const processActionQueue = () => {\n        // create copy of actions queue\n        const queue = [...actionQueue];\n\n        // clear actions queue (we don't want no double actions)\n        actionQueue.length = 0;\n\n        return queue;\n    };\n\n    // processes actions that might block the main UI thread\n    const processDispatchQueue = () => {\n        // create copy of actions queue\n        const queue = [...dispatchQueue];\n\n        // clear actions queue (we don't want no double actions)\n        dispatchQueue.length = 0;\n\n        // now dispatch these actions\n        queue.forEach(({ type, data }) => {\n            dispatch(type, data);\n        });\n    };\n\n    // adds a new action, calls its handler and\n    const dispatch = (type, data, isBlocking) => {\n        // is blocking action (should never block if document is hidden)\n        if (isBlocking && !document.hidden) {\n            dispatchQueue.push({ type, data });\n            return;\n        }\n\n        // if this action has a handler, handle the action\n        if (actionHandlers[type]) {\n            actionHandlers[type](data);\n        }\n\n        // now add action\n        actionQueue.push({\n            type,\n            data,\n        });\n    };\n\n    const query = (str, ...args) => (queryHandles[str] ? queryHandles[str](...args) : null);\n\n    const api = {\n        getState,\n        processActionQueue,\n        processDispatchQueue,\n        dispatch,\n        query,\n    };\n\n    let queryHandles = {};\n    queries.forEach(query => {\n        queryHandles = {\n            ...query(state),\n            ...queryHandles,\n        };\n    });\n\n    let actionHandlers = {};\n    actions.forEach(action => {\n        actionHandlers = {\n            ...action(dispatch, query, state),\n            ...actionHandlers,\n        };\n    });\n\n    return api;\n};\n\nconst defineProperty = (obj, property, definition) => {\n    if (typeof definition === 'function') {\n        obj[property] = definition;\n        return;\n    }\n    Object.defineProperty(obj, property, { ...definition });\n};\n\nconst forin = (obj, cb) => {\n    for (const key in obj) {\n        if (!obj.hasOwnProperty(key)) {\n            continue;\n        }\n\n        cb(key, obj[key]);\n    }\n};\n\nconst createObject = definition => {\n    const obj = {};\n    forin(definition, property => {\n        defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n};\n\nconst attr = (node, name, value = null) => {\n    if (value === null) {\n        return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n};\n\nconst ns = 'http://www.w3.org/2000/svg';\nconst svgElements = ['svg', 'path']; // only svg elements used\n\nconst isSVGElement = tag => svgElements.includes(tag);\n\nconst createElement = (tag, className, attributes = {}) => {\n    if (typeof className === 'object') {\n        attributes = className;\n        className = null;\n    }\n    const element = isSVGElement(tag)\n        ? document.createElementNS(ns, tag)\n        : document.createElement(tag);\n    if (className) {\n        if (isSVGElement(tag)) {\n            attr(element, 'class', className);\n        } else {\n            element.className = className;\n        }\n    }\n    forin(attributes, (name, value) => {\n        attr(element, name, value);\n    });\n    return element;\n};\n\nconst appendChild = parent => (child, index) => {\n    if (typeof index !== 'undefined' && parent.children[index]) {\n        parent.insertBefore(child, parent.children[index]);\n    } else {\n        parent.appendChild(child);\n    }\n};\n\nconst appendChildView = (parent, childViews) => (view, index) => {\n    if (typeof index !== 'undefined') {\n        childViews.splice(index, 0, view);\n    } else {\n        childViews.push(view);\n    }\n\n    return view;\n};\n\nconst removeChildView = (parent, childViews) => view => {\n    // remove from child views\n    childViews.splice(childViews.indexOf(view), 1);\n\n    // remove the element\n    if (view.element.parentNode) {\n        parent.removeChild(view.element);\n    }\n\n    return view;\n};\n\nconst IS_BROWSER = (() =>\n    typeof window !== 'undefined' && typeof window.document !== 'undefined')();\nconst isBrowser = () => IS_BROWSER;\n\nconst testElement = isBrowser() ? createElement('svg') : {};\nconst getChildCount =\n    'children' in testElement ? el => el.children.length : el => el.childNodes.length;\n\nconst getViewRect = (elementRect, childViews, offset, scale) => {\n    const left = offset[0] || elementRect.left;\n    const top = offset[1] || elementRect.top;\n    const right = left + elementRect.width;\n    const bottom = top + elementRect.height * (scale[1] || 1);\n\n    const rect = {\n        // the rectangle of the element itself\n        element: {\n            ...elementRect,\n        },\n\n        // the rectangle of the element expanded to contain its children, does not include any margins\n        inner: {\n            left: elementRect.left,\n            top: elementRect.top,\n            right: elementRect.right,\n            bottom: elementRect.bottom,\n        },\n\n        // the rectangle of the element expanded to contain its children including own margin and child margins\n        // margins will be added after we've recalculated the size\n        outer: {\n            left,\n            top,\n            right,\n            bottom,\n        },\n    };\n\n    // expand rect to fit all child rectangles\n    childViews\n        .filter(childView => !childView.isRectIgnored())\n        .map(childView => childView.rect)\n        .forEach(childViewRect => {\n            expandRect(rect.inner, { ...childViewRect.inner });\n            expandRect(rect.outer, { ...childViewRect.outer });\n        });\n\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n\n    return rect;\n};\n\nconst expandRect = (parent, child) => {\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n\n    if (child.bottom > parent.bottom) {\n        parent.bottom = child.bottom;\n    }\n\n    if (child.right > parent.right) {\n        parent.right = child.right;\n    }\n};\n\nconst calculateRectSize = rect => {\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n};\n\nconst isNumber = value => typeof value === 'number';\n\n/**\n * Determines if position is at destination\n * @param position\n * @param destination\n * @param velocity\n * @param errorMargin\n * @returns {boolean}\n */\nconst thereYet = (position, destination, velocity, errorMargin = 0.001) => {\n    return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n};\n\n/**\n * Spring animation\n */\nconst spring =\n    // default options\n    ({ stiffness = 0.5, damping = 0.75, mass = 10 } = {}) =>\n        // method definition\n        {\n            let target = null;\n            let position = null;\n            let velocity = 0;\n            let resting = false;\n\n            // updates spring state\n            const interpolate = (ts, skipToEndState) => {\n                // in rest, don't animate\n                if (resting) return;\n\n                // need at least a target or position to do springy things\n                if (!(isNumber(target) && isNumber(position))) {\n                    resting = true;\n                    velocity = 0;\n                    return;\n                }\n\n                // calculate spring force\n                const f = -(position - target) * stiffness;\n\n                // update velocity by adding force based on mass\n                velocity += f / mass;\n\n                // update position by adding velocity\n                position += velocity;\n\n                // slow down based on amount of damping\n                velocity *= damping;\n\n                // we've arrived if we're near target and our velocity is near zero\n                if (thereYet(position, target, velocity) || skipToEndState) {\n                    position = target;\n                    velocity = 0;\n                    resting = true;\n\n                    // we done\n                    api.onupdate(position);\n                    api.oncomplete(position);\n                } else {\n                    // progress update\n                    api.onupdate(position);\n                }\n            };\n\n            /**\n             * Set new target value\n             * @param value\n             */\n            const setTarget = value => {\n                // if currently has no position, set target and position to this value\n                if (isNumber(value) && !isNumber(position)) {\n                    position = value;\n                }\n\n                // next target value will not be animated to\n                if (target === null) {\n                    target = value;\n                    position = value;\n                }\n\n                // let start moving to target\n                target = value;\n\n                // already at target\n                if (position === target || typeof target === 'undefined') {\n                    // now resting as target is current position, stop moving\n                    resting = true;\n                    velocity = 0;\n\n                    // done!\n                    api.onupdate(position);\n                    api.oncomplete(position);\n\n                    return;\n                }\n\n                resting = false;\n            };\n\n            // need 'api' to call onupdate callback\n            const api = createObject({\n                interpolate,\n                target: {\n                    set: setTarget,\n                    get: () => target,\n                },\n                resting: {\n                    get: () => resting,\n                },\n                onupdate: value => {},\n                oncomplete: value => {},\n            });\n\n            return api;\n        };\n\nconst easeLinear = t => t;\nconst easeInOutQuad = t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\nconst tween =\n    // default values\n    ({ duration = 500, easing = easeInOutQuad, delay = 0 } = {}) =>\n        // method definition\n        {\n            let start = null;\n            let t;\n            let p;\n            let resting = true;\n            let reverse = false;\n            let target = null;\n\n            const interpolate = (ts, skipToEndState) => {\n                if (resting || target === null) return;\n\n                if (start === null) {\n                    start = ts;\n                }\n\n                if (ts - start < delay) return;\n\n                t = ts - start - delay;\n\n                if (t >= duration || skipToEndState) {\n                    t = 1;\n                    p = reverse ? 0 : 1;\n                    api.onupdate(p * target);\n                    api.oncomplete(p * target);\n                    resting = true;\n                } else {\n                    p = t / duration;\n                    api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n                }\n            };\n\n            // need 'api' to call onupdate callback\n            const api = createObject({\n                interpolate,\n                target: {\n                    get: () => (reverse ? 0 : target),\n                    set: value => {\n                        // is initial value\n                        if (target === null) {\n                            target = value;\n                            api.onupdate(value);\n                            api.oncomplete(value);\n                            return;\n                        }\n\n                        // want to tween to a smaller value and have a current value\n                        if (value < target) {\n                            target = 1;\n                            reverse = true;\n                        } else {\n                            // not tweening to a smaller value\n                            reverse = false;\n                            target = value;\n                        }\n\n                        // let's go!\n                        resting = false;\n                        start = null;\n                    },\n                },\n                resting: {\n                    get: () => resting,\n                },\n                onupdate: value => {},\n                oncomplete: value => {},\n            });\n\n            return api;\n        };\n\nconst animator = {\n    spring,\n    tween,\n};\n\n/*\n { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n { translation: { type: 'spring', ... }, ... }\n { translation: { x: { type: 'spring', ... } } }\n*/\nconst createAnimator = (definition, category, property) => {\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    const def =\n        definition[category] && typeof definition[category][property] === 'object'\n            ? definition[category][property]\n            : definition[category] || definition;\n\n    const type = typeof def === 'string' ? def : def.type;\n    const props = typeof def === 'object' ? { ...def } : {};\n\n    return animator[type] ? animator[type](props) : null;\n};\n\nconst addGetSet = (keys, obj, props, overwrite = false) => {\n    obj = Array.isArray(obj) ? obj : [obj];\n    obj.forEach(o => {\n        keys.forEach(key => {\n            let name = key;\n            let getter = () => props[key];\n            let setter = value => (props[key] = value);\n\n            if (typeof key === 'object') {\n                name = key.key;\n                getter = key.getter || getter;\n                setter = key.setter || setter;\n            }\n\n            if (o[name] && !overwrite) {\n                return;\n            }\n\n            o[name] = {\n                get: getter,\n                set: setter,\n            };\n        });\n    });\n};\n\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// setup animators\n\nconst animations = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI }) => {\n    // initial properties\n    const initialProps = { ...viewProps };\n\n    // list of all active animations\n    const animations = [];\n\n    // setup animators\n    forin(mixinConfig, (property, animation) => {\n        const animator = createAnimator(animation);\n        if (!animator) {\n            return;\n        }\n\n        // when the animator updates, update the view state value\n        animator.onupdate = value => {\n            viewProps[property] = value;\n        };\n\n        // set animator target\n        animator.target = initialProps[property];\n\n        // when value is set, set the animator target value\n        const prop = {\n            key: property,\n            setter: value => {\n                // if already at target, we done!\n                if (animator.target === value) {\n                    return;\n                }\n\n                animator.target = value;\n            },\n            getter: () => viewProps[property],\n        };\n\n        // add getters and setters\n        addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);\n\n        // add it to the list for easy updating from the _write method\n        animations.push(animator);\n    });\n\n    // expose internal write api\n    return {\n        write: ts => {\n            let skipToEndState = document.hidden;\n            let resting = true;\n            animations.forEach(animation => {\n                if (!animation.resting) resting = false;\n                animation.interpolate(ts, skipToEndState);\n            });\n            return resting;\n        },\n        destroy: () => {},\n    };\n};\n\nconst addEvent = element => (type, fn) => {\n    element.addEventListener(type, fn);\n};\n\nconst removeEvent = element => (type, fn) => {\n    element.removeEventListener(type, fn);\n};\n\n// mixin\nconst listeners = ({\n    mixinConfig,\n    viewProps,\n    viewInternalAPI,\n    viewExternalAPI,\n    viewState,\n    view,\n}) => {\n    const events = [];\n\n    const add = addEvent(view.element);\n    const remove = removeEvent(view.element);\n\n    viewExternalAPI.on = (type, fn) => {\n        events.push({\n            type,\n            fn,\n        });\n        add(type, fn);\n    };\n\n    viewExternalAPI.off = (type, fn) => {\n        events.splice(events.findIndex(event => event.type === type && event.fn === fn), 1);\n        remove(type, fn);\n    };\n\n    return {\n        write: () => {\n            // not busy\n            return true;\n        },\n        destroy: () => {\n            events.forEach(event => {\n                remove(event.type, event.fn);\n            });\n        },\n    };\n};\n\n// add to external api and link to props\n\nconst apis = ({ mixinConfig, viewProps, viewExternalAPI }) => {\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n};\n\nconst isDefined = value => value != null;\n\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// set initial state based on props in viewProps\n// apply as transforms each frame\n\nconst defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0,\n};\n\nconst styles = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view }) => {\n    // initial props\n    const initialProps = { ...viewProps };\n\n    // current props\n    const currentProps = {};\n\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);\n\n    // override rect on internal and external rect getter so it takes in account transforms\n    const getOffset = () => [viewProps['translateX'] || 0, viewProps['translateY'] || 0];\n    const getScale = () => [viewProps['scaleX'] || 0, viewProps['scaleY'] || 0];\n    const getRect = () =>\n        view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;\n    viewInternalAPI.rect = { get: getRect };\n    viewExternalAPI.rect = { get: getRect };\n\n    // apply view props\n    mixinConfig.forEach(key => {\n        viewProps[key] =\n            typeof initialProps[key] === 'undefined' ? defaults[key] : initialProps[key];\n    });\n\n    // expose api\n    return {\n        write: () => {\n            // see if props have changed\n            if (!propsHaveChanged(currentProps, viewProps)) {\n                return;\n            }\n\n            // moves element to correct position on screen\n            applyStyles(view.element, viewProps);\n\n            // store new transforms\n            Object.assign(currentProps, { ...viewProps });\n\n            // no longer busy\n            return true;\n        },\n        destroy: () => {},\n    };\n};\n\nconst propsHaveChanged = (currentProps, newProps) => {\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n        return true;\n    }\n\n    // lets analyze the individual props\n    for (const prop in newProps) {\n        if (newProps[prop] !== currentProps[prop]) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\nconst applyStyles = (\n    element,\n    {\n        opacity,\n        perspective,\n        translateX,\n        translateY,\n        scaleX,\n        scaleY,\n        rotateX,\n        rotateY,\n        rotateZ,\n        originX,\n        originY,\n        width,\n        height,\n    }\n) => {\n    let transforms = '';\n    let styles = '';\n\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n        styles += `transform-origin: ${originX || 0}px ${originY || 0}px;`;\n    }\n\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n        transforms += `perspective(${perspective}px) `;\n    }\n\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n        transforms += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;\n    }\n\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n        transforms += `scale3d(${isDefined(scaleX) ? scaleX : 1}, ${\n            isDefined(scaleY) ? scaleY : 1\n        }, 1) `;\n    }\n\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n        transforms += `rotateZ(${rotateZ}rad) `;\n    }\n\n    if (isDefined(rotateX)) {\n        transforms += `rotateX(${rotateX}rad) `;\n    }\n\n    if (isDefined(rotateY)) {\n        transforms += `rotateY(${rotateY}rad) `;\n    }\n\n    // add transforms\n    if (transforms.length) {\n        styles += `transform:${transforms};`;\n    }\n\n    // add opacity\n    if (isDefined(opacity)) {\n        styles += `opacity:${opacity};`;\n\n        // if we reach zero, we make the element inaccessible\n        if (opacity === 0) {\n            styles += `visibility:hidden;`;\n        }\n\n        // if we're below 100% opacity this element can't be clicked\n        if (opacity < 1) {\n            styles += `pointer-events:none;`;\n        }\n    }\n\n    // add height\n    if (isDefined(height)) {\n        styles += `height:${height}px;`;\n    }\n\n    // add width\n    if (isDefined(width)) {\n        styles += `width:${width}px;`;\n    }\n\n    // apply styles\n    const elementCurrentStyle = element.elementCurrentStyle || '';\n\n    // if new styles does not match current styles, lets update!\n    if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n        element.style.cssText = styles;\n        // store current styles so we can compare them to new styles later on\n        // _not_ getting the style value is faster\n        element.elementCurrentStyle = styles;\n    }\n};\n\nconst Mixins = {\n    styles,\n    listeners,\n    animations,\n    apis,\n};\n\nconst updateRect = (rect = {}, element = {}, style = {}) => {\n    if (!element.layoutCalculated) {\n        rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n        rect.marginTop = parseInt(style.marginTop, 10) || 0;\n        rect.marginRight = parseInt(style.marginRight, 10) || 0;\n        rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n        rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n        element.layoutCalculated = true;\n    }\n\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n\n    rect.scrollTop = element.scrollTop;\n\n    rect.hidden = element.offsetParent === null;\n\n    return rect;\n};\n\nconst createView =\n    // default view definition\n    ({\n        // element definition\n        tag = 'div',\n        name = null,\n        attributes = {},\n\n        // view interaction\n        read = () => {},\n        write = () => {},\n        create = () => {},\n        destroy = () => {},\n\n        // hooks\n        filterFrameActionsForChild = (child, actions) => actions,\n        didCreateView = () => {},\n        didWriteView = () => {},\n\n        // rect related\n        ignoreRect = false,\n        ignoreRectUpdate = false,\n\n        // mixins\n        mixins = [],\n    } = {}) => (\n        // each view requires reference to store\n        store,\n        // specific properties for this view\n        props = {}\n    ) => {\n        // root element should not be changed\n        const element = createElement(tag, `filepond--${name}`, attributes);\n\n        // style reference should also not be changed\n        const style = window.getComputedStyle(element, null);\n\n        // element rectangle\n        const rect = updateRect();\n        let frameRect = null;\n\n        // rest state\n        let isResting = false;\n\n        // pretty self explanatory\n        const childViews = [];\n\n        // loaded mixins\n        const activeMixins = [];\n\n        // references to created children\n        const ref = {};\n\n        // state used for each instance\n        const state = {};\n\n        // list of writers that will be called to update this view\n        const writers = [\n            write, // default writer\n        ];\n\n        const readers = [\n            read, // default reader\n        ];\n\n        const destroyers = [\n            destroy, // default destroy\n        ];\n\n        // core view methods\n        const getElement = () => element;\n        const getChildViews = () => childViews.concat();\n        const getReference = () => ref;\n        const createChildView = store => (view, props) => view(store, props);\n        const getRect = () => {\n            if (frameRect) {\n                return frameRect;\n            }\n            frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);\n            return frameRect;\n        };\n        const getStyle = () => style;\n\n        /**\n         * Read data from DOM\n         * @private\n         */\n        const _read = () => {\n            frameRect = null;\n\n            // read child views\n            childViews.forEach(child => child._read());\n\n            const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n            if (shouldUpdate) {\n                updateRect(rect, element, style);\n            }\n\n            // readers\n            const api = { root: internalAPI, props, rect };\n            readers.forEach(reader => reader(api));\n        };\n\n        /**\n         * Write data to DOM\n         * @private\n         */\n        const _write = (ts, frameActions, shouldOptimize) => {\n            // if no actions, we assume that the view is resting\n            let resting = frameActions.length === 0;\n\n            // writers\n            writers.forEach(writer => {\n                const writerResting = writer({\n                    props,\n                    root: internalAPI,\n                    actions: frameActions,\n                    timestamp: ts,\n                    shouldOptimize,\n                });\n                if (writerResting === false) {\n                    resting = false;\n                }\n            });\n\n            // run mixins\n            activeMixins.forEach(mixin => {\n                // if one of the mixins is still busy after write operation, we are not resting\n                const mixinResting = mixin.write(ts);\n                if (mixinResting === false) {\n                    resting = false;\n                }\n            });\n\n            // updates child views that are currently attached to the DOM\n            childViews\n                .filter(child => !!child.element.parentNode)\n                .forEach(child => {\n                    // if a child view is not resting, we are not resting\n                    const childResting = child._write(\n                        ts,\n                        filterFrameActionsForChild(child, frameActions),\n                        shouldOptimize\n                    );\n                    if (!childResting) {\n                        resting = false;\n                    }\n                });\n\n            // append new elements to DOM and update those\n            childViews\n                //.filter(child => !child.element.parentNode)\n                .forEach((child, index) => {\n                    // skip\n                    if (child.element.parentNode) {\n                        return;\n                    }\n\n                    // append to DOM\n                    internalAPI.appendChild(child.element, index);\n\n                    // call read (need to know the size of these elements)\n                    child._read();\n\n                    // re-call write\n                    child._write(\n                        ts,\n                        filterFrameActionsForChild(child, frameActions),\n                        shouldOptimize\n                    );\n\n                    // we just added somthing to the dom, no rest\n                    resting = false;\n                });\n\n            // update resting state\n            isResting = resting;\n\n            didWriteView({\n                props,\n                root: internalAPI,\n                actions: frameActions,\n                timestamp: ts,\n            });\n\n            // let parent know if we are resting\n            return resting;\n        };\n\n        const _destroy = () => {\n            activeMixins.forEach(mixin => mixin.destroy());\n            destroyers.forEach(destroyer => {\n                destroyer({ root: internalAPI, props });\n            });\n            childViews.forEach(child => child._destroy());\n        };\n\n        // sharedAPI\n        const sharedAPIDefinition = {\n            element: {\n                get: getElement,\n            },\n            style: {\n                get: getStyle,\n            },\n            childViews: {\n                get: getChildViews,\n            },\n        };\n\n        // private API definition\n        const internalAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: getRect,\n            },\n\n            // access to custom children references\n            ref: {\n                get: getReference,\n            },\n\n            // dom modifiers\n            is: needle => name === needle,\n            appendChild: appendChild(element),\n            createChildView: createChildView(store),\n            linkView: view => {\n                childViews.push(view);\n                return view;\n            },\n            unlinkView: view => {\n                childViews.splice(childViews.indexOf(view), 1);\n            },\n            appendChildView: appendChildView(element, childViews),\n            removeChildView: removeChildView(element, childViews),\n            registerWriter: writer => writers.push(writer),\n            registerReader: reader => readers.push(reader),\n            registerDestroyer: destroyer => destroyers.push(destroyer),\n            invalidateLayout: () => (element.layoutCalculated = false),\n\n            // access to data store\n            dispatch: store.dispatch,\n            query: store.query,\n        };\n\n        // public view API methods\n        const externalAPIDefinition = {\n            element: {\n                get: getElement,\n            },\n            childViews: {\n                get: getChildViews,\n            },\n            rect: {\n                get: getRect,\n            },\n            resting: {\n                get: () => isResting,\n            },\n            isRectIgnored: () => ignoreRect,\n            _read,\n            _write,\n            _destroy,\n        };\n\n        // mixin API methods\n        const mixinAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: () => rect,\n            },\n        };\n\n        // add mixin functionality\n        Object.keys(mixins)\n            .sort((a, b) => {\n                // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n                if (a === 'styles') {\n                    return 1;\n                } else if (b === 'styles') {\n                    return -1;\n                }\n                return 0;\n            })\n            .forEach(key => {\n                const mixinAPI = Mixins[key]({\n                    mixinConfig: mixins[key],\n                    viewProps: props,\n                    viewState: state,\n                    viewInternalAPI: internalAPIDefinition,\n                    viewExternalAPI: externalAPIDefinition,\n                    view: createObject(mixinAPIDefinition),\n                });\n\n                if (mixinAPI) {\n                    activeMixins.push(mixinAPI);\n                }\n            });\n\n        // construct private api\n        const internalAPI = createObject(internalAPIDefinition);\n\n        // create the view\n        create({\n            root: internalAPI,\n            props,\n        });\n\n        // append created child views to root node\n        const childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach((child, index) => {\n            internalAPI.appendChild(child.element, childCount + index);\n        });\n\n        // call did create\n        didCreateView(internalAPI);\n\n        // expose public api\n        return createObject(externalAPIDefinition);\n    };\n\nconst createPainter = (read, write, fps = 60) => {\n    const name = '__framePainter';\n\n    // set global painter\n    if (window[name]) {\n        window[name].readers.push(read);\n        window[name].writers.push(write);\n        return;\n    }\n\n    window[name] = {\n        readers: [read],\n        writers: [write],\n    };\n\n    const painter = window[name];\n\n    const interval = 1000 / fps;\n    let last = null;\n    let id = null;\n    let requestTick = null;\n    let cancelTick = null;\n\n    const setTimerType = () => {\n        if (document.hidden) {\n            requestTick = () => window.setTimeout(() => tick(performance.now()), interval);\n            cancelTick = () => window.clearTimeout(id);\n        } else {\n            requestTick = () => window.requestAnimationFrame(tick);\n            cancelTick = () => window.cancelAnimationFrame(id);\n        }\n    };\n\n    document.addEventListener('visibilitychange', () => {\n        if (cancelTick) cancelTick();\n        setTimerType();\n        tick(performance.now());\n    });\n\n    const tick = ts => {\n        // queue next tick\n        id = requestTick(tick);\n\n        // limit fps\n        if (!last) {\n            last = ts;\n        }\n\n        const delta = ts - last;\n\n        if (delta <= interval) {\n            // skip frame\n            return;\n        }\n\n        // align next frame\n        last = ts - (delta % interval);\n\n        // update view\n        painter.readers.forEach(read => read());\n        painter.writers.forEach(write => write(ts));\n    };\n\n    setTimerType();\n    tick(performance.now());\n\n    return {\n        pause: () => {\n            cancelTick(id);\n        },\n    };\n};\n\nconst createRoute = (routes, fn) => ({ root, props, actions = [], timestamp, shouldOptimize }) => {\n    actions\n        .filter(action => routes[action.type])\n        .forEach(action =>\n            routes[action.type]({ root, props, action: action.data, timestamp, shouldOptimize })\n        );\n    if (fn) {\n        fn({ root, props, actions, timestamp, shouldOptimize });\n    }\n};\n\nconst insertBefore = (newNode, referenceNode) =>\n    referenceNode.parentNode.insertBefore(newNode, referenceNode);\n\nconst insertAfter = (newNode, referenceNode) => {\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n};\n\nconst isArray = value => Array.isArray(value);\n\nconst isEmpty = value => value == null;\n\nconst trim = str => str.trim();\n\nconst toString = value => '' + value;\n\nconst toArray = (value, splitter = ',') => {\n    if (isEmpty(value)) {\n        return [];\n    }\n    if (isArray(value)) {\n        return value;\n    }\n    return toString(value)\n        .split(splitter)\n        .map(trim)\n        .filter(str => str.length);\n};\n\nconst isBoolean = value => typeof value === 'boolean';\n\nconst toBoolean = value => (isBoolean(value) ? value : value === 'true');\n\nconst isString = value => typeof value === 'string';\n\nconst toNumber = value =>\n    isNumber(value) ? value : isString(value) ? toString(value).replace(/[a-z]+/gi, '') : 0;\n\nconst toInt = value => parseInt(toNumber(value), 10);\n\nconst toFloat = value => parseFloat(toNumber(value));\n\nconst isInt = value => isNumber(value) && isFinite(value) && Math.floor(value) === value;\n\nconst toBytes = (value, base = 1000) => {\n    // is in bytes\n    if (isInt(value)) {\n        return value;\n    }\n\n    // is natural file size\n    let naturalFileSize = toString(value).trim();\n\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/MB$i/, '').trim();\n        return toInt(naturalFileSize) * base * base;\n    }\n\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/KB$i/, '').trim();\n        return toInt(naturalFileSize) * base;\n    }\n\n    return toInt(naturalFileSize);\n};\n\nconst isFunction = value => typeof value === 'function';\n\nconst toFunctionReference = string => {\n    let ref = self;\n    let levels = string.split('.');\n    let level = null;\n    while ((level = levels.shift())) {\n        ref = ref[level];\n        if (!ref) {\n            return null;\n        }\n    }\n    return ref;\n};\n\nconst methods = {\n    process: 'POST',\n    patch: 'PATCH',\n    revert: 'DELETE',\n    fetch: 'GET',\n    restore: 'GET',\n    load: 'GET',\n};\n\nconst createServerAPI = outline => {\n    const api = {};\n\n    api.url = isString(outline) ? outline : outline.url || '';\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n\n    forin(methods, key => {\n        api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n    });\n\n    // remove process if no url or process on outline\n    api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n\n    // special treatment for remove\n    api.remove = outline.remove || null;\n\n    // remove generic headers from api object\n    delete api.headers;\n\n    return api;\n};\n\nconst createAction = (name, outline, method, timeout, headers) => {\n    // is explicitely set to null so disable\n    if (outline === null) {\n        return null;\n    }\n\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === 'function') {\n        return outline;\n    }\n\n    // build action object\n    const action = {\n        url: method === 'GET' || method === 'PATCH' ? `?${name}=` : '',\n        method,\n        headers,\n        withCredentials: false,\n        timeout,\n        onload: null,\n        ondata: null,\n        onerror: null,\n    };\n\n    // is a single url\n    if (isString(outline)) {\n        action.url = outline;\n        return action;\n    }\n\n    // overwrite\n    Object.assign(action, outline);\n\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n        const parts = action.headers.split(/:(.+)/);\n        action.headers = {\n            header: parts[0],\n            value: parts[1],\n        };\n    }\n\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n\n    return action;\n};\n\nconst toServerAPI = value => createServerAPI(value);\n\nconst isNull = value => value === null;\n\nconst isObject = value => typeof value === 'object' && value !== null;\n\nconst isAPI = value => {\n    return (\n        isObject(value) &&\n        isString(value.url) &&\n        isObject(value.process) &&\n        isObject(value.revert) &&\n        isObject(value.restore) &&\n        isObject(value.fetch)\n    );\n};\n\nconst getType = value => {\n    if (isArray(value)) {\n        return 'array';\n    }\n\n    if (isNull(value)) {\n        return 'null';\n    }\n\n    if (isInt(value)) {\n        return 'int';\n    }\n\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n        return 'bytes';\n    }\n\n    if (isAPI(value)) {\n        return 'api';\n    }\n\n    return typeof value;\n};\n\nconst replaceSingleQuotes = str =>\n    str\n        .replace(/{\\s*'/g, '{\"')\n        .replace(/'\\s*}/g, '\"}')\n        .replace(/'\\s*:/g, '\":')\n        .replace(/:\\s*'/g, ':\"')\n        .replace(/,\\s*'/g, ',\"')\n        .replace(/'\\s*,/g, '\",');\n\nconst conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: value => (getType(value) === 'bytes' ? toBytes(value) : toInt(value)),\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: value => (isFunction(value) ? value : toString(value)),\n    function: value => toFunctionReference(value),\n    serverapi: toServerAPI,\n    object: value => {\n        try {\n            return JSON.parse(replaceSingleQuotes(value));\n        } catch (e) {\n            return null;\n        }\n    },\n};\n\nconst convertTo = (value, type) => conversionTable[type](value);\n\nconst getValueByType = (newValue, defaultValue, valueType) => {\n    // can always assign default value\n    if (newValue === defaultValue) {\n        return newValue;\n    }\n\n    // get the type of the new value\n    let newValueType = getType(newValue);\n\n    // is valid type?\n    if (newValueType !== valueType) {\n        // is string input, let's attempt to convert\n        const convertedValue = convertTo(newValue, valueType);\n\n        // what is the type now\n        newValueType = getType(convertedValue);\n\n        // no valid conversions found\n        if (convertedValue === null) {\n            throw `Trying to assign value with incorrect type to \"${option}\", allowed type: \"${valueType}\"`;\n        } else {\n            newValue = convertedValue;\n        }\n    }\n\n    // assign new value\n    return newValue;\n};\n\nconst createOption = (defaultValue, valueType) => {\n    let currentValue = defaultValue;\n    return {\n        enumerable: true,\n        get: () => currentValue,\n        set: newValue => {\n            currentValue = getValueByType(newValue, defaultValue, valueType);\n        },\n    };\n};\n\nconst createOptions = options => {\n    const obj = {};\n    forin(options, prop => {\n        const optionDefinition = options[prop];\n        obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n};\n\nconst createInitialState = options => ({\n    // model\n    items: [],\n\n    // timeout used for calling update items\n    listUpdateTimeout: null,\n\n    // timeout used for stacking metadata updates\n    itemUpdateTimeout: null,\n\n    // queue of items waiting to be processed\n    processingQueue: [],\n\n    // options\n    options: createOptions(options),\n});\n\nconst fromCamels = (string, separator = '-') =>\n    string\n        .split(/(?=[A-Z])/)\n        .map(part => part.toLowerCase())\n        .join(separator);\n\nconst createOptionAPI = (store, options) => {\n    const obj = {};\n    forin(options, key => {\n        obj[key] = {\n            get: () => store.getState().options[key],\n            set: value => {\n                store.dispatch(`SET_${fromCamels(key, '_').toUpperCase()}`, {\n                    value,\n                });\n            },\n        };\n    });\n    return obj;\n};\n\nconst createOptionActions = options => (dispatch, query, state) => {\n    const obj = {};\n    forin(options, key => {\n        const name = fromCamels(key, '_').toUpperCase();\n\n        obj[`SET_${name}`] = action => {\n            try {\n                state.options[key] = action.value;\n            } catch (e) {\n                // nope, failed\n            }\n\n            // we successfully set the value of this option\n            dispatch(`DID_SET_${name}`, { value: state.options[key] });\n        };\n    });\n    return obj;\n};\n\nconst createOptionQueries = options => state => {\n    const obj = {};\n    forin(options, key => {\n        obj[`GET_${fromCamels(key, '_').toUpperCase()}`] = action => state.options[key];\n    });\n    return obj;\n};\n\nconst InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5,\n};\n\nconst getUniqueId = () =>\n    Math.random()\n        .toString(36)\n        .substring(2, 11);\n\nconst arrayRemove = (arr, index) => arr.splice(index, 1);\n\nconst run = (cb, sync) => {\n    if (sync) {\n        cb();\n    } else if (document.hidden) {\n        Promise.resolve(1).then(cb);\n    } else {\n        setTimeout(cb, 0);\n    }\n};\n\nconst on = () => {\n    const listeners = [];\n    const off = (event, cb) => {\n        arrayRemove(\n            listeners,\n            listeners.findIndex(listener => listener.event === event && (listener.cb === cb || !cb))\n        );\n    };\n    const fire = (event, args, sync) => {\n        listeners\n            .filter(listener => listener.event === event)\n            .map(listener => listener.cb)\n            .forEach(cb => run(() => cb(...args), sync));\n    };\n    return {\n        fireSync: (event, ...args) => {\n            fire(event, args, true);\n        },\n        fire: (event, ...args) => {\n            fire(event, args, false);\n        },\n        on: (event, cb) => {\n            listeners.push({ event, cb });\n        },\n        onOnce: (event, cb) => {\n            listeners.push({\n                event,\n                cb: (...args) => {\n                    off(event, cb);\n                    cb(...args);\n                },\n            });\n        },\n        off,\n    };\n};\n\nconst copyObjectPropertiesToObject = (src, target, excluded) => {\n    Object.getOwnPropertyNames(src)\n        .filter(property => !excluded.includes(property))\n        .forEach(key =>\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key))\n        );\n};\n\nconst PRIVATE = [\n    'fire',\n    'process',\n    'revert',\n    'load',\n    'on',\n    'off',\n    'onOnce',\n    'retryLoad',\n    'extend',\n    'archive',\n    'archived',\n    'release',\n    'released',\n    'requestProcessing',\n    'freeze',\n];\n\nconst createItemAPI = item => {\n    const api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n};\n\nconst removeReleasedItems = items => {\n    items.forEach((item, index) => {\n        if (item.released) {\n            arrayRemove(items, index);\n        }\n    });\n};\n\nconst ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8,\n};\n\nconst FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3,\n};\n\nconst getNonNumeric = str => /[^0-9]+/.exec(str);\n\nconst getDecimalSeparator = () => getNonNumeric((1.1).toLocaleString())[0];\n\nconst getThousandsSeparator = () => {\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    const decimalSeparator = getDecimalSeparator();\n    const thousandsStringWithSeparator = (1000.0).toLocaleString();\n    const thousandsStringWithoutSeparator = (1000.0).toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n        return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === '.' ? ',' : '.';\n};\n\nconst Type = {\n    BOOLEAN: 'boolean',\n    INT: 'int',\n    NUMBER: 'number',\n    STRING: 'string',\n    ARRAY: 'array',\n    OBJECT: 'object',\n    FUNCTION: 'function',\n    ACTION: 'action',\n    SERVER_API: 'serverapi',\n    REGEX: 'regex',\n};\n\n// all registered filters\nconst filters = [];\n\n// loops over matching filters and passes options to each filter, returning the mapped results\nconst applyFilterChain = (key, value, utils) =>\n    new Promise((resolve, reject) => {\n        // find matching filters for this key\n        const matchingFilters = filters.filter(f => f.key === key).map(f => f.cb);\n\n        // resolve now\n        if (matchingFilters.length === 0) {\n            resolve(value);\n            return;\n        }\n\n        // first filter to kick things of\n        const initialFilter = matchingFilters.shift();\n\n        // chain filters\n        matchingFilters\n            .reduce(\n                // loop over promises passing value to next promise\n                (current, next) => current.then(value => next(value, utils)),\n\n                // call initial filter, will return a promise\n                initialFilter(value, utils)\n\n                // all executed\n            )\n            .then(value => resolve(value))\n            .catch(error => reject(error));\n    });\n\nconst applyFilters = (key, value, utils) =>\n    filters.filter(f => f.key === key).map(f => f.cb(value, utils));\n\n// adds a new filter to the list\nconst addFilter = (key, cb) => filters.push({ key, cb });\n\nconst extendDefaultOptions = additionalOptions => Object.assign(defaultOptions, additionalOptions);\n\nconst getOptions = () => ({ ...defaultOptions });\n\nconst setOptions = opts => {\n    forin(opts, (key, value) => {\n        // key does not exist, so this option cannot be set\n        if (!defaultOptions[key]) {\n            return;\n        }\n        defaultOptions[key][0] = getValueByType(\n            value,\n            defaultOptions[key][0],\n            defaultOptions[key][1]\n        );\n    });\n};\n\n// default options on app\nconst defaultOptions = {\n    // the id to add to the root element\n    id: [null, Type.STRING],\n\n    // input field name to use\n    name: ['filepond', Type.STRING],\n\n    // disable the field\n    disabled: [false, Type.BOOLEAN],\n\n    // classname to put on wrapper\n    className: [null, Type.STRING],\n\n    // is the field required\n    required: [false, Type.BOOLEAN],\n\n    // Allow media capture when value is set\n    captureMethod: [null, Type.STRING],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [true, Type.BOOLEAN],\n\n    // Feature toggles\n    allowDrop: [true, Type.BOOLEAN], // Allow dropping of files\n    allowBrowse: [true, Type.BOOLEAN], // Allow browsing the file system\n    allowPaste: [true, Type.BOOLEAN], // Allow pasting files\n    allowMultiple: [false, Type.BOOLEAN], // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)\n    allowReplace: [true, Type.BOOLEAN], // Allow dropping a file on other file to replace it (only works when multiple is set to false)\n    allowRevert: [true, Type.BOOLEAN], // Allows user to revert file upload\n    allowRemove: [true, Type.BOOLEAN], // Allow user to remove a file\n    allowProcess: [true, Type.BOOLEAN], // Allows user to process a file, when set to false, this removes the file upload button\n    allowReorder: [false, Type.BOOLEAN], // Allow reordering of files\n    allowDirectoriesOnly: [false, Type.BOOLEAN], // Allow only selecting directories with browse (no support for filtering dnd at this point)\n\n    // Try store file if `server` not set\n    storeAsFile: [false, Type.BOOLEAN],\n\n    // Revert mode\n    forceRevert: [false, Type.BOOLEAN], // Set to 'force' to require the file to be reverted before removal\n\n    // Input requirements\n    maxFiles: [null, Type.INT], // Max number of files\n    checkValidity: [false, Type.BOOLEAN], // Enables custom validity messages\n\n    // Where to put file\n    itemInsertLocationFreedom: [true, Type.BOOLEAN], // Set to false to always add items to begin or end of list\n    itemInsertLocation: ['before', Type.STRING], // Default index in list to add items that have been dropped at the top of the list\n    itemInsertInterval: [75, Type.INT],\n\n    // Drag 'n Drop related\n    dropOnPage: [false, Type.BOOLEAN], // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)\n    dropOnElement: [true, Type.BOOLEAN], // Drop needs to happen on element (set to false to also load drops outside of Up)\n    dropValidation: [false, Type.BOOLEAN], // Enable or disable validating files on drop\n    ignoredFiles: [['.ds_store', 'thumbs.db', 'desktop.ini'], Type.ARRAY],\n\n    // Upload related\n    instantUpload: [true, Type.BOOLEAN], // Should upload files immediately on drop\n    maxParallelUploads: [2, Type.INT], // Maximum files to upload in parallel\n    allowMinimumUploadDuration: [true, Type.BOOLEAN], // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened\n\n    // Chunks\n    chunkUploads: [false, Type.BOOLEAN], // Enable chunked uploads\n    chunkForce: [false, Type.BOOLEAN], // Force use of chunk uploads even for files smaller than chunk size\n    chunkSize: [5000000, Type.INT], // Size of chunks (5MB default)\n    chunkRetryDelays: [[500, 1000, 3000], Type.ARRAY], // Amount of times to retry upload of a chunk when it fails\n\n    // The server api end points to use for uploading (see docs)\n    server: [null, Type.SERVER_API],\n\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [1000, Type.INT],\n\n    // Labels and status messages\n    labelFileSizeBytes: ['bytes', Type.STRING],\n    labelFileSizeKilobytes: ['KB', Type.STRING],\n    labelFileSizeMegabytes: ['MB', Type.STRING],\n    labelFileSizeGigabytes: ['GB', Type.STRING],\n\n    labelDecimalSeparator: [getDecimalSeparator(), Type.STRING], // Default is locale separator\n    labelThousandsSeparator: [getThousandsSeparator(), Type.STRING], // Default is locale separator\n\n    labelIdle: [\n        'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n        Type.STRING,\n    ],\n    labelInvalidField: ['Field contains invalid files', Type.STRING],\n    labelFileWaitingForSize: ['Waiting for size', Type.STRING],\n    labelFileSizeNotAvailable: ['Size not available', Type.STRING],\n    labelFileCountSingular: ['file in list', Type.STRING],\n    labelFileCountPlural: ['files in list', Type.STRING],\n    labelFileLoading: ['Loading', Type.STRING],\n    labelFileAdded: ['Added', Type.STRING], // assistive only\n    labelFileLoadError: ['Error during load', Type.STRING],\n    labelFileRemoved: ['Removed', Type.STRING], // assistive only\n    labelFileRemoveError: ['Error during remove', Type.STRING],\n    labelFileProcessing: ['Uploading', Type.STRING],\n    labelFileProcessingComplete: ['Upload complete', Type.STRING],\n    labelFileProcessingAborted: ['Upload cancelled', Type.STRING],\n    labelFileProcessingError: ['Error during upload', Type.STRING],\n    labelFileProcessingRevertError: ['Error during revert', Type.STRING],\n\n    labelTapToCancel: ['tap to cancel', Type.STRING],\n    labelTapToRetry: ['tap to retry', Type.STRING],\n    labelTapToUndo: ['tap to undo', Type.STRING],\n\n    labelButtonRemoveItem: ['Remove', Type.STRING],\n    labelButtonAbortItemLoad: ['Abort', Type.STRING],\n    labelButtonRetryItemLoad: ['Retry', Type.STRING],\n    labelButtonAbortItemProcessing: ['Cancel', Type.STRING],\n    labelButtonUndoItemProcessing: ['Undo', Type.STRING],\n    labelButtonRetryItemProcessing: ['Retry', Type.STRING],\n    labelButtonProcessItem: ['Upload', Type.STRING],\n\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING,\n    ],\n    iconProcess: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n        Type.STRING,\n    ],\n    iconRetry: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING,\n    ],\n    iconUndo: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING,\n    ],\n    iconDone: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING,\n    ],\n\n    // event handlers\n    oninit: [null, Type.FUNCTION],\n    onwarning: [null, Type.FUNCTION],\n    onerror: [null, Type.FUNCTION],\n    onactivatefile: [null, Type.FUNCTION],\n    oninitfile: [null, Type.FUNCTION],\n    onaddfilestart: [null, Type.FUNCTION],\n    onaddfileprogress: [null, Type.FUNCTION],\n    onaddfile: [null, Type.FUNCTION],\n    onprocessfilestart: [null, Type.FUNCTION],\n    onprocessfileprogress: [null, Type.FUNCTION],\n    onprocessfileabort: [null, Type.FUNCTION],\n    onprocessfilerevert: [null, Type.FUNCTION],\n    onprocessfile: [null, Type.FUNCTION],\n    onprocessfiles: [null, Type.FUNCTION],\n    onremovefile: [null, Type.FUNCTION],\n    onpreparefile: [null, Type.FUNCTION],\n    onupdatefiles: [null, Type.FUNCTION],\n    onreorderfiles: [null, Type.FUNCTION],\n\n    // hooks\n    beforeDropFile: [null, Type.FUNCTION],\n    beforeAddFile: [null, Type.FUNCTION],\n    beforeRemoveFile: [null, Type.FUNCTION],\n    beforePrepareFile: [null, Type.FUNCTION],\n\n    // styles\n    stylePanelLayout: [null, Type.STRING], // null 'integrated', 'compact', 'circle'\n    stylePanelAspectRatio: [null, Type.STRING], // null or '3:2' or 1\n    styleItemPanelAspectRatio: [null, Type.STRING],\n    styleButtonRemoveItemPosition: ['left', Type.STRING],\n    styleButtonProcessItemPosition: ['right', Type.STRING],\n    styleLoadIndicatorPosition: ['right', Type.STRING],\n    styleProgressIndicatorPosition: ['right', Type.STRING],\n    styleButtonRemoveItemAlign: [false, Type.BOOLEAN],\n\n    // custom initial files array\n    files: [[], Type.ARRAY],\n\n    // show support by displaying credits\n    credits: [['https://pqina.nl/', 'Powered by PQINA'], Type.ARRAY],\n};\n\nconst getItemByQuery = (items, query) => {\n    // just return first index\n    if (isEmpty(query)) {\n        return items[0] || null;\n    }\n\n    // query is index\n    if (isInt(query)) {\n        return items[query] || null;\n    }\n\n    // if query is item, get the id\n    if (typeof query === 'object') {\n        query = query.id;\n    }\n\n    // assume query is a string and return item by id\n    return items.find(item => item.id === query) || null;\n};\n\nconst getNumericAspectRatioFromString = aspectRatio => {\n    if (isEmpty(aspectRatio)) {\n        return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n        const parts = aspectRatio.split(':');\n        return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n};\n\nconst getActiveItems = items => items.filter(item => !item.archived);\n\nconst Status = {\n    EMPTY: 0,\n    IDLE: 1, // waiting\n    ERROR: 2, // a file is in error state\n    BUSY: 3, // busy processing or loading\n    READY: 4, // all files uploaded\n};\n\nlet res = null;\nconst canUpdateFileInput = () => {\n    if (res === null) {\n        try {\n            const dataTransfer = new DataTransfer();\n            dataTransfer.items.add(new File(['hello world'], 'This_Works.txt'));\n            const el = document.createElement('input');\n            el.setAttribute('type', 'file');\n            el.files = dataTransfer.files;\n            res = el.files.length === 1;\n        } catch (err) {\n            res = false;\n        }\n    }\n    return res;\n};\n\nconst ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR,\n];\nconst ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT,\n];\nconst ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];\n\nconst isItemInErrorState = item => ITEM_ERROR.includes(item.status);\nconst isItemInBusyState = item => ITEM_BUSY.includes(item.status);\nconst isItemInReadyState = item => ITEM_READY.includes(item.status);\n\nconst isAsync = state =>\n    isObject(state.options.server) &&\n    (isObject(state.options.server.process) || isFunction(state.options.server.process));\n\nconst queries = state => ({\n    GET_STATUS: () => {\n        const items = getActiveItems(state.items);\n\n        const { EMPTY, ERROR, BUSY, IDLE, READY } = Status;\n\n        if (items.length === 0) return EMPTY;\n\n        if (items.some(isItemInErrorState)) return ERROR;\n\n        if (items.some(isItemInBusyState)) return BUSY;\n\n        if (items.some(isItemInReadyState)) return READY;\n\n        return IDLE;\n    },\n\n    GET_ITEM: query => getItemByQuery(state.items, query),\n\n    GET_ACTIVE_ITEM: query => getItemByQuery(getActiveItems(state.items), query),\n\n    GET_ACTIVE_ITEMS: () => getActiveItems(state.items),\n\n    GET_ITEMS: () => state.items,\n\n    GET_ITEM_NAME: query => {\n        const item = getItemByQuery(state.items, query);\n        return item ? item.filename : null;\n    },\n\n    GET_ITEM_SIZE: query => {\n        const item = getItemByQuery(state.items, query);\n        return item ? item.fileSize : null;\n    },\n\n    GET_STYLES: () =>\n        Object.keys(state.options)\n            .filter(key => /^style/.test(key))\n            .map(option => ({\n                name: option,\n                value: state.options[option],\n            })),\n\n    GET_PANEL_ASPECT_RATIO: () => {\n        const isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n        const aspectRatio = isShapeCircle\n            ? 1\n            : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n        return aspectRatio;\n    },\n\n    GET_ITEM_PANEL_ASPECT_RATIO: () => state.options.styleItemPanelAspectRatio,\n\n    GET_ITEMS_BY_STATUS: status =>\n        getActiveItems(state.items).filter(item => item.status === status),\n\n    GET_TOTAL_ITEMS: () => getActiveItems(state.items).length,\n\n    SHOULD_UPDATE_FILE_INPUT: () =>\n        state.options.storeAsFile && canUpdateFileInput() && !isAsync(state),\n\n    IS_ASYNC: () => isAsync(state),\n\n    GET_FILE_SIZE_LABELS: query => ({\n        labelBytes: query('GET_LABEL_FILE_SIZE_BYTES') || undefined,\n        labelKilobytes: query('GET_LABEL_FILE_SIZE_KILOBYTES') || undefined,\n        labelMegabytes: query('GET_LABEL_FILE_SIZE_MEGABYTES') || undefined,\n        labelGigabytes: query('GET_LABEL_FILE_SIZE_GIGABYTES') || undefined,\n    }),\n});\n\nconst hasRoomForItem = state => {\n    const count = getActiveItems(state.items).length;\n\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n        return count === 0;\n    }\n\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    const maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n        return true;\n    }\n\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n        return true;\n    }\n\n    // no more room for another file\n    return false;\n};\n\nconst limit = (value, min, max) => Math.max(Math.min(max, value), min);\n\nconst arrayInsert = (arr, index, item) => arr.splice(index, 0, item);\n\nconst insertItem = (items, item, index) => {\n    if (isEmpty(item)) {\n        return null;\n    }\n\n    // if index is undefined, append\n    if (typeof index === 'undefined') {\n        items.push(item);\n        return item;\n    }\n\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n\n    // add item to array\n    arrayInsert(items, index, item);\n\n    // expose\n    return item;\n};\n\nconst isBase64DataURI = str =>\n    /^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(\n        str\n    );\n\nconst getFilenameFromURL = url =>\n    `${url}`\n        .split('/')\n        .pop()\n        .split('?')\n        .shift();\n\nconst getExtensionFromFilename = name => name.split('.').pop();\n\nconst guesstimateExtension = type => {\n    // if no extension supplied, exit here\n    if (typeof type !== 'string') {\n        return '';\n    }\n\n    // get subtype\n    const subtype = type.split('/').pop();\n\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n        return 'svg';\n    }\n\n    if (/zip|compressed/.test(subtype)) {\n        return 'zip';\n    }\n\n    if (/plain/.test(subtype)) {\n        return 'txt';\n    }\n\n    if (/msword/.test(subtype)) {\n        return 'doc';\n    }\n\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n        // always use jpg extension\n        if (subtype === 'jpeg') {\n            return 'jpg';\n        }\n\n        // return subtype\n        return subtype;\n    }\n\n    return '';\n};\n\nconst leftPad = (value, padding = '') => (padding + value).slice(-padding.length);\n\nconst getDateString = (date = new Date()) =>\n    `${date.getFullYear()}-${leftPad(date.getMonth() + 1, '00')}-${leftPad(\n        date.getDate(),\n        '00'\n    )}_${leftPad(date.getHours(), '00')}-${leftPad(date.getMinutes(), '00')}-${leftPad(\n        date.getSeconds(),\n        '00'\n    )}`;\n\nconst getFileFromBlob = (blob, filename, type = null, extension = null) => {\n    const file =\n        typeof type === 'string'\n            ? blob.slice(0, blob.size, type)\n            : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n        filename = getDateString();\n    }\n\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n        file.name = filename;\n    } else {\n        extension = extension || guesstimateExtension(file.type);\n        file.name = filename + (extension ? '.' + extension : '');\n    }\n\n    return file;\n};\n\nconst getBlobBuilder = () => {\n    return (window.BlobBuilder =\n        window.BlobBuilder ||\n        window.WebKitBlobBuilder ||\n        window.MozBlobBuilder ||\n        window.MSBlobBuilder);\n};\n\nconst createBlob = (arrayBuffer, mimeType) => {\n    const BB = getBlobBuilder();\n\n    if (BB) {\n        const bb = new BB();\n        bb.append(arrayBuffer);\n        return bb.getBlob(mimeType);\n    }\n\n    return new Blob([arrayBuffer], {\n        type: mimeType,\n    });\n};\n\nconst getBlobFromByteStringWithMimeType = (byteString, mimeType) => {\n    const ab = new ArrayBuffer(byteString.length);\n    const ia = new Uint8Array(ab);\n\n    for (let i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n    }\n\n    return createBlob(ab, mimeType);\n};\n\nconst getMimeTypeFromBase64DataURI = dataURI => {\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n};\n\nconst getBase64DataFromBase64DataURI = dataURI => {\n    // get data part of string (remove data:image/jpeg...,)\n    const data = dataURI.split(',')[1];\n\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, '');\n};\n\nconst getByteStringFromBase64DataURI = dataURI => {\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n};\n\nconst getBlobFromBase64DataURI = dataURI => {\n    const mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    const byteString = getByteStringFromBase64DataURI(dataURI);\n\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n};\n\nconst getFileFromBase64DataURI = (dataURI, filename, extension) => {\n    return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n};\n\nconst getFileNameFromHeader = header => {\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n\n    // get filename parts\n    const matches = header\n        .split(/filename=|filename\\*=.+''/)\n        .splice(1)\n        .map(name => name.trim().replace(/^[\"']|[;\"']{0,2}$/g, ''))\n        .filter(name => name.length);\n\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n};\n\nconst getFileSizeFromHeader = header => {\n    if (/content-length:/i.test(header)) {\n        const size = header.match(/[0-9]+/)[0];\n        return size ? parseInt(size, 10) : null;\n    }\n    return null;\n};\n\nconst getTranfserIdFromHeader = header => {\n    if (/x-content-transfer-id:/i.test(header)) {\n        const id = (header.split(':')[1] || '').trim();\n        return id || null;\n    }\n    return null;\n};\n\nconst getFileInfoFromHeaders = headers => {\n    const info = {\n        source: null,\n        name: null,\n        size: null,\n    };\n\n    const rows = headers.split('\\n');\n    for (let header of rows) {\n        const name = getFileNameFromHeader(header);\n        if (name) {\n            info.name = name;\n            continue;\n        }\n\n        const size = getFileSizeFromHeader(header);\n        if (size) {\n            info.size = size;\n            continue;\n        }\n\n        const source = getTranfserIdFromHeader(header);\n        if (source) {\n            info.source = source;\n            continue;\n        }\n    }\n\n    return info;\n};\n\nconst createFileLoader = fetchFn => {\n    const state = {\n        source: null,\n        complete: false,\n        progress: 0,\n        size: null,\n        timestamp: null,\n        duration: 0,\n        request: null,\n    };\n\n    const getProgress = () => state.progress;\n    const abort = () => {\n        if (state.request && state.request.abort) {\n            state.request.abort();\n        }\n    };\n\n    // load source\n    const load = () => {\n        // get quick reference\n        const source = state.source;\n\n        api.fire('init', source);\n\n        // Load Files\n        if (source instanceof File) {\n            api.fire('load', source);\n        } else if (source instanceof Blob) {\n            // Load blobs, set default name to current date\n            api.fire('load', getFileFromBlob(source, source.name));\n        } else if (isBase64DataURI(source)) {\n            // Load base 64, set default name to current date\n            api.fire('load', getFileFromBase64DataURI(source));\n        } else {\n            // Deal as if is external URL, let's load it!\n            loadURL(source);\n        }\n    };\n\n    // loads a url\n    const loadURL = url => {\n        // is remote url and no fetch method supplied\n        if (!fetchFn) {\n            api.fire('error', {\n                type: 'error',\n                body: \"Can't load URL\",\n                code: 400,\n            });\n            return;\n        }\n\n        // set request start\n        state.timestamp = Date.now();\n\n        // load file\n        state.request = fetchFn(\n            url,\n            response => {\n                // update duration\n                state.duration = Date.now() - state.timestamp;\n\n                // done!\n                state.complete = true;\n\n                // turn blob response into a file\n                if (response instanceof Blob) {\n                    response = getFileFromBlob(response, response.name || getFilenameFromURL(url));\n                }\n\n                api.fire(\n                    'load',\n                    // if has received blob, we go with blob, if no response, we return null\n                    response instanceof Blob ? response : response ? response.body : null\n                );\n            },\n            error => {\n                api.fire(\n                    'error',\n                    typeof error === 'string'\n                        ? {\n                              type: 'error',\n                              code: 0,\n                              body: error,\n                          }\n                        : error\n                );\n            },\n            (computable, current, total) => {\n                // collected some meta data already\n                if (total) {\n                    state.size = total;\n                }\n\n                // update duration\n                state.duration = Date.now() - state.timestamp;\n\n                // if we can't compute progress, we're not going to fire progress events\n                if (!computable) {\n                    state.progress = null;\n                    return;\n                }\n\n                // update progress percentage\n                state.progress = current / total;\n\n                // expose\n                api.fire('progress', state.progress);\n            },\n            () => {\n                api.fire('abort');\n            },\n            response => {\n                const fileinfo = getFileInfoFromHeaders(\n                    typeof response === 'string' ? response : response.headers\n                );\n                api.fire('meta', {\n                    size: state.size || fileinfo.size,\n                    filename: fileinfo.name,\n                    source: fileinfo.source,\n                });\n            }\n        );\n    };\n\n    const api = {\n        ...on(),\n        setSource: source => (state.source = source),\n        getProgress, // file load progress\n        abort, // abort file load\n        load, // start load\n    };\n\n    return api;\n};\n\nconst isGet = method => /GET|HEAD/.test(method);\n\nconst sendRequest = (data, url, options) => {\n    const api = {\n        onheaders: () => {},\n        onprogress: () => {},\n        onload: () => {},\n        ontimeout: () => {},\n        onerror: () => {},\n        onabort: () => {},\n        abort: () => {\n            aborted = true;\n            xhr.abort();\n        },\n    };\n\n    // timeout identifier, only used when timeout is defined\n    let aborted = false;\n    let headersReceived = false;\n\n    // set default options\n    options = {\n        method: 'POST',\n        headers: {},\n        withCredentials: false,\n        ...options,\n    };\n\n    // encode url\n    url = encodeURI(url);\n\n    // if method is GET, add any received data to url\n\n    if (isGet(options.method) && data) {\n        url = `${url}${encodeURIComponent(typeof data === 'string' ? data : JSON.stringify(data))}`;\n    }\n\n    // create request\n    const xhr = new XMLHttpRequest();\n\n    // progress of load\n    const process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = e => {\n        // no progress event when aborted ( onprogress is called once after abort() )\n        if (aborted) {\n            return;\n        }\n\n        api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = () => {\n        // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n        if (xhr.readyState < 2) {\n            return;\n        }\n\n        // no server response\n        if (xhr.readyState === 4 && xhr.status === 0) {\n            return;\n        }\n\n        if (headersReceived) {\n            return;\n        }\n\n        headersReceived = true;\n\n        // we've probably received some useful data in response headers\n        api.onheaders(xhr);\n    };\n\n    // load successful\n    xhr.onload = () => {\n        // is classified as valid response\n        if (xhr.status >= 200 && xhr.status < 300) {\n            api.onload(xhr);\n        } else {\n            api.onerror(xhr);\n        }\n    };\n\n    // error during load\n    xhr.onerror = () => api.onerror(xhr);\n\n    // request aborted\n    xhr.onabort = () => {\n        aborted = true;\n        api.onabort();\n    };\n\n    // request timeout\n    xhr.ontimeout = () => api.ontimeout(xhr);\n\n    // open up open up!\n    xhr.open(options.method, url, true);\n\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n        xhr.timeout = options.timeout;\n    }\n\n    // add headers\n    Object.keys(options.headers).forEach(key => {\n        const value = unescape(encodeURIComponent(options.headers[key]));\n        xhr.setRequestHeader(key, value);\n    });\n\n    // set type of response\n    if (options.responseType) {\n        xhr.responseType = options.responseType;\n    }\n\n    // set credentials\n    if (options.withCredentials) {\n        xhr.withCredentials = true;\n    }\n\n    // let's send our data\n    xhr.send(data);\n\n    return api;\n};\n\nconst createResponse = (type, code, body, headers) => ({\n    type,\n    code,\n    body,\n    headers,\n});\n\nconst createTimeoutResponse = cb => xhr => {\n    cb(createResponse('error', 0, 'Timeout', xhr.getAllResponseHeaders()));\n};\n\nconst hasQS = str => /\\?/.test(str);\nconst buildURL = (...parts) => {\n    let url = '';\n    parts.forEach(part => {\n        url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, '&') : part;\n    });\n    return url;\n};\n\nconst createFetchFunction = (apiUrl = '', action) => {\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') {\n        return action;\n    }\n\n    // no action supplied\n    if (!action || !isString(action.url)) {\n        return null;\n    }\n\n    // set onload hanlder\n    const onload = action.onload || (res => res);\n    const onerror = action.onerror || (res => null);\n\n    // internal handler\n    return (url, load, error, progress, abort, headers) => {\n        // do local or remote request based on if the url is external\n        const request = sendRequest(url, buildURL(apiUrl, action.url), {\n            ...action,\n            responseType: 'blob',\n        });\n\n        request.onload = xhr => {\n            // get headers\n            const headers = xhr.getAllResponseHeaders();\n\n            // get filename\n            const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n            // create response\n            load(\n                createResponse(\n                    'load',\n                    xhr.status,\n                    action.method === 'HEAD'\n                        ? null\n                        : getFileFromBlob(onload(xhr.response), filename),\n                    headers\n                )\n            );\n        };\n\n        request.onerror = xhr => {\n            error(\n                createResponse(\n                    'error',\n                    xhr.status,\n                    onerror(xhr.response) || xhr.statusText,\n                    xhr.getAllResponseHeaders()\n                )\n            );\n        };\n\n        request.onheaders = xhr => {\n            headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n\n        // should return request\n        return request;\n    };\n};\n\nconst ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4,\n};\n\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort, transfer, options) => {\n    return {\n    abort:() => {}\n  }\n}\n*/\n\n// apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\nconst processFileChunked = (\n    apiUrl,\n    action,\n    name,\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer,\n    options\n) => {\n    // all chunks\n    const chunks = [];\n    const { chunkTransferId, chunkServer, chunkSize, chunkRetryDelays } = options;\n\n    // default state\n    const state = {\n        serverId: chunkTransferId,\n        aborted: false,\n    };\n\n    // set onload handlers\n    const ondata = action.ondata || (fd => fd);\n    const onload =\n        action.onload ||\n        ((xhr, method) =>\n            method === 'HEAD' ? xhr.getResponseHeader('Upload-Offset') : xhr.response);\n    const onerror = action.onerror || (res => null);\n\n    // create server hook\n    const requestTransferId = cb => {\n        const formData = new FormData();\n\n        // add metadata under same name\n        if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n\n        const headers =\n            typeof action.headers === 'function'\n                ? action.headers(file, metadata)\n                : {\n                      ...action.headers,\n                      'Upload-Length': file.size,\n                  };\n\n        const requestParams = {\n            ...action,\n            headers,\n        };\n\n        // send request object\n        const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n\n        request.onload = xhr => cb(onload(xhr, requestParams.method));\n\n        request.onerror = xhr =>\n            error(\n                createResponse(\n                    'error',\n                    xhr.status,\n                    onerror(xhr.response) || xhr.statusText,\n                    xhr.getAllResponseHeaders()\n                )\n            );\n\n        request.ontimeout = createTimeoutResponse(error);\n    };\n\n    const requestTransferOffset = cb => {\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n        const headers =\n            typeof action.headers === 'function'\n                ? action.headers(state.serverId)\n                : {\n                      ...action.headers,\n                  };\n\n        const requestParams = {\n            headers,\n            method: 'HEAD',\n        };\n\n        const request = sendRequest(null, requestUrl, requestParams);\n\n        request.onload = xhr => cb(onload(xhr, requestParams.method));\n\n        request.onerror = xhr =>\n            error(\n                createResponse(\n                    'error',\n                    xhr.status,\n                    onerror(xhr.response) || xhr.statusText,\n                    xhr.getAllResponseHeaders()\n                )\n            );\n\n        request.ontimeout = createTimeoutResponse(error);\n    };\n\n    // create chunks\n    const lastChunkIndex = Math.floor(file.size / chunkSize);\n    for (let i = 0; i <= lastChunkIndex; i++) {\n        const offset = i * chunkSize;\n        const data = file.slice(offset, offset + chunkSize, 'application/offset+octet-stream');\n        chunks[i] = {\n            index: i,\n            size: data.size,\n            offset,\n            data,\n            file,\n            progress: 0,\n            retries: [...chunkRetryDelays],\n            status: ChunkStatus.QUEUED,\n            error: null,\n            request: null,\n            timeout: null,\n        };\n    }\n\n    const completeProcessingChunks = () => load(state.serverId);\n\n    const canProcessChunk = chunk =>\n        chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n\n    const processChunk = chunk => {\n        // processing is paused, wait here\n        if (state.aborted) return;\n\n        // get next chunk to process\n        chunk = chunk || chunks.find(canProcessChunk);\n\n        // no more chunks to process\n        if (!chunk) {\n            // all done?\n            if (chunks.every(chunk => chunk.status === ChunkStatus.COMPLETE)) {\n                completeProcessingChunks();\n            }\n\n            // no chunk to handle\n            return;\n        }\n\n        // now processing this chunk\n        chunk.status = ChunkStatus.PROCESSING;\n        chunk.progress = null;\n\n        // allow parsing of formdata\n        const ondata = chunkServer.ondata || (fd => fd);\n        const onerror = chunkServer.onerror || (res => null);\n        const onload = chunkServer.onload || (() => {});\n\n        // send request object\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n\n        const headers =\n            typeof chunkServer.headers === 'function'\n                ? chunkServer.headers(chunk)\n                : {\n                      ...chunkServer.headers,\n                      'Content-Type': 'application/offset+octet-stream',\n                      'Upload-Offset': chunk.offset,\n                      'Upload-Length': file.size,\n                      'Upload-Name': file.name,\n                  };\n\n        const request = (chunk.request = sendRequest(ondata(chunk.data), requestUrl, {\n            ...chunkServer,\n            headers,\n        }));\n\n        request.onload = xhr => {\n            // allow hooking into request result\n            onload(xhr, chunk.index, chunks.length);\n\n            // done!\n            chunk.status = ChunkStatus.COMPLETE;\n\n            // remove request reference\n            chunk.request = null;\n\n            // start processing more chunks\n            processChunks();\n        };\n\n        request.onprogress = (lengthComputable, loaded, total) => {\n            chunk.progress = lengthComputable ? loaded : null;\n            updateTotalProgress();\n        };\n\n        request.onerror = xhr => {\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            chunk.error = onerror(xhr.response) || xhr.statusText;\n            if (!retryProcessChunk(chunk)) {\n                error(\n                    createResponse(\n                        'error',\n                        xhr.status,\n                        onerror(xhr.response) || xhr.statusText,\n                        xhr.getAllResponseHeaders()\n                    )\n                );\n            }\n        };\n\n        request.ontimeout = xhr => {\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            if (!retryProcessChunk(chunk)) {\n                createTimeoutResponse(error)(xhr);\n            }\n        };\n\n        request.onabort = () => {\n            chunk.status = ChunkStatus.QUEUED;\n            chunk.request = null;\n            abort();\n        };\n    };\n\n    const retryProcessChunk = chunk => {\n        // no more retries left\n        if (chunk.retries.length === 0) return false;\n\n        // new retry\n        chunk.status = ChunkStatus.WAITING;\n        clearTimeout(chunk.timeout);\n        chunk.timeout = setTimeout(() => {\n            processChunk(chunk);\n        }, chunk.retries.shift());\n\n        // we're going to retry\n        return true;\n    };\n\n    const updateTotalProgress = () => {\n        // calculate total progress fraction\n        const totalBytesTransfered = chunks.reduce((p, chunk) => {\n            if (p === null || chunk.progress === null) return null;\n            return p + chunk.progress;\n        }, 0);\n\n        // can't compute progress\n        if (totalBytesTransfered === null) return progress(false, 0, 0);\n\n        // calculate progress values\n        const totalSize = chunks.reduce((total, chunk) => total + chunk.size, 0);\n\n        // can update progress indicator\n        progress(true, totalBytesTransfered, totalSize);\n    };\n\n    // process new chunks\n    const processChunks = () => {\n        const totalProcessing = chunks.filter(chunk => chunk.status === ChunkStatus.PROCESSING)\n            .length;\n        if (totalProcessing >= 1) return;\n        processChunk();\n    };\n\n    const abortChunks = () => {\n        chunks.forEach(chunk => {\n            clearTimeout(chunk.timeout);\n            if (chunk.request) {\n                chunk.request.abort();\n            }\n        });\n    };\n\n    // let's go!\n    if (!state.serverId) {\n        requestTransferId(serverId => {\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n\n            // pass back to item so we can use it if something goes wrong\n            transfer(serverId);\n\n            // store internally\n            state.serverId = serverId;\n            processChunks();\n        });\n    } else {\n        requestTransferOffset(offset => {\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n\n            // mark chunks with lower offset as complete\n            chunks\n                .filter(chunk => chunk.offset < offset)\n                .forEach(chunk => {\n                    chunk.status = ChunkStatus.COMPLETE;\n                    chunk.progress = chunk.size;\n                });\n\n            // continue processing\n            processChunks();\n        });\n    }\n\n    return {\n        abort: () => {\n            state.aborted = true;\n            abortChunks();\n        },\n    };\n};\n\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort) => {\n    return {\n    abort:() => {}\n  }\n}\n*/\nconst createFileProcessorFunction = (apiUrl, action, name, options) => (\n    file,\n    metadata,\n    load,\n    error,\n    progress,\n    abort,\n    transfer\n) => {\n    // no file received\n    if (!file) return;\n\n    // if was passed a file, and we can chunk it, exit here\n    const canChunkUpload = options.chunkUploads;\n    const shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n    const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n    if (file instanceof Blob && willChunkUpload)\n        return processFileChunked(\n            apiUrl,\n            action,\n            name,\n            file,\n            metadata,\n            load,\n            error,\n            progress,\n            abort,\n            transfer,\n            options\n        );\n\n    // set handlers\n    const ondata = action.ondata || (fd => fd);\n    const onload = action.onload || (res => res);\n    const onerror = action.onerror || (res => null);\n\n    const headers =\n        typeof action.headers === 'function'\n            ? action.headers(file, metadata) || {}\n            : {\n                  ...action.headers,\n              };\n\n    const requestParams = {\n        ...action,\n        headers,\n    };\n\n    // create formdata object\n    var formData = new FormData();\n\n    // add metadata under same name\n    if (isObject(metadata)) {\n        formData.append(name, JSON.stringify(metadata));\n    }\n\n    // Turn into an array of objects so no matter what the input, we can handle it the same way\n    (file instanceof Blob ? [{ name: null, file }] : file).forEach(item => {\n        formData.append(\n            name,\n            item.file,\n            item.name === null ? item.file.name : `${item.name}${item.file.name}`\n        );\n    });\n\n    // send request object\n    const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n    request.onload = xhr => {\n        load(createResponse('load', xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));\n    };\n\n    request.onerror = xhr => {\n        error(\n            createResponse(\n                'error',\n                xhr.status,\n                onerror(xhr.response) || xhr.statusText,\n                xhr.getAllResponseHeaders()\n            )\n        );\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n};\n\nconst createProcessorFunction = (apiUrl = '', action, name, options) => {\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === 'function') return (...params) => action(name, ...params, options);\n\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n};\n\n/*\n function signature:\n (uniqueFileId, load, error) => { }\n */\nconst createRevertFunction = (apiUrl = '', action) => {\n    // is custom implementation\n    if (typeof action === 'function') {\n        return action;\n    }\n\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n        return (uniqueFileId, load) => load();\n    }\n\n    // set onload hanlder\n    const onload = action.onload || (res => res);\n    const onerror = action.onerror || (res => null);\n\n    // internal implementation\n    return (uniqueFileId, load, error) => {\n        const request = sendRequest(\n            uniqueFileId,\n            apiUrl + action.url,\n            action // contains method, headers and withCredentials properties\n        );\n        request.onload = xhr => {\n            load(\n                createResponse(\n                    'load',\n                    xhr.status,\n                    onload(xhr.response),\n                    xhr.getAllResponseHeaders()\n                )\n            );\n        };\n\n        request.onerror = xhr => {\n            error(\n                createResponse(\n                    'error',\n                    xhr.status,\n                    onerror(xhr.response) || xhr.statusText,\n                    xhr.getAllResponseHeaders()\n                )\n            );\n        };\n\n        request.ontimeout = createTimeoutResponse(error);\n\n        return request;\n    };\n};\n\nconst getRandomNumber = (min = 0, max = 1) => min + Math.random() * (max - min);\n\nconst createPerceivedPerformanceUpdater = (\n    cb,\n    duration = 1000,\n    offset = 0,\n    tickMin = 25,\n    tickMax = 250\n) => {\n    let timeout = null;\n    const start = Date.now();\n\n    const tick = () => {\n        let runtime = Date.now() - start;\n        let delay = getRandomNumber(tickMin, tickMax);\n\n        if (runtime + delay > duration) {\n            delay = runtime + delay - duration;\n        }\n\n        let progress = runtime / duration;\n        if (progress >= 1 || document.hidden) {\n            cb(1);\n            return;\n        }\n\n        cb(progress);\n\n        timeout = setTimeout(tick, delay);\n    };\n\n    if (duration > 0) tick();\n\n    return {\n        clear: () => {\n            clearTimeout(timeout);\n        },\n    };\n};\n\nconst createFileProcessor = (processFn, options) => {\n    const state = {\n        complete: false,\n        perceivedProgress: 0,\n        perceivedPerformanceUpdater: null,\n        progress: null,\n        timestamp: null,\n        perceivedDuration: 0,\n        duration: 0,\n        request: null,\n        response: null,\n    };\n\n    const { allowMinimumUploadDuration } = options;\n\n    const process = (file, metadata) => {\n        const progressFn = () => {\n            // we've not yet started the real download, stop here\n            // the request might not go through, for instance, there might be some server trouble\n            // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n            if (state.duration === 0 || state.progress === null) return;\n\n            // as we're now processing, fire the progress event\n            api.fire('progress', api.getProgress());\n        };\n\n        const completeFn = () => {\n            state.complete = true;\n            api.fire('load-perceived', state.response.body);\n        };\n\n        // let's start processing\n        api.fire('start');\n\n        // set request start\n        state.timestamp = Date.now();\n\n        // create perceived performance progress indicator\n        state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(\n            progress => {\n                state.perceivedProgress = progress;\n                state.perceivedDuration = Date.now() - state.timestamp;\n\n                progressFn();\n\n                // if fake progress is done, and a response has been received,\n                // and we've not yet called the complete method\n                if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                    // we done!\n                    completeFn();\n                }\n            },\n            // random delay as in a list of files you start noticing\n            // files uploading at the exact same speed\n            allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0\n        );\n\n        // remember request so we can abort it later\n        state.request = processFn(\n            // the file to process\n            file,\n\n            // the metadata to send along\n            metadata,\n\n            // callbacks (load, error, progress, abort, transfer)\n            // load expects the body to be a server id if\n            // you want to make use of revert\n            response => {\n                // we put the response in state so we can access\n                // it outside of this method\n                state.response = isObject(response)\n                    ? response\n                    : {\n                          type: 'load',\n                          code: 200,\n                          body: `${response}`,\n                          headers: {},\n                      };\n\n                // update duration\n                state.duration = Date.now() - state.timestamp;\n\n                // force progress to 1 as we're now done\n                state.progress = 1;\n\n                // actual load is done let's share results\n                api.fire('load', state.response.body);\n\n                // we are really done\n                // if perceived progress is 1 ( wait for perceived progress to complete )\n                // or if server does not support progress ( null )\n                if (\n                    !allowMinimumUploadDuration ||\n                    (allowMinimumUploadDuration && state.perceivedProgress === 1)\n                ) {\n                    completeFn();\n                }\n            },\n\n            // error is expected to be an object with type, code, body\n            error => {\n                // cancel updater\n                state.perceivedPerformanceUpdater.clear();\n\n                // update others about this error\n                api.fire(\n                    'error',\n                    isObject(error)\n                        ? error\n                        : {\n                              type: 'error',\n                              code: 0,\n                              body: `${error}`,\n                          }\n                );\n            },\n\n            // actual processing progress\n            (computable, current, total) => {\n                // update actual duration\n                state.duration = Date.now() - state.timestamp;\n\n                // update actual progress\n                state.progress = computable ? current / total : null;\n\n                progressFn();\n            },\n\n            // abort does not expect a value\n            () => {\n                // stop updater\n                state.perceivedPerformanceUpdater.clear();\n\n                // fire the abort event so we can switch visuals\n                api.fire('abort', state.response ? state.response.body : null);\n            },\n\n            // register the id for this transfer\n            transferId => {\n                api.fire('transfer', transferId);\n            }\n        );\n    };\n\n    const abort = () => {\n        // no request running, can't abort\n        if (!state.request) return;\n\n        // stop updater\n        state.perceivedPerformanceUpdater.clear();\n\n        // abort actual request\n        if (state.request.abort) state.request.abort();\n\n        // if has response object, we've completed the request\n        state.complete = true;\n    };\n\n    const reset = () => {\n        abort();\n        state.complete = false;\n        state.perceivedProgress = 0;\n        state.progress = 0;\n        state.timestamp = null;\n        state.perceivedDuration = 0;\n        state.duration = 0;\n        state.request = null;\n        state.response = null;\n    };\n\n    const getProgress = allowMinimumUploadDuration\n        ? () => (state.progress ? Math.min(state.progress, state.perceivedProgress) : null)\n        : () => state.progress || null;\n\n    const getDuration = allowMinimumUploadDuration\n        ? () => Math.min(state.duration, state.perceivedDuration)\n        : () => state.duration;\n\n    const api = {\n        ...on(),\n        process, // start processing file\n        abort, // abort active process request\n        getProgress,\n        getDuration,\n        reset,\n    };\n\n    return api;\n};\n\nconst getFilenameWithoutExtension = name => name.substring(0, name.lastIndexOf('.')) || name;\n\nconst createFileStub = source => {\n    let data = [source.name, source.size, source.type];\n\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n        data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n        // if is base64 data uri we need to determine the average size and type\n        data[1] = source.length;\n        data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n        // url\n        data[0] = getFilenameFromURL(source);\n        data[1] = 0;\n        data[2] = 'application/octet-stream';\n    }\n\n    return {\n        name: data[0],\n        size: data[1],\n        type: data[2],\n    };\n};\n\nconst isFile = value => !!(value instanceof File || (value instanceof Blob && value.name));\n\nconst deepCloneObject = src => {\n    if (!isObject(src)) return src;\n    const target = isArray(src) ? [] : {};\n    for (const key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        const v = src[key];\n        target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n};\n\nconst createItem = (origin = null, serverFileReference = null, file = null) => {\n    // unique id for this item, is used to identify the item across views\n    const id = getUniqueId();\n\n    /**\n     * Internal item state\n     */\n    const state = {\n        // is archived\n        archived: false,\n\n        // if is frozen, no longer fires events\n        frozen: false,\n\n        // removed from view\n        released: false,\n\n        // original source\n        source: null,\n\n        // file model reference\n        file,\n\n        // id of file on server\n        serverFileReference,\n\n        // id of file transfer on server\n        transferId: null,\n\n        // is aborted\n        processingAborted: false,\n\n        // current item status\n        status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n\n        // active processes\n        activeLoader: null,\n        activeProcessor: null,\n    };\n\n    // callback used when abort processing is called to link back to the resolve method\n    let abortProcessingRequestComplete = null;\n\n    /**\n     * Externally added item metadata\n     */\n    const metadata = {};\n\n    // item data\n    const setStatus = status => (state.status = status);\n\n    // fire event unless the item has been archived\n    const fire = (event, ...params) => {\n        if (state.released || state.frozen) return;\n        api.fire(event, ...params);\n    };\n\n    // file data\n    const getFileExtension = () => getExtensionFromFilename(state.file.name);\n    const getFileType = () => state.file.type;\n    const getFileSize = () => state.file.size;\n    const getFile = () => state.file;\n\n    //\n    // logic to load a file\n    //\n    const load = (source, loader, onload) => {\n        // remember the original item source\n        state.source = source;\n\n        // source is known\n        api.fireSync('init');\n\n        // file stub is already there\n        if (state.file) {\n            api.fireSync('load-skip');\n            return;\n        }\n\n        // set a stub file object while loading the actual data\n        state.file = createFileStub(source);\n\n        // starts loading\n        loader.on('init', () => {\n            fire('load-init');\n        });\n\n        // we'eve received a size indication, let's update the stub\n        loader.on('meta', meta => {\n            // set size of file stub\n            state.file.size = meta.size;\n\n            // set name of file stub\n            state.file.filename = meta.filename;\n\n            // if has received source, we done\n            if (meta.source) {\n                origin = FileOrigin.LIMBO;\n                state.serverFileReference = meta.source;\n                state.status = ItemStatus.PROCESSING_COMPLETE;\n            }\n\n            // size has been updated\n            fire('load-meta');\n        });\n\n        // the file is now loading we need to update the progress indicators\n        loader.on('progress', progress => {\n            setStatus(ItemStatus.LOADING);\n\n            fire('load-progress', progress);\n        });\n\n        // an error was thrown while loading the file, we need to switch to error state\n        loader.on('error', error => {\n            setStatus(ItemStatus.LOAD_ERROR);\n\n            fire('load-request-error', error);\n        });\n\n        // user or another process aborted the file load (cannot retry)\n        loader.on('abort', () => {\n            setStatus(ItemStatus.INIT);\n            fire('load-abort');\n        });\n\n        // done loading\n        loader.on('load', file => {\n            // as we've now loaded the file the loader is no longer required\n            state.activeLoader = null;\n\n            // called when file has loaded succesfully\n            const success = result => {\n                // set (possibly) transformed file\n                state.file = isFile(result) ? result : state.file;\n\n                // file received\n                if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                    setStatus(ItemStatus.PROCESSING_COMPLETE);\n                } else {\n                    setStatus(ItemStatus.IDLE);\n                }\n\n                fire('load');\n            };\n\n            const error = result => {\n                // set original file\n                state.file = file;\n                fire('load-meta');\n\n                setStatus(ItemStatus.LOAD_ERROR);\n                fire('load-file-error', result);\n            };\n\n            // if we already have a server file reference, we don't need to call the onload method\n            if (state.serverFileReference) {\n                success(file);\n                return;\n            }\n\n            // no server id, let's give this file the full treatment\n            onload(file, success, error);\n        });\n\n        // set loader source data\n        loader.setSource(source);\n\n        // set as active loader\n        state.activeLoader = loader;\n\n        // load the source data\n        loader.load();\n    };\n\n    const retryLoad = () => {\n        if (!state.activeLoader) {\n            return;\n        }\n        state.activeLoader.load();\n    };\n\n    const abortLoad = () => {\n        if (state.activeLoader) {\n            state.activeLoader.abort();\n            return;\n        }\n        setStatus(ItemStatus.INIT);\n        fire('load-abort');\n    };\n\n    //\n    // logic to process a file\n    //\n    const process = (processor, onprocess) => {\n        // processing was aborted\n        if (state.processingAborted) {\n            state.processingAborted = false;\n            return;\n        }\n\n        // now processing\n        setStatus(ItemStatus.PROCESSING);\n\n        // reset abort callback\n        abortProcessingRequestComplete = null;\n\n        // if no file loaded we'll wait for the load event\n        if (!(state.file instanceof Blob)) {\n            api.on('load', () => {\n                process(processor, onprocess);\n            });\n            return;\n        }\n\n        // setup processor\n        processor.on('load', serverFileReference => {\n            // need this id to be able to revert the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n        });\n\n        // register transfer id\n        processor.on('transfer', transferId => {\n            // need this id to be able to revert the upload\n            state.transferId = transferId;\n        });\n\n        processor.on('load-perceived', serverFileReference => {\n            // no longer required\n            state.activeProcessor = null;\n\n            // need this id to be able to rever the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n            fire('process-complete', serverFileReference);\n        });\n\n        processor.on('start', () => {\n            fire('process-start');\n        });\n\n        processor.on('error', error => {\n            state.activeProcessor = null;\n            setStatus(ItemStatus.PROCESSING_ERROR);\n            fire('process-error', error);\n        });\n\n        processor.on('abort', serverFileReference => {\n            state.activeProcessor = null;\n\n            // if file was uploaded but processing was cancelled during perceived processor time store file reference\n            state.serverFileReference = serverFileReference;\n\n            setStatus(ItemStatus.IDLE);\n            fire('process-abort');\n\n            // has timeout so doesn't interfere with remove action\n            if (abortProcessingRequestComplete) {\n                abortProcessingRequestComplete();\n            }\n        });\n\n        processor.on('progress', progress => {\n            fire('process-progress', progress);\n        });\n\n        // when successfully transformed\n        const success = file => {\n            // if was archived in the mean time, don't process\n            if (state.archived) return;\n\n            // process file!\n            processor.process(file, { ...metadata });\n        };\n\n        // something went wrong during transform phase\n        const error = console.error;\n\n        // start processing the file\n        onprocess(state.file, success, error);\n\n        // set as active processor\n        state.activeProcessor = processor;\n    };\n\n    const requestProcessing = () => {\n        state.processingAborted = false;\n        setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n\n    const abortProcessing = () =>\n        new Promise(resolve => {\n            if (!state.activeProcessor) {\n                state.processingAborted = true;\n\n                setStatus(ItemStatus.IDLE);\n                fire('process-abort');\n\n                resolve();\n                return;\n            }\n\n            abortProcessingRequestComplete = () => {\n                resolve();\n            };\n\n            state.activeProcessor.abort();\n        });\n\n    //\n    // logic to revert a processed file\n    //\n    const revert = (revertFileUpload, forceRevert) =>\n        new Promise((resolve, reject) => {\n            // a completed upload will have a serverFileReference, a failed chunked upload where\n            // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n            const serverTransferId =\n                state.serverFileReference !== null ? state.serverFileReference : state.transferId;\n\n            // cannot revert without a server id for this process\n            if (serverTransferId === null) {\n                resolve();\n                return;\n            }\n\n            // revert the upload (fire and forget)\n            revertFileUpload(\n                serverTransferId,\n                () => {\n                    // reset file server id and transfer id as now it's not available on the server\n                    state.serverFileReference = null;\n                    state.transferId = null;\n                    resolve();\n                },\n                error => {\n                    // don't set error state when reverting is optional, it will always resolve\n                    if (!forceRevert) {\n                        resolve();\n                        return;\n                    }\n\n                    // oh no errors\n                    setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                    fire('process-revert-error');\n                    reject(error);\n                }\n            );\n\n            // fire event\n            setStatus(ItemStatus.IDLE);\n            fire('process-revert');\n        });\n\n    // exposed methods\n    const setMetadata = (key, value, silent) => {\n        const keys = key.split('.');\n        const root = keys[0];\n        const last = keys.pop();\n        let data = metadata;\n        keys.forEach(key => (data = data[key]));\n\n        // compare old value against new value, if they're the same, we're not updating\n        if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n\n        // update value\n        data[last] = value;\n\n        // fire update\n        fire('metadata-update', {\n            key: root,\n            value: metadata[root],\n            silent,\n        });\n    };\n\n    const getMetadata = key => deepCloneObject(key ? metadata[key] : metadata);\n\n    const api = {\n        id: { get: () => id },\n        origin: { get: () => origin, set: value => (origin = value) },\n        serverId: { get: () => state.serverFileReference },\n        transferId: { get: () => state.transferId },\n        status: { get: () => state.status },\n        filename: { get: () => state.file.name },\n        filenameWithoutExtension: { get: () => getFilenameWithoutExtension(state.file.name) },\n        fileExtension: { get: getFileExtension },\n        fileType: { get: getFileType },\n        fileSize: { get: getFileSize },\n        file: { get: getFile },\n        relativePath: { get: () => state.file._relativePath },\n\n        source: { get: () => state.source },\n\n        getMetadata,\n        setMetadata: (key, value, silent) => {\n            if (isObject(key)) {\n                const data = key;\n                Object.keys(data).forEach(key => {\n                    setMetadata(key, data[key], value);\n                });\n                return key;\n            }\n            setMetadata(key, value, silent);\n            return value;\n        },\n\n        extend: (name, handler) => (itemAPI[name] = handler),\n\n        abortLoad,\n        retryLoad,\n        requestProcessing,\n        abortProcessing,\n\n        load,\n        process,\n        revert,\n\n        ...on(),\n\n        freeze: () => (state.frozen = true),\n\n        release: () => (state.released = true),\n        released: { get: () => state.released },\n\n        archive: () => (state.archived = true),\n        archived: { get: () => state.archived },\n\n        // replace source and file object\n        setFile: file => (state.file = file),\n    };\n\n    // create it here instead of returning it instantly so we can extend it later\n    const itemAPI = createObject(api);\n\n    return itemAPI;\n};\n\nconst getItemIndexByQuery = (items, query) => {\n    // just return first index\n    if (isEmpty(query)) {\n        return 0;\n    }\n\n    // invalid queries\n    if (!isString(query)) {\n        return -1;\n    }\n\n    // return item by id (or -1 if not found)\n    return items.findIndex(item => item.id === query);\n};\n\nconst getItemById = (items, itemId) => {\n    const index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n        return;\n    }\n    return items[index] || null;\n};\n\nconst fetchBlob = (url, load, error, progress, abort, headers) => {\n    const request = sendRequest(null, url, {\n        method: 'GET',\n        responseType: 'blob',\n    });\n\n    request.onload = xhr => {\n        // get headers\n        const headers = xhr.getAllResponseHeaders();\n\n        // get filename\n        const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n\n        // create response\n        load(createResponse('load', xhr.status, getFileFromBlob(xhr.response, filename), headers));\n    };\n\n    request.onerror = xhr => {\n        error(createResponse('error', xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n    };\n\n    request.onheaders = xhr => {\n        headers(createResponse('headers', xhr.status, null, xhr.getAllResponseHeaders()));\n    };\n\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n\n    // should return request\n    return request;\n};\n\nconst getDomainFromURL = url => {\n    if (url.indexOf('//') === 0) {\n        url = location.protocol + url;\n    }\n    return url\n        .toLowerCase()\n        .replace('blob:', '')\n        .replace(/([a-z])?:\\/\\//, '$1')\n        .split('/')[0];\n};\n\nconst isExternalURL = url =>\n    (url.indexOf(':') > -1 || url.indexOf('//') > -1) &&\n    getDomainFromURL(location.href) !== getDomainFromURL(url);\n\nconst dynamicLabel = label => (...params) => (isFunction(label) ? label(...params) : label);\n\nconst isMockItem = item => !isFile(item.file);\n\nconst listUpdated = (dispatch, state) => {\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(() => {\n        dispatch('DID_UPDATE_ITEMS', { items: getActiveItems(state.items) });\n    }, 0);\n};\n\nconst optionalPromise = (fn, ...params) =>\n    new Promise(resolve => {\n        if (!fn) {\n            return resolve(true);\n        }\n\n        const result = fn(...params);\n\n        if (result == null) {\n            return resolve(true);\n        }\n\n        if (typeof result === 'boolean') {\n            return resolve(result);\n        }\n\n        if (typeof result.then === 'function') {\n            result.then(resolve);\n        }\n    });\n\nconst sortItems = (state, compare) => {\n    state.items.sort((a, b) => compare(createItemAPI(a), createItemAPI(b)));\n};\n\n// returns item based on state\nconst getItemByQueryFromState = (state, itemHandler) => ({\n    query,\n    success = () => {},\n    failure = () => {},\n    ...options\n} = {}) => {\n    const item = getItemByQuery(state.items, query);\n    if (!item) {\n        failure({\n            error: createResponse('error', 0, 'Item not found'),\n            file: null,\n        });\n        return;\n    }\n    itemHandler(item, success, failure, options || {});\n};\n\nconst actions = (dispatch, query, state) => ({\n    /**\n     * Aborts all ongoing processes\n     */\n    ABORT_ALL: () => {\n        getActiveItems(state.items).forEach(item => {\n            item.freeze();\n            item.abortLoad();\n            item.abortProcessing();\n        });\n    },\n\n    /**\n     * Sets initial files\n     */\n    DID_SET_FILES: ({ value = [] }) => {\n        // map values to file objects\n        const files = value.map(file => ({\n            source: file.source ? file.source : file,\n            options: file.options,\n        }));\n\n        // loop over files, if file is in list, leave it be, if not, remove\n        // test if items should be moved\n        let activeItems = getActiveItems(state.items);\n\n        activeItems.forEach(item => {\n            // if item not is in new value, remove\n            if (!files.find(file => file.source === item.source || file.source === item.file)) {\n                dispatch('REMOVE_ITEM', { query: item, remove: false });\n            }\n        });\n\n        // add new files\n        activeItems = getActiveItems(state.items);\n        files.forEach((file, index) => {\n            // if file is already in list\n            if (activeItems.find(item => item.source === file.source || item.file === file.source))\n                return;\n\n            // not in list, add\n            dispatch('ADD_ITEM', {\n                ...file,\n                interactionMethod: InteractionMethod.NONE,\n                index,\n            });\n        });\n    },\n\n    DID_UPDATE_ITEM_METADATA: ({ id, action, change }) => {\n        // don't do anything\n        if (change.silent) return;\n\n        // if is called multiple times in close succession we combined all calls together to save resources\n        clearTimeout(state.itemUpdateTimeout);\n        state.itemUpdateTimeout = setTimeout(() => {\n            const item = getItemById(state.items, id);\n\n            // only revert and attempt to upload when we're uploading to a server\n            if (!query('IS_ASYNC')) {\n                // should we update the output data\n                applyFilterChain('SHOULD_PREPARE_OUTPUT', false, {\n                    item,\n                    query,\n                    action,\n                    change,\n                }).then(shouldPrepareOutput => {\n                    // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                    const beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                    if (beforePrepareFile)\n                        shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                    if (!shouldPrepareOutput) return;\n\n                    dispatch(\n                        'REQUEST_PREPARE_OUTPUT',\n                        {\n                            query: id,\n                            item,\n                            success: file => {\n                                dispatch('DID_PREPARE_OUTPUT', { id, file });\n                            },\n                        },\n                        true\n                    );\n                });\n\n                return;\n            }\n\n            // if is local item we need to enable upload button so change can be propagated to server\n            if (item.origin === FileOrigin.LOCAL) {\n                dispatch('DID_LOAD_ITEM', {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: item.source,\n                });\n            }\n\n            // for async scenarios\n            const upload = () => {\n                // we push this forward a bit so the interface is updated correctly\n                setTimeout(() => {\n                    dispatch('REQUEST_ITEM_PROCESSING', { query: id });\n                }, 32);\n            };\n\n            const revert = doUpload => {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                )\n                    .then(doUpload ? upload : () => {})\n                    .catch(() => {});\n            };\n\n            const abort = doUpload => {\n                item.abortProcessing().then(doUpload ? upload : () => {});\n            };\n\n            // if we should re-upload the file immediately\n            if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                return revert(state.options.instantUpload);\n            }\n\n            // if currently uploading, cancel upload\n            if (item.status === ItemStatus.PROCESSING) {\n                return abort(state.options.instantUpload);\n            }\n\n            if (state.options.instantUpload) {\n                upload();\n            }\n        }, 0);\n    },\n\n    MOVE_ITEM: ({ query, index }) => {\n        const item = getItemByQuery(state.items, query);\n        if (!item) return;\n        const currentIndex = state.items.indexOf(item);\n        index = limit(index, 0, state.items.length - 1);\n        if (currentIndex === index) return;\n        state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n    },\n\n    SORT: ({ compare }) => {\n        sortItems(state, compare);\n        dispatch('DID_SORT_ITEMS', {\n            items: query('GET_ACTIVE_ITEMS'),\n        });\n    },\n\n    ADD_ITEMS: ({ items, index, interactionMethod, success = () => {}, failure = () => {} }) => {\n        let currentIndex = index;\n\n        if (index === -1 || typeof index === 'undefined') {\n            const insertLocation = query('GET_ITEM_INSERT_LOCATION');\n            const totalItems = query('GET_TOTAL_ITEMS');\n            currentIndex = insertLocation === 'before' ? 0 : totalItems;\n        }\n\n        const ignoredFiles = query('GET_IGNORED_FILES');\n        const isValidFile = source =>\n            isFile(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);\n        const validItems = items.filter(isValidFile);\n\n        const promises = validItems.map(\n            source =>\n                new Promise((resolve, reject) => {\n                    dispatch('ADD_ITEM', {\n                        interactionMethod,\n                        source: source.source || source,\n                        success: resolve,\n                        failure: reject,\n                        index: currentIndex++,\n                        options: source.options || {},\n                    });\n                })\n        );\n\n        Promise.all(promises)\n            .then(success)\n            .catch(failure);\n    },\n\n    /**\n     * @param source\n     * @param index\n     * @param interactionMethod\n     */\n    ADD_ITEM: ({\n        source,\n        index = -1,\n        interactionMethod,\n        success = () => {},\n        failure = () => {},\n        options = {},\n    }) => {\n        // if no source supplied\n        if (isEmpty(source)) {\n            failure({\n                error: createResponse('error', 0, 'No source'),\n                file: null,\n            });\n            return;\n        }\n\n        // filter out invalid file items, used to filter dropped directory contents\n        if (isFile(source) && state.options.ignoredFiles.includes(source.name.toLowerCase())) {\n            // fail silently\n            return;\n        }\n\n        // test if there's still room in the list of files\n        if (!hasRoomForItem(state)) {\n            // if multiple allowed, we can't replace\n            // or if only a single item is allowed but we're not allowed to replace it we exit\n            if (\n                state.options.allowMultiple ||\n                (!state.options.allowMultiple && !state.options.allowReplace)\n            ) {\n                const error = createResponse('warning', 0, 'Max files');\n\n                dispatch('DID_THROW_MAX_FILES', {\n                    source,\n                    error,\n                });\n\n                failure({ error, file: null });\n\n                return;\n            }\n\n            // let's replace the item\n            // id of first item we're about to remove\n            const item = getActiveItems(state.items)[0];\n\n            // if has been processed remove it from the server as well\n            if (\n                item.status === ItemStatus.PROCESSING_COMPLETE ||\n                item.status === ItemStatus.PROCESSING_REVERT_ERROR\n            ) {\n                const forceRevert = query('GET_FORCE_REVERT');\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    forceRevert\n                )\n                    .then(() => {\n                        if (!forceRevert) return;\n\n                        // try to add now\n                        dispatch('ADD_ITEM', {\n                            source,\n                            index,\n                            interactionMethod,\n                            success,\n                            failure,\n                            options,\n                        });\n                    })\n                    .catch(() => {}); // no need to handle this catch state for now\n\n                if (forceRevert) return;\n            }\n\n            // remove first item as it will be replaced by this item\n            dispatch('REMOVE_ITEM', { query: item.id });\n        }\n\n        // where did the file originate\n        const origin =\n            options.type === 'local'\n                ? FileOrigin.LOCAL\n                : options.type === 'limbo'\n                ? FileOrigin.LIMBO\n                : FileOrigin.INPUT;\n\n        // create a new blank item\n        const item = createItem(\n            // where did this file come from\n            origin,\n\n            // an input file never has a server file reference\n            origin === FileOrigin.INPUT ? null : source,\n\n            // file mock data, if defined\n            options.file\n        );\n\n        // set initial meta data\n        Object.keys(options.metadata || {}).forEach(key => {\n            item.setMetadata(key, options.metadata[key]);\n        });\n\n        // created the item, let plugins add methods\n        applyFilters('DID_CREATE_ITEM', item, { query, dispatch });\n\n        // where to insert new items\n        const itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n\n        // adjust index if is not allowed to pick location\n        if (!state.options.itemInsertLocationFreedom) {\n            index = itemInsertLocation === 'before' ? -1 : state.items.length;\n        }\n\n        // add item to list\n        insertItem(state.items, item, index);\n\n        // sort items in list\n        if (isFunction(itemInsertLocation) && source) {\n            sortItems(state, itemInsertLocation);\n        }\n\n        // get a quick reference to the item id\n        const id = item.id;\n\n        // observe item events\n        item.on('init', () => {\n            dispatch('DID_INIT_ITEM', { id });\n        });\n\n        item.on('load-init', () => {\n            dispatch('DID_START_ITEM_LOAD', { id });\n        });\n\n        item.on('load-meta', () => {\n            dispatch('DID_UPDATE_ITEM_META', { id });\n        });\n\n        item.on('load-progress', progress => {\n            dispatch('DID_UPDATE_ITEM_LOAD_PROGRESS', { id, progress });\n        });\n\n        item.on('load-request-error', error => {\n            const mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n\n            // is client error, no way to recover\n            if (error.code >= 400 && error.code < 500) {\n                dispatch('DID_THROW_ITEM_INVALID', {\n                    id,\n                    error,\n                    status: {\n                        main: mainStatus,\n                        sub: `${error.code} (${error.body})`,\n                    },\n                });\n\n                // reject the file so can be dealt with through API\n                failure({ error, file: createItemAPI(item) });\n                return;\n            }\n\n            // is possible server error, so might be possible to retry\n            dispatch('DID_THROW_ITEM_LOAD_ERROR', {\n                id,\n                error,\n                status: {\n                    main: mainStatus,\n                    sub: state.options.labelTapToRetry,\n                },\n            });\n        });\n\n        item.on('load-file-error', error => {\n            dispatch('DID_THROW_ITEM_INVALID', {\n                id,\n                error: error.status,\n                status: error.status,\n            });\n            failure({ error: error.status, file: createItemAPI(item) });\n        });\n\n        item.on('load-abort', () => {\n            dispatch('REMOVE_ITEM', { query: id });\n        });\n\n        item.on('load-skip', () => {\n            item.on('metadata-update', change => {\n                if (!isFile(item.file)) return;\n                dispatch('DID_UPDATE_ITEM_METADATA', { id, change });\n            });\n\n            dispatch('COMPLETE_LOAD_ITEM', {\n                query: id,\n                item,\n                data: {\n                    source,\n                    success,\n                },\n            });\n        });\n\n        item.on('load', () => {\n            const handleAdd = shouldAdd => {\n                // no should not add this file\n                if (!shouldAdd) {\n                    dispatch('REMOVE_ITEM', {\n                        query: id,\n                    });\n                    return;\n                }\n\n                // now interested in metadata updates\n                item.on('metadata-update', change => {\n                    dispatch('DID_UPDATE_ITEM_METADATA', { id, change });\n                });\n\n                // let plugins decide if the output data should be prepared at this point\n                // means we'll do this and wait for idle state\n                applyFilterChain('SHOULD_PREPARE_OUTPUT', false, { item, query }).then(\n                    shouldPrepareOutput => {\n                        // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                        const beforePrepareFile = query('GET_BEFORE_PREPARE_FILE');\n                        if (beforePrepareFile)\n                            shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n\n                        const loadComplete = () => {\n                            dispatch('COMPLETE_LOAD_ITEM', {\n                                query: id,\n                                item,\n                                data: {\n                                    source,\n                                    success,\n                                },\n                            });\n\n                            listUpdated(dispatch, state);\n                        };\n\n                        // exit\n                        if (shouldPrepareOutput) {\n                            // wait for idle state and then run PREPARE_OUTPUT\n                            dispatch(\n                                'REQUEST_PREPARE_OUTPUT',\n                                {\n                                    query: id,\n                                    item,\n                                    success: file => {\n                                        dispatch('DID_PREPARE_OUTPUT', { id, file });\n                                        loadComplete();\n                                    },\n                                },\n                                true\n                            );\n\n                            return;\n                        }\n\n                        loadComplete();\n                    }\n                );\n            };\n\n            // item loaded, allow plugins to\n            // - read data (quickly)\n            // - add metadata\n            applyFilterChain('DID_LOAD_ITEM', item, { query, dispatch })\n                .then(() => {\n                    optionalPromise(query('GET_BEFORE_ADD_FILE'), createItemAPI(item)).then(\n                        handleAdd\n                    );\n                })\n                .catch(e => {\n                    if (!e || !e.error || !e.status) return handleAdd(false);\n                    dispatch('DID_THROW_ITEM_INVALID', {\n                        id,\n                        error: e.error,\n                        status: e.status,\n                    });\n                });\n        });\n\n        item.on('process-start', () => {\n            dispatch('DID_START_ITEM_PROCESSING', { id });\n        });\n\n        item.on('process-progress', progress => {\n            dispatch('DID_UPDATE_ITEM_PROCESS_PROGRESS', { id, progress });\n        });\n\n        item.on('process-error', error => {\n            dispatch('DID_THROW_ITEM_PROCESSING_ERROR', {\n                id,\n                error,\n                status: {\n                    main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                    sub: state.options.labelTapToRetry,\n                },\n            });\n        });\n\n        item.on('process-revert-error', error => {\n            dispatch('DID_THROW_ITEM_PROCESSING_REVERT_ERROR', {\n                id,\n                error,\n                status: {\n                    main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                    sub: state.options.labelTapToRetry,\n                },\n            });\n        });\n\n        item.on('process-complete', serverFileReference => {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                id,\n                error: null,\n                serverFileReference,\n            });\n            dispatch('DID_DEFINE_VALUE', { id, value: serverFileReference });\n        });\n\n        item.on('process-abort', () => {\n            dispatch('DID_ABORT_ITEM_PROCESSING', { id });\n        });\n\n        item.on('process-revert', () => {\n            dispatch('DID_REVERT_ITEM_PROCESSING', { id });\n            dispatch('DID_DEFINE_VALUE', { id, value: null });\n        });\n\n        // let view know the item has been inserted\n        dispatch('DID_ADD_ITEM', { id, index, interactionMethod });\n\n        listUpdated(dispatch, state);\n\n        // start loading the source\n        const { url, load, restore, fetch } = state.options.server || {};\n\n        item.load(\n            source,\n\n            // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n            createFileLoader(\n                origin === FileOrigin.INPUT\n                    ? // input, if is remote, see if should use custom fetch, else use default fetchBlob\n                      isString(source) && isExternalURL(source)\n                        ? fetch\n                            ? createFetchFunction(url, fetch)\n                            : fetchBlob // remote url\n                        : fetchBlob // try to fetch url\n                    : // limbo or local\n                    origin === FileOrigin.LIMBO\n                    ? createFetchFunction(url, restore) // limbo\n                    : createFetchFunction(url, load) // local\n            ),\n\n            // called when the file is loaded so it can be piped through the filters\n            (file, success, error) => {\n                // let's process the file\n                applyFilterChain('LOAD_FILE', file, { query })\n                    .then(success)\n                    .catch(error);\n            }\n        );\n    },\n\n    REQUEST_PREPARE_OUTPUT: ({ item, success, failure = () => {} }) => {\n        // error response if item archived\n        const err = {\n            error: createResponse('error', 0, 'Item not found'),\n            file: null,\n        };\n\n        // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n        if (item.archived) return failure(err);\n\n        // allow plugins to alter the file data\n        applyFilterChain('PREPARE_OUTPUT', item.file, { query, item }).then(result => {\n            applyFilterChain('COMPLETE_PREPARE_OUTPUT', result, { query, item }).then(result => {\n                // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                if (item.archived) return failure(err);\n\n                // we done!\n                success(result);\n            });\n        });\n    },\n\n    COMPLETE_LOAD_ITEM: ({ item, data }) => {\n        const { success, source } = data;\n\n        // sort items in list\n        const itemInsertLocation = query('GET_ITEM_INSERT_LOCATION');\n        if (isFunction(itemInsertLocation) && source) {\n            sortItems(state, itemInsertLocation);\n        }\n\n        // let interface know the item has loaded\n        dispatch('DID_LOAD_ITEM', {\n            id: item.id,\n            error: null,\n            serverFileReference: item.origin === FileOrigin.INPUT ? null : source,\n        });\n\n        // item has been successfully loaded and added to the\n        // list of items so can now be safely returned for use\n        success(createItemAPI(item));\n\n        // if this is a local server file we need to show a different state\n        if (item.origin === FileOrigin.LOCAL) {\n            dispatch('DID_LOAD_LOCAL_ITEM', { id: item.id });\n            return;\n        }\n\n        // if is a temp server file we prevent async upload call here (as the file is already on the server)\n        if (item.origin === FileOrigin.LIMBO) {\n            dispatch('DID_COMPLETE_ITEM_PROCESSING', {\n                id: item.id,\n                error: null,\n                serverFileReference: source,\n            });\n\n            dispatch('DID_DEFINE_VALUE', {\n                id: item.id,\n                value: item.serverId || source,\n            });\n            return;\n        }\n\n        // id we are allowed to upload the file immediately, lets do it\n        if (query('IS_ASYNC') && state.options.instantUpload) {\n            dispatch('REQUEST_ITEM_PROCESSING', { query: item.id });\n        }\n    },\n\n    RETRY_ITEM_LOAD: getItemByQueryFromState(state, item => {\n        // try loading the source one more time\n        item.retryLoad();\n    }),\n\n    REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, (item, success, failure) => {\n        dispatch(\n            'REQUEST_PREPARE_OUTPUT',\n            {\n                query: item.id,\n                item,\n                success: file => {\n                    dispatch('DID_PREPARE_OUTPUT', { id: item.id, file });\n                    success({\n                        file: item,\n                        output: file,\n                    });\n                },\n                failure,\n            },\n            true\n        );\n    }),\n\n    REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, (item, success, failure) => {\n        // cannot be queued (or is already queued)\n        const itemCanBeQueuedForProcessing =\n            // waiting for something\n            item.status === ItemStatus.IDLE ||\n            // processing went wrong earlier\n            item.status === ItemStatus.PROCESSING_ERROR;\n\n        // not ready to be processed\n        if (!itemCanBeQueuedForProcessing) {\n            const processNow = () =>\n                dispatch('REQUEST_ITEM_PROCESSING', { query: item, success, failure });\n\n            const process = () => (document.hidden ? processNow() : setTimeout(processNow, 32));\n\n            // if already done processing or tried to revert but didn't work, try again\n            if (\n                item.status === ItemStatus.PROCESSING_COMPLETE ||\n                item.status === ItemStatus.PROCESSING_REVERT_ERROR\n            ) {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                )\n                    .then(process)\n                    .catch(() => {}); // don't continue with processing if something went wrong\n            } else if (item.status === ItemStatus.PROCESSING) {\n                item.abortProcessing().then(process);\n            }\n\n            return;\n        }\n\n        // already queued for processing\n        if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n\n        item.requestProcessing();\n\n        dispatch('DID_REQUEST_ITEM_PROCESSING', { id: item.id });\n\n        dispatch('PROCESS_ITEM', { query: item, success, failure }, true);\n    }),\n\n    PROCESS_ITEM: getItemByQueryFromState(state, (item, success, failure) => {\n        const maxParallelUploads = query('GET_MAX_PARALLEL_UPLOADS');\n        const totalCurrentUploads = query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING).length;\n\n        // queue and wait till queue is freed up\n        if (totalCurrentUploads === maxParallelUploads) {\n            // queue for later processing\n            state.processingQueue.push({\n                id: item.id,\n                success,\n                failure,\n            });\n\n            // stop it!\n            return;\n        }\n\n        // if was not queued or is already processing exit here\n        if (item.status === ItemStatus.PROCESSING) return;\n\n        const processNext = () => {\n            // process queueud items\n            const queueEntry = state.processingQueue.shift();\n\n            // no items left\n            if (!queueEntry) return;\n\n            // get item reference\n            const { id, success, failure } = queueEntry;\n            const itemReference = getItemByQuery(state.items, id);\n\n            // if item was archived while in queue, jump to next\n            if (!itemReference || itemReference.archived) {\n                processNext();\n                return;\n            }\n\n            // process queued item\n            dispatch('PROCESS_ITEM', { query: id, success, failure }, true);\n        };\n\n        // we done function\n        item.onOnce('process-complete', () => {\n            success(createItemAPI(item));\n            processNext();\n\n            // if origin is local, and we're instant uploading, trigger remove of original\n            // as revert will remove file from list\n            const server = state.options.server;\n            const instantUpload = state.options.instantUpload;\n            if (instantUpload && item.origin === FileOrigin.LOCAL && isFunction(server.remove)) {\n                const noop = () => {};\n                item.origin = FileOrigin.LIMBO;\n                state.options.server.remove(item.source, noop, noop);\n            }\n\n            // All items processed? No errors?\n            const allItemsProcessed =\n                query('GET_ITEMS_BY_STATUS', ItemStatus.PROCESSING_COMPLETE).length ===\n                state.items.length;\n            if (allItemsProcessed) {\n                dispatch('DID_COMPLETE_ITEM_PROCESSING_ALL');\n            }\n        });\n\n        // we error function\n        item.onOnce('process-error', error => {\n            failure({ error, file: createItemAPI(item) });\n            processNext();\n        });\n\n        // start file processing\n        const options = state.options;\n        item.process(\n            createFileProcessor(\n                createProcessorFunction(options.server.url, options.server.process, options.name, {\n                    chunkTransferId: item.transferId,\n                    chunkServer: options.server.patch,\n                    chunkUploads: options.chunkUploads,\n                    chunkForce: options.chunkForce,\n                    chunkSize: options.chunkSize,\n                    chunkRetryDelays: options.chunkRetryDelays,\n                }),\n                {\n                    allowMinimumUploadDuration: query('GET_ALLOW_MINIMUM_UPLOAD_DURATION'),\n                }\n            ),\n            // called when the file is about to be processed so it can be piped through the transform filters\n            (file, success, error) => {\n                // allow plugins to alter the file data\n                applyFilterChain('PREPARE_OUTPUT', file, { query, item })\n                    .then(file => {\n                        dispatch('DID_PREPARE_OUTPUT', { id: item.id, file });\n\n                        success(file);\n                    })\n                    .catch(error);\n            }\n        );\n    }),\n\n    RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, item => {\n        dispatch('REQUEST_ITEM_PROCESSING', { query: item });\n    }),\n\n    REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, item => {\n        optionalPromise(query('GET_BEFORE_REMOVE_FILE'), createItemAPI(item)).then(shouldRemove => {\n            if (!shouldRemove) {\n                return;\n            }\n            dispatch('REMOVE_ITEM', { query: item });\n        });\n    }),\n\n    RELEASE_ITEM: getItemByQueryFromState(state, item => {\n        item.release();\n    }),\n\n    REMOVE_ITEM: getItemByQueryFromState(state, (item, success, failure, options) => {\n        const removeFromView = () => {\n            // get id reference\n            const id = item.id;\n\n            // archive the item, this does not remove it from the list\n            getItemById(state.items, id).archive();\n\n            // tell the view the item has been removed\n            dispatch('DID_REMOVE_ITEM', { error: null, id, item });\n\n            // now the list has been modified\n            listUpdated(dispatch, state);\n\n            // correctly removed\n            success(createItemAPI(item));\n        };\n\n        // if this is a local file and the `server.remove` function has been configured,\n        // send source there so dev can remove file from server\n        const server = state.options.server;\n        if (\n            item.origin === FileOrigin.LOCAL &&\n            server &&\n            isFunction(server.remove) &&\n            options.remove !== false\n        ) {\n            dispatch('DID_START_ITEM_REMOVE', { id: item.id });\n\n            server.remove(\n                item.source,\n                () => removeFromView(),\n                status => {\n                    dispatch('DID_THROW_ITEM_REMOVE_ERROR', {\n                        id: item.id,\n                        error: createResponse('error', 0, status, null),\n                        status: {\n                            main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                            sub: state.options.labelTapToRetry,\n                        },\n                    });\n                }\n            );\n        } else {\n            // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n            if (\n                (options.revert && item.origin !== FileOrigin.LOCAL && item.serverId !== null) ||\n                // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                // revert before removing from the view...\n                (state.options.chunkUploads && item.file.size > state.options.chunkSize) ||\n                (state.options.chunkUploads && state.options.chunkForce)\n            ) {\n                item.revert(\n                    createRevertFunction(state.options.server.url, state.options.server.revert),\n                    query('GET_FORCE_REVERT')\n                );\n            }\n\n            // can now safely remove from view\n            removeFromView();\n        }\n    }),\n\n    ABORT_ITEM_LOAD: getItemByQueryFromState(state, item => {\n        item.abortLoad();\n    }),\n\n    ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, item => {\n        // test if is already processed\n        if (item.serverId) {\n            dispatch('REVERT_ITEM_PROCESSING', { id: item.id });\n            return;\n        }\n\n        // abort\n        item.abortProcessing().then(() => {\n            const shouldRemove = state.options.instantUpload;\n            if (shouldRemove) {\n                dispatch('REMOVE_ITEM', { query: item.id });\n            }\n        });\n    }),\n\n    REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, item => {\n        // not instant uploading, revert immediately\n        if (!state.options.instantUpload) {\n            dispatch('REVERT_ITEM_PROCESSING', { query: item });\n            return;\n        }\n\n        // if we're instant uploading the file will also be removed if we revert,\n        // so if a before remove file hook is defined we need to run it now\n        const handleRevert = shouldRevert => {\n            if (!shouldRevert) return;\n            dispatch('REVERT_ITEM_PROCESSING', { query: item });\n        };\n\n        const fn = query('GET_BEFORE_REMOVE_FILE');\n        if (!fn) {\n            return handleRevert(true);\n        }\n\n        const requestRemoveResult = fn(createItemAPI(item));\n        if (requestRemoveResult == null) {\n            // undefined or null\n            return handleRevert(true);\n        }\n\n        if (typeof requestRemoveResult === 'boolean') {\n            return handleRevert(requestRemoveResult);\n        }\n\n        if (typeof requestRemoveResult.then === 'function') {\n            requestRemoveResult.then(handleRevert);\n        }\n    }),\n\n    REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, item => {\n        item.revert(\n            createRevertFunction(state.options.server.url, state.options.server.revert),\n            query('GET_FORCE_REVERT')\n        )\n            .then(() => {\n                const shouldRemove = state.options.instantUpload || isMockItem(item);\n                if (shouldRemove) {\n                    dispatch('REMOVE_ITEM', { query: item.id });\n                }\n            })\n            .catch(() => {});\n    }),\n\n    SET_OPTIONS: ({ options }) => {\n        // get all keys passed\n        const optionKeys = Object.keys(options);\n\n        // get prioritized keyed to include (remove once not in options object)\n        const prioritizedOptionKeys = PrioritizedOptions.filter(key => optionKeys.includes(key));\n\n        // order the keys, prioritized first, then rest\n        const orderedOptionKeys = [\n            // add prioritized first if passed to options, else remove\n            ...prioritizedOptionKeys,\n\n            // prevent duplicate keys\n            ...Object.keys(options).filter(key => !prioritizedOptionKeys.includes(key)),\n        ];\n\n        // dispatch set event for each option\n        orderedOptionKeys.forEach(key => {\n            dispatch(`SET_${fromCamels(key, '_').toUpperCase()}`, {\n                value: options[key],\n            });\n        });\n    },\n});\n\nconst PrioritizedOptions = [\n    'server', // must be processed before \"files\"\n];\n\nconst formatFilename = name => name;\n\nconst createElement$1 = tagName => {\n    return document.createElement(tagName);\n};\n\nconst text = (node, value) => {\n    let textNode = node.childNodes[0];\n    if (!textNode) {\n        textNode = document.createTextNode(value);\n        node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n        textNode.nodeValue = value;\n    }\n};\n\nconst polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {\n    const angleInRadians = (((angleInDegrees % 360) - 90) * Math.PI) / 180.0;\n    return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians),\n    };\n};\n\nconst describeArc = (x, y, radius, startAngle, endAngle, arcSweep) => {\n    const start = polarToCartesian(x, y, radius, endAngle);\n    const end = polarToCartesian(x, y, radius, startAngle);\n    return ['M', start.x, start.y, 'A', radius, radius, 0, arcSweep, 0, end.x, end.y].join(' ');\n};\n\nconst percentageArc = (x, y, radius, from, to) => {\n    let arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n        arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n        arcSweep = 0;\n    }\n    return describeArc(\n        x,\n        y,\n        radius,\n        Math.min(0.9999, from) * 360,\n        Math.min(0.9999, to) * 360,\n        arcSweep\n    );\n};\n\nconst create = ({ root, props }) => {\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n\n    // svg\n    const svg = createElement('svg');\n    root.ref.path = createElement('path', {\n        'stroke-width': 2,\n        'stroke-linecap': 'round',\n    });\n    svg.appendChild(root.ref.path);\n\n    root.ref.svg = svg;\n\n    root.appendChild(svg);\n};\n\nconst write = ({ root, props }) => {\n    if (props.opacity === 0) {\n        return;\n    }\n\n    if (props.align) {\n        root.element.dataset.align = props.align;\n    }\n\n    // get width of stroke\n    const ringStrokeWidth = parseInt(attr(root.ref.path, 'stroke-width'), 10);\n\n    // calculate size of ring\n    const size = root.rect.element.width * 0.5;\n\n    // ring state\n    let ringFrom = 0;\n    let ringTo = 0;\n\n    // now in busy mode\n    if (props.spin) {\n        ringFrom = 0;\n        ringTo = 0.5;\n    } else {\n        ringFrom = 0;\n        ringTo = props.progress;\n    }\n\n    // get arc path\n    const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n\n    // update progress bar\n    attr(root.ref.path, 'd', coordinates);\n\n    // hide while contains 0 value\n    attr(root.ref.path, 'stroke-opacity', props.spin || props.progress > 0 ? 1 : 0);\n};\n\nconst progressIndicator = createView({\n    tag: 'div',\n    name: 'progress-indicator',\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create,\n    write,\n    mixins: {\n        apis: ['progress', 'spin', 'align'],\n        styles: ['opacity'],\n        animations: {\n            opacity: { type: 'tween', duration: 500 },\n            progress: {\n                type: 'spring',\n                stiffness: 0.95,\n                damping: 0.65,\n                mass: 10,\n            },\n        },\n    },\n});\n\nconst create$1 = ({ root, props }) => {\n    root.element.innerHTML = (props.icon || '') + `<span>${props.label}</span>`;\n\n    props.isDisabled = false;\n};\n\nconst write$1 = ({ root, props }) => {\n    const { isDisabled } = props;\n    const shouldDisable = root.query('GET_DISABLED') || props.opacity === 0;\n\n    if (shouldDisable && !isDisabled) {\n        props.isDisabled = true;\n        attr(root.element, 'disabled', 'disabled');\n    } else if (!shouldDisable && isDisabled) {\n        props.isDisabled = false;\n        root.element.removeAttribute('disabled');\n    }\n};\n\nconst fileActionButton = createView({\n    tag: 'button',\n    attributes: {\n        type: 'button',\n    },\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'file-action-button',\n    mixins: {\n        apis: ['label'],\n        styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n        animations: {\n            scaleX: 'spring',\n            scaleY: 'spring',\n            translateX: 'spring',\n            translateY: 'spring',\n            opacity: { type: 'tween', duration: 250 },\n        },\n        listeners: true,\n    },\n    create: create$1,\n    write: write$1,\n});\n\nconst toNaturalFileSize = (bytes, decimalSeparator = '.', base = 1000, options = {}) => {\n    const {\n        labelBytes = 'bytes',\n        labelKilobytes = 'KB',\n        labelMegabytes = 'MB',\n        labelGigabytes = 'GB',\n    } = options;\n\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n\n    const KB = base;\n    const MB = base * base;\n    const GB = base * base * base;\n\n    // just bytes\n    if (bytes < KB) {\n        return `${bytes} ${labelBytes}`;\n    }\n\n    // kilobytes\n    if (bytes < MB) {\n        return `${Math.floor(bytes / KB)} ${labelKilobytes}`;\n    }\n\n    // megabytes\n    if (bytes < GB) {\n        return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;\n    }\n\n    // gigabytes\n    return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;\n};\n\nconst removeDecimalsWhenZero = (value, decimalCount, separator) => {\n    return value\n        .toFixed(decimalCount)\n        .split('.')\n        .filter(part => part !== '0')\n        .join(separator);\n};\n\nconst create$2 = ({ root, props }) => {\n    // filename\n    const fileName = createElement$1('span');\n    fileName.className = 'filepond--file-info-main';\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, 'aria-hidden', 'true');\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n\n    // filesize\n    const fileSize = createElement$1('span');\n    fileSize.className = 'filepond--file-info-sub';\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n\n    // set initial values\n    text(fileSize, root.query('GET_LABEL_FILE_WAITING_FOR_SIZE'));\n    text(fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n};\n\nconst updateFile = ({ root, props }) => {\n    text(\n        root.ref.fileSize,\n        toNaturalFileSize(\n            root.query('GET_ITEM_SIZE', props.id),\n            '.',\n            root.query('GET_FILE_SIZE_BASE'),\n            root.query('GET_FILE_SIZE_LABELS', root.query)\n        )\n    );\n    text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n};\n\nconst updateFileSizeOnError = ({ root, props }) => {\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query('GET_ITEM_SIZE', props.id))) {\n        updateFile({ root, props });\n        return;\n    }\n\n    text(root.ref.fileSize, root.query('GET_LABEL_FILE_SIZE_NOT_AVAILABLE'));\n};\n\nconst fileInfo = createView({\n    name: 'file-info',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: updateFile,\n        DID_UPDATE_ITEM_META: updateFile,\n        DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n        DID_THROW_ITEM_INVALID: updateFileSizeOnError,\n    }),\n    didCreateView: root => {\n        applyFilters('CREATE_VIEW', { ...root, view: root });\n    },\n    create: create$2,\n    mixins: {\n        styles: ['translateX', 'translateY'],\n        animations: {\n            translateX: 'spring',\n            translateY: 'spring',\n        },\n    },\n});\n\nconst toPercentage = value => Math.round(value * 100);\n\nconst create$3 = ({ root }) => {\n    // main status\n    const main = createElement$1('span');\n    main.className = 'filepond--file-status-main';\n    root.appendChild(main);\n    root.ref.main = main;\n\n    // sub status\n    const sub = createElement$1('span');\n    sub.className = 'filepond--file-status-sub';\n    root.appendChild(sub);\n    root.ref.sub = sub;\n\n    didSetItemLoadProgress({ root, action: { progress: null } });\n};\n\nconst didSetItemLoadProgress = ({ root, action }) => {\n    const title =\n        action.progress === null\n            ? root.query('GET_LABEL_FILE_LOADING')\n            : `${root.query('GET_LABEL_FILE_LOADING')} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n};\n\nconst didSetItemProcessProgress = ({ root, action }) => {\n    const title =\n        action.progress === null\n            ? root.query('GET_LABEL_FILE_PROCESSING')\n            : `${root.query('GET_LABEL_FILE_PROCESSING')} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n};\n\nconst didRequestItemProcessing = ({ root }) => {\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_CANCEL'));\n};\n\nconst didAbortItemProcessing = ({ root }) => {\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_ABORTED'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_RETRY'));\n};\n\nconst didCompleteItemProcessing = ({ root }) => {\n    text(root.ref.main, root.query('GET_LABEL_FILE_PROCESSING_COMPLETE'));\n    text(root.ref.sub, root.query('GET_LABEL_TAP_TO_UNDO'));\n};\n\nconst clear = ({ root }) => {\n    text(root.ref.main, '');\n    text(root.ref.sub, '');\n};\n\nconst error = ({ root, action }) => {\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n};\n\nconst fileStatus = createView({\n    name: 'file-status',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: clear,\n        DID_REVERT_ITEM_PROCESSING: clear,\n        DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n        DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n        DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n        DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n        DID_THROW_ITEM_LOAD_ERROR: error,\n        DID_THROW_ITEM_INVALID: error,\n        DID_THROW_ITEM_PROCESSING_ERROR: error,\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n        DID_THROW_ITEM_REMOVE_ERROR: error,\n    }),\n    didCreateView: root => {\n        applyFilters('CREATE_VIEW', { ...root, view: root });\n    },\n    create: create$3,\n    mixins: {\n        styles: ['translateX', 'translateY', 'opacity'],\n        animations: {\n            opacity: { type: 'tween', duration: 250 },\n            translateX: 'spring',\n            translateY: 'spring',\n        },\n    },\n});\n\n/**\n * Button definitions for the file view\n */\n\nconst Buttons = {\n    AbortItemLoad: {\n        label: 'GET_LABEL_BUTTON_ABORT_ITEM_LOAD',\n        action: 'ABORT_ITEM_LOAD',\n        className: 'filepond--action-abort-item-load',\n        align: 'LOAD_INDICATOR_POSITION', // right\n    },\n    RetryItemLoad: {\n        label: 'GET_LABEL_BUTTON_RETRY_ITEM_LOAD',\n        action: 'RETRY_ITEM_LOAD',\n        icon: 'GET_ICON_RETRY',\n        className: 'filepond--action-retry-item-load',\n        align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n    },\n    RemoveItem: {\n        label: 'GET_LABEL_BUTTON_REMOVE_ITEM',\n        action: 'REQUEST_REMOVE_ITEM',\n        icon: 'GET_ICON_REMOVE',\n        className: 'filepond--action-remove-item',\n        align: 'BUTTON_REMOVE_ITEM_POSITION', // left\n    },\n    ProcessItem: {\n        label: 'GET_LABEL_BUTTON_PROCESS_ITEM',\n        action: 'REQUEST_ITEM_PROCESSING',\n        icon: 'GET_ICON_PROCESS',\n        className: 'filepond--action-process-item',\n        align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n    },\n    AbortItemProcessing: {\n        label: 'GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING',\n        action: 'ABORT_ITEM_PROCESSING',\n        className: 'filepond--action-abort-item-processing',\n        align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n    },\n    RetryItemProcessing: {\n        label: 'GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING',\n        action: 'RETRY_ITEM_PROCESSING',\n        icon: 'GET_ICON_RETRY',\n        className: 'filepond--action-retry-item-processing',\n        align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n    },\n    RevertItemProcessing: {\n        label: 'GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING',\n        action: 'REQUEST_REVERT_ITEM_PROCESSING',\n        icon: 'GET_ICON_UNDO',\n        className: 'filepond--action-revert-item-processing',\n        align: 'BUTTON_PROCESS_ITEM_POSITION', // right\n    },\n};\n\n// make a list of buttons, we can then remove buttons from this list if they're disabled\nconst ButtonKeys = [];\nforin(Buttons, key => {\n    ButtonKeys.push(key);\n});\n\nconst calculateFileInfoOffset = root => {\n    if (getRemoveIndicatorAligment(root) === 'right') return 0;\n    const buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n};\n\nconst calculateButtonWidth = root => {\n    const buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n};\n\n// Force on full pixels so text stays crips\nconst calculateFileVerticalCenterOffset = root =>\n    Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\nconst calculateFileHorizontalCenterOffset = root =>\n    Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\n\nconst getLoadIndicatorAlignment = root => root.query('GET_STYLE_LOAD_INDICATOR_POSITION');\nconst getProcessIndicatorAlignment = root => root.query('GET_STYLE_PROGRESS_INDICATOR_POSITION');\nconst getRemoveIndicatorAligment = root => root.query('GET_STYLE_BUTTON_REMOVE_ITEM_POSITION');\n\nconst DefaultStyle = {\n    buttonAbortItemLoad: { opacity: 0 },\n    buttonRetryItemLoad: { opacity: 0 },\n    buttonRemoveItem: { opacity: 0 },\n    buttonProcessItem: { opacity: 0 },\n    buttonAbortItemProcessing: { opacity: 0 },\n    buttonRetryItemProcessing: { opacity: 0 },\n    buttonRevertItemProcessing: { opacity: 0 },\n    loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },\n    processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },\n    processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },\n    info: { translateX: 0, translateY: 0, opacity: 0 },\n    status: { translateX: 0, translateY: 0, opacity: 0 },\n};\n\nconst IdleStyle = {\n    buttonRemoveItem: { opacity: 1 },\n    buttonProcessItem: { opacity: 1 },\n    info: { translateX: calculateFileInfoOffset },\n    status: { translateX: calculateFileInfoOffset },\n};\n\nconst ProcessingStyle = {\n    buttonAbortItemProcessing: { opacity: 1 },\n    processProgressIndicator: { opacity: 1 },\n    status: { opacity: 1 },\n};\n\nconst StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n        buttonRemoveItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { translateX: calculateFileInfoOffset, opacity: 1 },\n    },\n    DID_START_ITEM_LOAD: {\n        buttonAbortItemLoad: { opacity: 1 },\n        loadProgressIndicator: { opacity: 1 },\n        status: { opacity: 1 },\n    },\n    DID_THROW_ITEM_LOAD_ERROR: {\n        buttonRetryItemLoad: { opacity: 1 },\n        buttonRemoveItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { opacity: 1 },\n    },\n    DID_START_ITEM_REMOVE: {\n        processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },\n        info: { translateX: calculateFileInfoOffset },\n        status: { opacity: 0 },\n    },\n    DID_THROW_ITEM_REMOVE_ERROR: {\n        processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },\n        buttonRemoveItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { opacity: 1, translateX: calculateFileInfoOffset },\n    },\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n        buttonRemoveItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { translateX: calculateFileInfoOffset },\n    },\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n        buttonRevertItemProcessing: { opacity: 1 },\n        info: { opacity: 1 },\n        status: { opacity: 1 },\n    },\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n        buttonRemoveItem: { opacity: 1 },\n        buttonRetryItemProcessing: { opacity: 1 },\n        status: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n    },\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n        buttonRevertItemProcessing: { opacity: 1 },\n        status: { opacity: 1 },\n        info: { opacity: 1 },\n    },\n    DID_ABORT_ITEM_PROCESSING: {\n        buttonRemoveItem: { opacity: 1 },\n        buttonProcessItem: { opacity: 1 },\n        info: { translateX: calculateFileInfoOffset },\n        status: { opacity: 1 },\n    },\n    DID_REVERT_ITEM_PROCESSING: IdleStyle,\n};\n\n// complete indicator view\nconst processingCompleteIndicatorView = createView({\n    create: ({ root }) => {\n        root.element.innerHTML = root.query('GET_ICON_DONE');\n    },\n    name: 'processing-complete-indicator',\n    ignoreRect: true,\n    mixins: {\n        styles: ['scaleX', 'scaleY', 'opacity'],\n        animations: {\n            scaleX: 'spring',\n            scaleY: 'spring',\n            opacity: { type: 'tween', duration: 250 },\n        },\n    },\n});\n\n/**\n * Creates the file view\n */\nconst create$4 = ({ root, props }) => {\n    // copy Buttons object\n    const LocalButtons = Object.keys(Buttons).reduce((prev, curr) => {\n        prev[curr] = { ...Buttons[curr] };\n        return prev;\n    }, {});\n\n    const { id } = props;\n\n    // allow reverting upload\n    const allowRevert = root.query('GET_ALLOW_REVERT');\n\n    // allow remove file\n    const allowRemove = root.query('GET_ALLOW_REMOVE');\n\n    // allow processing upload\n    const allowProcess = root.query('GET_ALLOW_PROCESS');\n\n    // is instant uploading, need this to determine the icon of the undo button\n    const instantUpload = root.query('GET_INSTANT_UPLOAD');\n\n    // is async set up\n    const isAsync = root.query('IS_ASYNC');\n\n    // should align remove item buttons\n    const alignRemoveItemButton = root.query('GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN');\n\n    // enabled buttons array\n    let buttonFilter;\n    if (isAsync) {\n        if (allowProcess && !allowRevert) {\n            // only remove revert button\n            buttonFilter = key => !/RevertItemProcessing/.test(key);\n        } else if (!allowProcess && allowRevert) {\n            // only remove process button\n            buttonFilter = key => !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n        } else if (!allowProcess && !allowRevert) {\n            // remove all process buttons\n            buttonFilter = key => !/Process/.test(key);\n        }\n    } else {\n        // no process controls available\n        buttonFilter = key => !/Process/.test(key);\n    }\n\n    const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n        LocalButtons['RevertItemProcessing'].label = 'GET_LABEL_BUTTON_REMOVE_ITEM';\n        LocalButtons['RevertItemProcessing'].icon = 'GET_ICON_REMOVE';\n    }\n\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n        const map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n        map.info.translateX = calculateFileHorizontalCenterOffset;\n        map.info.translateY = calculateFileVerticalCenterOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // should align center\n    if (isAsync && !allowProcess) {\n        [\n            'DID_START_ITEM_PROCESSING',\n            'DID_REQUEST_ITEM_PROCESSING',\n            'DID_UPDATE_ITEM_PROCESS_PROGRESS',\n            'DID_THROW_ITEM_PROCESSING_ERROR',\n        ].forEach(key => {\n            StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n        });\n        StyleMap['DID_THROW_ITEM_PROCESSING_ERROR'].status.translateX = calculateButtonWidth;\n    }\n\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n        LocalButtons['RevertItemProcessing'].align = 'BUTTON_REMOVE_ITEM_POSITION';\n        const map = StyleMap['DID_COMPLETE_ITEM_PROCESSING'];\n        map.info.translateX = calculateFileInfoOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };\n    }\n\n    // show/hide RemoveItem button\n    if (!allowRemove) {\n        LocalButtons['RemoveItem'].disabled = true;\n    }\n\n    // create the button views\n    forin(LocalButtons, (key, definition) => {\n        // create button\n        const buttonView = root.createChildView(fileActionButton, {\n            label: root.query(definition.label),\n            icon: root.query(definition.icon),\n            opacity: 0,\n        });\n\n        // should be appended?\n        if (enabledButtons.includes(key)) {\n            root.appendChildView(buttonView);\n        }\n\n        // toggle\n        if (definition.disabled) {\n            buttonView.element.setAttribute('disabled', 'disabled');\n            buttonView.element.setAttribute('hidden', 'hidden');\n        }\n\n        // add position attribute\n        buttonView.element.dataset.align = root.query(`GET_STYLE_${definition.align}`);\n\n        // add class\n        buttonView.element.classList.add(definition.className);\n\n        // handle interactions\n        buttonView.on('click', e => {\n            e.stopPropagation();\n            if (definition.disabled) return;\n            root.dispatch(definition.action, { query: id });\n        });\n\n        // set reference\n        root.ref[`button${key}`] = buttonView;\n    });\n\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(\n        root.createChildView(processingCompleteIndicatorView)\n    );\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(\n        `GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`\n    );\n\n    // create file info view\n    root.ref.info = root.appendChildView(root.createChildView(fileInfo, { id }));\n\n    // create file status view\n    root.ref.status = root.appendChildView(root.createChildView(fileStatus, { id }));\n\n    // add progress indicators\n    const loadIndicatorView = root.appendChildView(\n        root.createChildView(progressIndicator, {\n            opacity: 0,\n            align: root.query(`GET_STYLE_LOAD_INDICATOR_POSITION`),\n        })\n    );\n    loadIndicatorView.element.classList.add('filepond--load-indicator');\n    root.ref.loadProgressIndicator = loadIndicatorView;\n\n    const progressIndicatorView = root.appendChildView(\n        root.createChildView(progressIndicator, {\n            opacity: 0,\n            align: root.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`),\n        })\n    );\n    progressIndicatorView.element.classList.add('filepond--process-indicator');\n    root.ref.processProgressIndicator = progressIndicatorView;\n\n    // current active styles\n    root.ref.activeStyles = [];\n};\n\nconst write$2 = ({ root, actions, props }) => {\n    // route actions\n    route({ root, actions, props });\n\n    // select last state change action\n    let action = actions\n        .concat()\n        .filter(action => /^DID_/.test(action.type))\n        .reverse()\n        .find(action => StyleMap[action.type]);\n\n    // a new action happened, let's get the matching styles\n    if (action) {\n        // define new active styles\n        root.ref.activeStyles = [];\n\n        const stylesToApply = StyleMap[action.type];\n        forin(DefaultStyle, (name, defaultStyles) => {\n            // get reference to control\n            const control = root.ref[name];\n\n            // loop over all styles for this control\n            forin(defaultStyles, (key, defaultValue) => {\n                const value =\n                    stylesToApply[name] && typeof stylesToApply[name][key] !== 'undefined'\n                        ? stylesToApply[name][key]\n                        : defaultValue;\n                root.ref.activeStyles.push({ control, key, value });\n            });\n        });\n    }\n\n    // apply active styles to element\n    root.ref.activeStyles.forEach(({ control, key, value }) => {\n        control[key] = typeof value === 'function' ? value(root) : value;\n    });\n};\n\nconst route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({ root, action }) => {\n        root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({ root, action }) => {\n        root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({ root, action }) => {\n        root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: ({ root }) => {\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: ({ root }) => {\n        root.ref.loadProgressIndicator.spin = true;\n        root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: ({ root }) => {\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: ({ root, action }) => {\n        root.ref.loadProgressIndicator.spin = false;\n        root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ({ root, action }) => {\n        root.ref.processProgressIndicator.spin = false;\n        root.ref.processProgressIndicator.progress = action.progress;\n    },\n});\n\nconst file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: root => {\n        applyFilters('CREATE_VIEW', { ...root, view: root });\n    },\n    name: 'file',\n});\n\n/**\n * Creates the file view\n */\nconst create$5 = ({ root, props }) => {\n    // filename\n    root.ref.fileName = createElement$1('legend');\n    root.appendChild(root.ref.fileName);\n\n    // file appended\n    root.ref.file = root.appendChildView(root.createChildView(file, { id: props.id }));\n\n    // data has moved to data.js\n    root.ref.data = false;\n};\n\n/**\n * Data storage\n */\nconst didLoadItem = ({ root, props }) => {\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(root.ref.fileName, formatFilename(root.query('GET_ITEM_NAME', props.id)));\n};\n\nconst fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n        DID_LOAD_ITEM: didLoadItem,\n    }),\n    didCreateView: root => {\n        applyFilters('CREATE_VIEW', { ...root, view: root });\n    },\n    tag: 'fieldset',\n    name: 'file-wrapper',\n});\n\nconst PANEL_SPRING_PROPS = { type: 'spring', damping: 0.6, mass: 7 };\n\nconst create$6 = ({ root, props }) => {\n    [\n        {\n            name: 'top',\n        },\n        {\n            name: 'center',\n            props: {\n                translateY: null,\n                scaleY: null,\n            },\n            mixins: {\n                animations: {\n                    scaleY: PANEL_SPRING_PROPS,\n                },\n                styles: ['translateY', 'scaleY'],\n            },\n        },\n        {\n            name: 'bottom',\n            props: {\n                translateY: null,\n            },\n            mixins: {\n                animations: {\n                    translateY: PANEL_SPRING_PROPS,\n                },\n                styles: ['translateY'],\n            },\n        },\n    ].forEach(section => {\n        createSection(root, section, props.name);\n    });\n\n    root.element.classList.add(`filepond--${props.name}`);\n\n    root.ref.scalable = null;\n};\n\nconst createSection = (root, section, className) => {\n    const viewConstructor = createView({\n        name: `panel-${section.name} filepond--${className}`,\n        mixins: section.mixins,\n        ignoreRectUpdate: true,\n    });\n\n    const view = root.createChildView(viewConstructor, section.props);\n\n    root.ref[section.name] = root.appendChildView(view);\n};\n\nconst write$3 = ({ root, props }) => {\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n        root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n        root.element.dataset.scalable = root.ref.scalable;\n    }\n\n    // no height, can't set\n    if (!props.height) return;\n\n    // get child rects\n    const topRect = root.ref.top.rect.element;\n    const bottomRect = root.ref.bottom.rect.element;\n\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    const height = Math.max(topRect.height + bottomRect.height, props.height);\n\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n};\n\nconst panel = createView({\n    name: 'panel',\n    read: ({ root, props }) => (props.heightCurrent = root.ref.bottom.translateY),\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n        apis: ['height', 'heightCurrent', 'scalable'],\n    },\n});\n\nconst createDragHelper = items => {\n    const itemIds = items.map(item => item.id);\n    let prevIndex = undefined;\n    return {\n        setIndex: index => {\n            prevIndex = index;\n        },\n        getIndex: () => prevIndex,\n        getItemIndex: item => itemIds.indexOf(item.id),\n    };\n};\n\nconst ITEM_TRANSLATE_SPRING = {\n    type: 'spring',\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10,\n};\n\nconst ITEM_SCALE_SPRING = 'spring';\n\nconst StateMap = {\n    DID_START_ITEM_LOAD: 'busy',\n    DID_UPDATE_ITEM_LOAD_PROGRESS: 'loading',\n    DID_THROW_ITEM_INVALID: 'load-invalid',\n    DID_THROW_ITEM_LOAD_ERROR: 'load-error',\n    DID_LOAD_ITEM: 'idle',\n    DID_THROW_ITEM_REMOVE_ERROR: 'remove-error',\n    DID_START_ITEM_REMOVE: 'busy',\n    DID_START_ITEM_PROCESSING: 'busy processing',\n    DID_REQUEST_ITEM_PROCESSING: 'busy processing',\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: 'processing',\n    DID_COMPLETE_ITEM_PROCESSING: 'processing-complete',\n    DID_THROW_ITEM_PROCESSING_ERROR: 'processing-error',\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: 'processing-revert-error',\n    DID_ABORT_ITEM_PROCESSING: 'cancelled',\n    DID_REVERT_ITEM_PROCESSING: 'idle',\n};\n\n/**\n * Creates the file view\n */\nconst create$7 = ({ root, props }) => {\n    // select\n    root.ref.handleClick = e => root.dispatch('DID_ACTIVATE_ITEM', { id: props.id });\n\n    // set id\n    root.element.id = `filepond--item-${props.id}`;\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // file view\n    root.ref.container = root.appendChildView(root.createChildView(fileWrapper, { id: props.id }));\n\n    // file panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'item-panel' }));\n\n    // default start height\n    root.ref.panel.height = null;\n\n    // by default not marked for removal\n    props.markedForRemoval = false;\n\n    // if not allowed to reorder file items, exit here\n    if (!root.query('GET_ALLOW_REORDER')) return;\n\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = 'idle';\n\n    const grab = e => {\n        if (!e.isPrimary) return;\n\n        let removedActivateListener = false;\n\n        const origin = {\n            x: e.pageX,\n            y: e.pageY,\n        };\n\n        props.dragOrigin = {\n            x: root.translateX,\n            y: root.translateY,\n        };\n\n        props.dragCenter = {\n            x: e.offsetX,\n            y: e.offsetY,\n        };\n\n        const dragState = createDragHelper(root.query('GET_ACTIVE_ITEMS'));\n\n        root.dispatch('DID_GRAB_ITEM', { id: props.id, dragState });\n\n        const drag = e => {\n            if (!e.isPrimary) return;\n\n            e.stopPropagation();\n            e.preventDefault();\n\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y,\n            };\n\n            // if dragged stop listening to clicks, will re-add when done dragging\n            const dist =\n                props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;\n            if (dist > 16 && !removedActivateListener) {\n                removedActivateListener = true;\n                root.element.removeEventListener('click', root.ref.handleClick);\n            }\n\n            root.dispatch('DID_DRAG_ITEM', { id: props.id, dragState });\n        };\n\n        const drop = e => {\n            if (!e.isPrimary) return;\n\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y,\n            };\n\n            reset();\n        };\n\n        const cancel = () => {\n            reset();\n        };\n\n        const reset = () => {\n            document.removeEventListener('pointercancel', cancel);\n            document.removeEventListener('pointermove', drag);\n            document.removeEventListener('pointerup', drop);\n\n            root.dispatch('DID_DROP_ITEM', { id: props.id, dragState });\n\n            // start listening to clicks again\n            if (removedActivateListener) {\n                setTimeout(() => root.element.addEventListener('click', root.ref.handleClick), 0);\n            }\n        };\n\n        document.addEventListener('pointercancel', cancel);\n        document.addEventListener('pointermove', drag);\n        document.addEventListener('pointerup', drop);\n    };\n\n    root.element.addEventListener('pointerdown', grab);\n};\n\nconst route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: ({ root, action }) => {\n        root.height = action.height;\n    },\n});\n\nconst write$4 = createRoute(\n    {\n        DID_GRAB_ITEM: ({ root, props }) => {\n            props.dragOrigin = {\n                x: root.translateX,\n                y: root.translateY,\n            };\n        },\n        DID_DRAG_ITEM: ({ root }) => {\n            root.element.dataset.dragState = 'drag';\n        },\n        DID_DROP_ITEM: ({ root, props }) => {\n            props.dragOffset = null;\n            props.dragOrigin = null;\n            root.element.dataset.dragState = 'drop';\n        },\n    },\n    ({ root, actions, props, shouldOptimize }) => {\n        if (root.element.dataset.dragState === 'drop') {\n            if (root.scaleX <= 1) {\n                root.element.dataset.dragState = 'idle';\n            }\n        }\n\n        // select last state change action\n        let action = actions\n            .concat()\n            .filter(action => /^DID_/.test(action.type))\n            .reverse()\n            .find(action => StateMap[action.type]);\n\n        // no need to set same state twice\n        if (action && action.type !== props.currentState) {\n            // set current state\n            props.currentState = action.type;\n\n            // set state\n            root.element.dataset.filepondItemState = StateMap[props.currentState] || '';\n        }\n\n        // route actions\n        const aspectRatio =\n            root.query('GET_ITEM_PANEL_ASPECT_RATIO') || root.query('GET_PANEL_ASPECT_RATIO');\n        if (!aspectRatio) {\n            route$1({ root, actions, props });\n            if (!root.height && root.ref.container.rect.element.height > 0) {\n                root.height = root.ref.container.rect.element.height;\n            }\n        } else if (!shouldOptimize) {\n            root.height = root.rect.element.width * aspectRatio;\n        }\n\n        // sync panel height with item height\n        if (shouldOptimize) {\n            root.ref.panel.height = null;\n        }\n\n        root.ref.panel.height = root.height;\n    }\n);\n\nconst item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: ({ root, props }) => {\n        root.element.removeEventListener('click', root.ref.handleClick);\n        root.dispatch('RELEASE_ITEM', { query: props.id });\n    },\n    tag: 'li',\n    name: 'item',\n    mixins: {\n        apis: [\n            'id',\n            'interactionMethod',\n            'markedForRemoval',\n            'spawnDate',\n            'dragCenter',\n            'dragOrigin',\n            'dragOffset',\n        ],\n        styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity', 'height'],\n        animations: {\n            scaleX: ITEM_SCALE_SPRING,\n            scaleY: ITEM_SCALE_SPRING,\n            translateX: ITEM_TRANSLATE_SPRING,\n            translateY: ITEM_TRANSLATE_SPRING,\n            opacity: { type: 'tween', duration: 150 },\n        },\n    },\n});\n\nvar getItemsPerRow = (horizontalSpace, itemWidth) => {\n    // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n\n    return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n};\n\nconst getItemIndexByPosition = (view, children, positionInView) => {\n    if (!positionInView) return;\n\n    const horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    const l = children.length;\n    let last = null;\n\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n\n    // let's get the item width\n    const item = children[0];\n    const itemRect = item.rect.element;\n    const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    const itemWidth = itemRect.width + itemHorizontalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n        for (let index = 0; index < l; index++) {\n            const child = children[index];\n            const childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n            if (positionInView.top < childMid) {\n                return index;\n            }\n        }\n        return l;\n    }\n\n    // grid\n    const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    const itemHeight = itemRect.height + itemVerticalMargin;\n    for (let index = 0; index < l; index++) {\n        const indexX = index % itemsPerRow;\n        const indexY = Math.floor(index / itemsPerRow);\n\n        const offsetX = indexX * itemWidth;\n        const offsetY = indexY * itemHeight;\n\n        const itemTop = offsetY - itemRect.marginTop;\n        const itemRight = offsetX + itemWidth;\n        const itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n\n        if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n            if (positionInView.left < itemRight) {\n                return index;\n            } else if (index !== l - 1) {\n                last = index;\n            } else {\n                last = null;\n            }\n        }\n    }\n\n    if (last !== null) {\n        return last;\n    }\n\n    return l;\n};\n\nconst dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight() {\n        return this.height;\n    },\n    set setHeight(val) {\n        if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth() {\n        return this.width;\n    },\n    set setWidth(val) {\n        if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function(height, width) {\n        if (this.height === 0 || height === 0) this.height = height;\n        if (this.width === 0 || width === 0) this.width = width;\n    },\n};\n\nconst create$8 = ({ root }) => {\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, 'role', 'list');\n\n    root.ref.lastItemSpanwDate = Date.now();\n};\n\n/**\n * Inserts a new item\n * @param root\n * @param action\n */\nconst addItemView = ({ root, action }) => {\n    const { id, index, interactionMethod } = action;\n\n    root.ref.addIndex = index;\n\n    const now = Date.now();\n    let spawnDate = now;\n    let opacity = 1;\n\n    if (interactionMethod !== InteractionMethod.NONE) {\n        opacity = 0;\n        const cooldown = root.query('GET_ITEM_INSERT_INTERVAL');\n        const dist = now - root.ref.lastItemSpanwDate;\n        spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n\n    root.ref.lastItemSpanwDate = spawnDate;\n\n    root.appendChildView(\n        root.createChildView(\n            // view type\n            item,\n\n            // props\n            {\n                spawnDate,\n                id,\n                opacity,\n                interactionMethod,\n            }\n        ),\n        index\n    );\n};\n\nconst moveItem = (item, x, y, vx = 0, vy = 1) => {\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n        item.translateX = null;\n        item.translateY = null;\n        item.translateX = item.dragOrigin.x + item.dragOffset.x;\n        item.translateY = item.dragOrigin.y + item.dragOffset.y;\n        item.scaleX = 1.025;\n        item.scaleY = 1.025;\n    } else {\n        item.translateX = x;\n        item.translateY = y;\n\n        if (Date.now() > item.spawnDate) {\n            // reveal element\n            if (item.opacity === 0) {\n                introItemView(item, x, y, vx, vy);\n            }\n\n            // make sure is default scale every frame\n            item.scaleX = 1;\n            item.scaleY = 1;\n            item.opacity = 1;\n        }\n    }\n};\n\nconst introItemView = (item, x, y, vx, vy) => {\n    if (item.interactionMethod === InteractionMethod.NONE) {\n        item.translateX = null;\n        item.translateX = x;\n        item.translateY = null;\n        item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n        item.translateX = null;\n        item.translateX = x - vx * 20;\n\n        item.translateY = null;\n        item.translateY = y - vy * 10;\n\n        item.scaleX = 0.8;\n        item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n        item.translateY = null;\n        item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n        item.translateX = null;\n        item.translateX = x - 30;\n        item.translateY = null;\n    }\n};\n\n/**\n * Removes an existing item\n * @param root\n * @param action\n */\nconst removeItemView = ({ root, action }) => {\n    const { id } = action;\n\n    // get the view matching the given id\n    const view = root.childViews.find(child => child.id === id);\n\n    // if no view found, exit\n    if (!view) {\n        return;\n    }\n\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n\n    // mark for removal\n    view.markedForRemoval = true;\n};\n\nconst getItemHeight = child =>\n    child.rect.element.height +\n    child.rect.element.marginBottom * 0.5 +\n    child.rect.element.marginTop * 0.5;\nconst getItemWidth = child =>\n    child.rect.element.width +\n    child.rect.element.marginLeft * 0.5 +\n    child.rect.element.marginRight * 0.5;\n\nconst dragItem = ({ root, action }) => {\n    const { id, dragState } = action;\n\n    // reference to item\n    const item = root.query('GET_ITEM', { id });\n\n    // get the view matching the given id\n    const view = root.childViews.find(child => child.id === id);\n\n    const numItems = root.childViews.length;\n    const oldIndex = dragState.getItemIndex(item);\n\n    // if no view found, exit\n    if (!view) return;\n\n    const dragPosition = {\n        x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n        y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y,\n    };\n\n    // get drag area dimensions\n    const dragHeight = getItemHeight(view);\n    const dragWidth = getItemWidth(view);\n\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    let cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n\n    // rows are used to find when we have left the preview area bounding box\n    const rows = Math.floor(numItems / cols + 1);\n\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n\n    // get new index of dragged item\n    var location = {\n        y: Math.floor(dragPosition.y / dragHeight),\n        x: Math.floor(dragPosition.x / dragWidth),\n        getGridIndex: function getGridIndex() {\n            if (\n                dragPosition.y > dropAreaDimensions.getHeight ||\n                dragPosition.y < 0 ||\n                dragPosition.x > dropAreaDimensions.getWidth ||\n                dragPosition.x < 0\n            )\n                return oldIndex;\n            return this.y * cols + this.x;\n        },\n        getColIndex: function getColIndex() {\n            const items = root.query('GET_ACTIVE_ITEMS');\n            const visibleChildren = root.childViews.filter(child => child.rect.element.height);\n            const children = items.map(item =>\n                visibleChildren.find(childView => childView.id === item.id)\n            );\n            const currentIndex = children.findIndex(child => child === view);\n            const dragHeight = getItemHeight(view);\n            const l = children.length;\n            let idx = l;\n            let childHeight = 0;\n            let childBottom = 0;\n            let childTop = 0;\n            for (let i = 0; i < l; i++) {\n                childHeight = getItemHeight(children[i]);\n                childTop = childBottom;\n                childBottom = childTop + childHeight;\n                if (dragPosition.y < childBottom) {\n                    if (currentIndex > i) {\n                        if (dragPosition.y < childTop + dragHeight) {\n                            idx = i;\n                            break;\n                        }\n                        continue;\n                    }\n                    idx = i;\n                    break;\n                }\n            }\n            return idx;\n        },\n    };\n\n    // get new index\n    const index = cols > 1 ? location.getGridIndex() : location.getColIndex();\n    root.dispatch('MOVE_ITEM', { query: view, index });\n\n    // if the index of the item changed, dispatch reorder action\n    const currentIndex = dragState.getIndex();\n\n    if (currentIndex === undefined || currentIndex !== index) {\n        dragState.setIndex(index);\n\n        if (currentIndex === undefined) return;\n\n        root.dispatch('DID_REORDER_ITEMS', {\n            items: root.query('GET_ACTIVE_ITEMS'),\n            origin: oldIndex,\n            target: index,\n        });\n    }\n};\n\n/**\n * Setup action routes\n */\nconst route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem,\n});\n\n/**\n * Write to view\n * @param root\n * @param actions\n * @param props\n */\nconst write$5 = ({ root, props, actions, shouldOptimize }) => {\n    // route actions\n    route$2({ root, props, actions });\n\n    const { dragCoordinates } = props;\n\n    // available space on horizontal axis\n    const horizontalSpace = root.rect.element.width;\n\n    // only draw children that have dimensions\n    const visibleChildren = root.childViews.filter(child => child.rect.element.height);\n\n    // sort based on current active items\n    const children = root\n        .query('GET_ACTIVE_ITEMS')\n        .map(item => visibleChildren.find(child => child.id === item.id))\n        .filter(item => item);\n\n    // get index\n    const dragIndex = dragCoordinates\n        ? getItemIndexByPosition(root, children, dragCoordinates)\n        : null;\n\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    const addIndex = root.ref.addIndex || null;\n\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n\n    let dragIndexOffset = 0;\n    let removeIndexOffset = 0;\n    let addIndexOffset = 0;\n\n    if (children.length === 0) return;\n\n    const childRect = children[0].rect.element;\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n        let offsetY = 0;\n        let dragOffset = 0;\n\n        children.forEach((child, index) => {\n            if (dragIndex) {\n                let dist = index - dragIndex;\n                if (dist === -2) {\n                    dragOffset = -itemVerticalMargin * 0.25;\n                } else if (dist === -1) {\n                    dragOffset = -itemVerticalMargin * 0.75;\n                } else if (dist === 0) {\n                    dragOffset = itemVerticalMargin * 0.75;\n                } else if (dist === 1) {\n                    dragOffset = itemVerticalMargin * 0.25;\n                } else {\n                    dragOffset = 0;\n                }\n            }\n\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n\n            if (!child.markedForRemoval) {\n                moveItem(child, 0, offsetY + dragOffset);\n            }\n\n            let itemHeight = child.rect.element.height + itemVerticalMargin;\n\n            let visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n\n            offsetY += visualHeight;\n        });\n    }\n    // grid\n    else {\n        let prevX = 0;\n        let prevY = 0;\n\n        children.forEach((child, index) => {\n            if (index === dragIndex) {\n                dragIndexOffset = 1;\n            }\n\n            if (index === addIndex) {\n                addIndexOffset += 1;\n            }\n\n            if (child.markedForRemoval && child.opacity < 0.5) {\n                removeIndexOffset -= 1;\n            }\n\n            const visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n\n            const indexX = visualIndex % itemsPerRow;\n            const indexY = Math.floor(visualIndex / itemsPerRow);\n\n            const offsetX = indexX * itemWidth;\n            const offsetY = indexY * itemHeight;\n\n            const vectorX = Math.sign(offsetX - prevX);\n            const vectorY = Math.sign(offsetY - prevY);\n\n            prevX = offsetX;\n            prevY = offsetY;\n\n            if (child.markedForRemoval) return;\n\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n\n            moveItem(child, offsetX, offsetY, vectorX, vectorY);\n        });\n    }\n};\n\n/**\n * Filters actions that are meant specifically for a certain child of the list\n * @param child\n * @param actions\n */\nconst filterSetItemActions = (child, actions) =>\n    actions.filter(action => {\n        // if action has an id, filter out actions that don't have this child id\n        if (action.data && action.data.id) {\n            return child.id === action.data.id;\n        }\n\n        // allow all other actions\n        return true;\n    });\n\nconst list = createView({\n    create: create$8,\n    write: write$5,\n    tag: 'ul',\n    name: 'list',\n    didWriteView: ({ root }) => {\n        root.childViews\n            .filter(view => view.markedForRemoval && view.opacity === 0 && view.resting)\n            .forEach(view => {\n                view._destroy();\n                root.removeChildView(view);\n            });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n        apis: ['dragCoordinates'],\n    },\n});\n\nconst create$9 = ({ root, props }) => {\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n};\n\nconst storeDragCoordinates = ({ root, props, action }) => {\n    if (!root.query('GET_ITEM_INSERT_LOCATION_FREEDOM')) return;\n    props.dragCoordinates = {\n        left: action.position.scopeLeft - root.ref.list.rect.element.left,\n        top:\n            action.position.scopeTop -\n            (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop),\n    };\n};\n\nconst clearDragCoordinates = ({ props }) => {\n    props.dragCoordinates = null;\n};\n\nconst route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates,\n});\n\nconst write$6 = ({ root, props, actions }) => {\n    // route actions\n    route$3({ root, props, actions });\n\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n        props.overflowing = false;\n\n        // reset overflow state\n        root.element.dataset.state = '';\n        root.height = null;\n    }\n\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n        const newHeight = Math.round(props.overflow);\n        if (newHeight !== root.height) {\n            props.overflowing = true;\n            root.element.dataset.state = 'overflow';\n            root.height = newHeight;\n        }\n    }\n};\n\nconst listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: 'list-scroller',\n    mixins: {\n        apis: ['overflow', 'dragCoordinates'],\n        styles: ['height', 'translateY'],\n        animations: {\n            translateY: 'spring',\n        },\n    },\n});\n\nconst attrToggle = (element, name, state, enabledValue = '') => {\n    if (state) {\n        attr(element, name, enabledValue);\n    } else {\n        element.removeAttribute(name);\n    }\n};\n\nconst resetFileInput = input => {\n    // no value, no need to reset\n    if (!input || input.value === '') {\n        return;\n    }\n\n    try {\n        // for modern browsers\n        input.value = '';\n    } catch (err) {}\n\n    // for IE10\n    if (input.value) {\n        // quickly append input to temp form and reset form\n        const form = createElement$1('form');\n        const parentNode = input.parentNode;\n        const ref = input.nextSibling;\n        form.appendChild(input);\n        form.reset();\n\n        // re-inject input where it originally was\n        if (ref) {\n            parentNode.insertBefore(input, ref);\n        } else {\n            parentNode.appendChild(input);\n        }\n    }\n};\n\nconst create$a = ({ root, props }) => {\n    // set id so can be referenced from outside labels\n    root.element.id = `filepond--browser-${props.id}`;\n\n    // set name of element (is removed when a value is set)\n    attr(root.element, 'name', root.query('GET_NAME'));\n\n    // we have to link this element to the status element\n    attr(root.element, 'aria-controls', `filepond--assistant-${props.id}`);\n\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, 'aria-labelledby', `filepond--drop-label-${props.id}`);\n\n    // set configurable props\n    setAcceptedFileTypes({ root, action: { value: root.query('GET_ACCEPTED_FILE_TYPES') } });\n    toggleAllowMultiple({ root, action: { value: root.query('GET_ALLOW_MULTIPLE') } });\n    toggleDirectoryFilter({ root, action: { value: root.query('GET_ALLOW_DIRECTORIES_ONLY') } });\n    toggleDisabled({ root });\n    toggleRequired({ root, action: { value: root.query('GET_REQUIRED') } });\n    setCaptureMethod({ root, action: { value: root.query('GET_CAPTURE_METHOD') } });\n\n    // handle changes to the input field\n    root.ref.handleChange = e => {\n        if (!root.element.value) {\n            return;\n        }\n\n        // extract files and move value of webkitRelativePath path to _relativePath\n        const files = Array.from(root.element.files).map(file => {\n            file._relativePath = file.webkitRelativePath;\n            return file;\n        });\n\n        // we add a little delay so the OS file select window can move out of the way before we add our file\n        setTimeout(() => {\n            // load files\n            props.onload(files);\n\n            // reset input, it's just for exposing a method to drop files, should not retain any state\n            resetFileInput(root.element);\n        }, 250);\n    };\n\n    root.element.addEventListener('change', root.ref.handleChange);\n};\n\nconst setAcceptedFileTypes = ({ root, action }) => {\n    if (!root.query('GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE')) return;\n    attrToggle(root.element, 'accept', !!action.value, action.value ? action.value.join(',') : '');\n};\n\nconst toggleAllowMultiple = ({ root, action }) => {\n    attrToggle(root.element, 'multiple', action.value);\n};\n\nconst toggleDirectoryFilter = ({ root, action }) => {\n    attrToggle(root.element, 'webkitdirectory', action.value);\n};\n\nconst toggleDisabled = ({ root }) => {\n    const isDisabled = root.query('GET_DISABLED');\n    const doesAllowBrowse = root.query('GET_ALLOW_BROWSE');\n    const disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, 'disabled', disableField);\n};\n\nconst toggleRequired = ({ root, action }) => {\n    // want to remove required, always possible\n    if (!action.value) {\n        attrToggle(root.element, 'required', false);\n    }\n    // if want to make required, only possible when zero items\n    else if (root.query('GET_TOTAL_ITEMS') === 0) {\n        attrToggle(root.element, 'required', true);\n    }\n};\n\nconst setCaptureMethod = ({ root, action }) => {\n    attrToggle(root.element, 'capture', !!action.value, action.value === true ? '' : action.value);\n};\n\nconst updateRequiredStatus = ({ root }) => {\n    const { element } = root;\n    // always remove the required attribute when more than zero items\n    if (root.query('GET_TOTAL_ITEMS') > 0) {\n        attrToggle(element, 'required', false);\n        attrToggle(element, 'name', false);\n    } else {\n        // add name attribute\n        attrToggle(element, 'name', true, root.query('GET_NAME'));\n\n        // remove any validation messages\n        const shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n        if (shouldCheckValidity) {\n            element.setCustomValidity('');\n        }\n\n        // we only add required if the field has been deemed required\n        if (root.query('GET_REQUIRED')) {\n            attrToggle(element, 'required', true);\n        }\n    }\n};\n\nconst updateFieldValidityStatus = ({ root }) => {\n    const shouldCheckValidity = root.query('GET_CHECK_VALIDITY');\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query('GET_LABEL_INVALID_FIELD'));\n};\n\nconst browser = createView({\n    tag: 'input',\n    name: 'browser',\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n        type: 'file',\n    },\n    create: create$a,\n    destroy: ({ root }) => {\n        root.element.removeEventListener('change', root.ref.handleChange);\n    },\n    write: createRoute({\n        DID_LOAD_ITEM: updateRequiredStatus,\n        DID_REMOVE_ITEM: updateRequiredStatus,\n        DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n\n        DID_SET_DISABLED: toggleDisabled,\n        DID_SET_ALLOW_BROWSE: toggleDisabled,\n        DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n        DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n        DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n        DID_SET_CAPTURE_METHOD: setCaptureMethod,\n        DID_SET_REQUIRED: toggleRequired,\n    }),\n});\n\nconst Key = {\n    ENTER: 13,\n    SPACE: 32,\n};\n\nconst create$b = ({ root, props }) => {\n    // create the label and link it to the file browser\n    const label = createElement$1('label');\n    attr(label, 'for', `filepond--browser-${props.id}`);\n\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, 'id', `filepond--drop-label-${props.id}`);\n\n    // handle keys\n    root.ref.handleKeyDown = e => {\n        const isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n        if (!isActivationKey) return;\n        // stops from triggering the element a second time\n        e.preventDefault();\n\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n\n    root.ref.handleClick = e => {\n        const isLabelClick = e.target === label || label.contains(e.target);\n\n        // don't want to click twice\n        if (isLabelClick) return;\n\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n\n    // attach events\n    label.addEventListener('keydown', root.ref.handleKeyDown);\n    root.element.addEventListener('click', root.ref.handleClick);\n\n    // update\n    updateLabelValue(label, props.caption);\n\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n};\n\nconst updateLabelValue = (label, value) => {\n    label.innerHTML = value;\n    const clickable = label.querySelector('.filepond--label-action');\n    if (clickable) {\n        attr(clickable, 'tabindex', '0');\n    }\n    return value;\n};\n\nconst dropLabel = createView({\n    name: 'drop-label',\n    ignoreRect: true,\n    create: create$b,\n    destroy: ({ root }) => {\n        root.ref.label.addEventListener('keydown', root.ref.handleKeyDown);\n        root.element.removeEventListener('click', root.ref.handleClick);\n    },\n    write: createRoute({\n        DID_SET_LABEL_IDLE: ({ root, action }) => {\n            updateLabelValue(root.ref.label, action.value);\n        },\n    }),\n    mixins: {\n        styles: ['opacity', 'translateX', 'translateY'],\n        animations: {\n            opacity: { type: 'tween', duration: 150 },\n            translateX: 'spring',\n            translateY: 'spring',\n        },\n    },\n});\n\nconst blob = createView({\n    name: 'drip-blob',\n    ignoreRect: true,\n    mixins: {\n        styles: ['translateX', 'translateY', 'scaleX', 'scaleY', 'opacity'],\n        animations: {\n            scaleX: 'spring',\n            scaleY: 'spring',\n            translateX: 'spring',\n            translateY: 'spring',\n            opacity: { type: 'tween', duration: 250 },\n        },\n    },\n});\n\nconst addBlob = ({ root }) => {\n    const centerX = root.rect.element.width * 0.5;\n    const centerY = root.rect.element.height * 0.5;\n\n    root.ref.blob = root.appendChildView(\n        root.createChildView(blob, {\n            opacity: 0,\n            scaleX: 2.5,\n            scaleY: 2.5,\n            translateX: centerX,\n            translateY: centerY,\n        })\n    );\n};\n\nconst moveBlob = ({ root, action }) => {\n    if (!root.ref.blob) {\n        addBlob({ root });\n        return;\n    }\n\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n};\n\nconst hideBlob = ({ root }) => {\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.opacity = 0;\n};\n\nconst explodeBlob = ({ root }) => {\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n};\n\nconst write$7 = ({ root, props, actions }) => {\n    route$4({ root, props, actions });\n\n    const { blob } = root.ref;\n\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n        root.removeChildView(blob);\n        root.ref.blob = null;\n    }\n};\n\nconst route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob,\n});\n\nconst drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: 'drip',\n    write: write$7,\n});\n\nconst setInputFiles = (element, files) => {\n    try {\n        // Create a DataTransfer instance and add a newly created file\n        const dataTransfer = new DataTransfer();\n        files.forEach(file => {\n            if (file instanceof File) {\n                dataTransfer.items.add(file);\n            } else {\n                dataTransfer.items.add(\n                    new File([file], file.name, {\n                        type: file.type,\n                    })\n                );\n            }\n        });\n\n        // Assign the DataTransfer files list to the file input\n        element.files = dataTransfer.files;\n    } catch (err) {\n        return false;\n    }\n    return true;\n};\n\nconst create$c = ({ root }) => {\n    root.ref.fields = {};\n    const legend = document.createElement('legend');\n    legend.textContent = 'Files';\n    root.element.appendChild(legend);\n};\n\nconst getField = (root, id) => root.ref.fields[id];\n\nconst syncFieldPositionsWithItems = root => {\n    root.query('GET_ACTIVE_ITEMS').forEach(item => {\n        if (!root.ref.fields[item.id]) return;\n        root.element.appendChild(root.ref.fields[item.id]);\n    });\n};\n\nconst didReorderItems = ({ root }) => syncFieldPositionsWithItems(root);\n\nconst didAddItem = ({ root, action }) => {\n    const fileItem = root.query('GET_ITEM', action.id);\n    const isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n    const shouldUseFileInput = !isLocalFile && root.query('SHOULD_UPDATE_FILE_INPUT');\n    const dataContainer = createElement$1('input');\n    dataContainer.type = shouldUseFileInput ? 'file' : 'hidden';\n    dataContainer.name = root.query('GET_NAME');\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n};\n\nconst didLoadItem$1 = ({ root, action }) => {\n    const field = getField(root, action.id);\n    if (!field) return;\n\n    // store server ref in hidden input\n    if (action.serverFileReference !== null) field.value = action.serverFileReference;\n\n    // store file item in file input\n    if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n\n    const fileItem = root.query('GET_ITEM', action.id);\n    setInputFiles(field, [fileItem.file]);\n};\n\nconst didPrepareOutput = ({ root, action }) => {\n    // this timeout pushes the handler after 'load'\n    if (!root.query('SHOULD_UPDATE_FILE_INPUT')) return;\n    setTimeout(() => {\n        const field = getField(root, action.id);\n        if (!field) return;\n        setInputFiles(field, [action.file]);\n    }, 0);\n};\n\nconst didSetDisabled = ({ root }) => {\n    root.element.disabled = root.query('GET_DISABLED');\n};\n\nconst didRemoveItem = ({ root, action }) => {\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n};\n\n// only runs for server files. will refuse to update the value if the field\n// is a file field\nconst didDefineValue = ({ root, action }) => {\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n        // clear field value\n        field.removeAttribute('value');\n    } else {\n        // set field value\n        if (field.type != 'file') {\n            field.value = action.value;\n        }\n    }\n    syncFieldPositionsWithItems(root);\n};\n\nconst write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_PREPARE_OUTPUT: didPrepareOutput,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems,\n});\n\nconst data = createView({\n    tag: 'fieldset',\n    name: 'data',\n    create: create$c,\n    write: write$8,\n    ignoreRect: true,\n});\n\nconst getRootNode = element => ('getRootNode' in element ? element.getRootNode() : document);\n\nconst images = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'tiff'];\nconst text$1 = ['css', 'csv', 'html', 'txt'];\nconst map = {\n    zip: 'zip|compressed',\n    epub: 'application/epub+zip',\n};\n\nconst guesstimateMimeType = (extension = '') => {\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n        return (\n            'image/' + (extension === 'jpg' ? 'jpeg' : extension === 'svg' ? 'svg+xml' : extension)\n        );\n    }\n    if (text$1.includes(extension)) {\n        return 'text/' + extension;\n    }\n\n    return map[extension] || '';\n};\n\nconst requestDataTransferItems = dataTransfer =>\n    new Promise((resolve, reject) => {\n        // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n        const links = getLinks(dataTransfer);\n        if (links.length && !hasFiles(dataTransfer)) {\n            return resolve(links);\n        }\n        // try to get files from the transfer\n        getFiles(dataTransfer).then(resolve);\n    });\n\n/**\n * Test if datatransfer has files\n */\nconst hasFiles = dataTransfer => {\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n};\n\n/**\n * Extracts files from a DataTransfer object\n */\nconst getFiles = dataTransfer =>\n    new Promise((resolve, reject) => {\n        // get the transfer items as promises\n        const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])\n\n            // only keep file system items (files and directories)\n            .filter(item => isFileSystemItem(item))\n\n            // map each item to promise\n            .map(item => getFilesFromItem(item));\n\n        // if is empty, see if we can extract some info from the files property as a fallback\n        if (!promisedFiles.length) {\n            // TODO: test for directories (should not be allowed)\n            // Use FileReader, problem is that the files property gets lost in the process\n            resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n            return;\n        }\n\n        // done!\n        Promise.all(promisedFiles)\n            .then(returnedFileGroups => {\n                // flatten groups\n                const files = [];\n                returnedFileGroups.forEach(group => {\n                    files.push.apply(files, group);\n                });\n\n                // done (filter out empty files)!\n                resolve(\n                    files\n                        .filter(file => file)\n                        .map(file => {\n                            if (!file._relativePath) file._relativePath = file.webkitRelativePath;\n                            return file;\n                        })\n                );\n            })\n            .catch(console.error);\n    });\n\nconst isFileSystemItem = item => {\n    if (isEntry(item)) {\n        const entry = getAsEntry(item);\n        if (entry) {\n            return entry.isFile || entry.isDirectory;\n        }\n    }\n    return item.kind === 'file';\n};\n\nconst getFilesFromItem = item =>\n    new Promise((resolve, reject) => {\n        if (isDirectoryEntry(item)) {\n            getFilesInDirectory(getAsEntry(item))\n                .then(resolve)\n                .catch(reject);\n            return;\n        }\n\n        resolve([item.getAsFile()]);\n    });\n\nconst getFilesInDirectory = entry =>\n    new Promise((resolve, reject) => {\n        const files = [];\n\n        // the total entries to read\n        let dirCounter = 0;\n        let fileCounter = 0;\n\n        const resolveIfDone = () => {\n            if (fileCounter === 0 && dirCounter === 0) {\n                resolve(files);\n            }\n        };\n\n        // the recursive function\n        const readEntries = dirEntry => {\n            dirCounter++;\n\n            const directoryReader = dirEntry.createReader();\n\n            // directories are returned in batches, we need to process all batches before we're done\n            const readBatch = () => {\n                directoryReader.readEntries(entries => {\n                    if (entries.length === 0) {\n                        dirCounter--;\n                        resolveIfDone();\n                        return;\n                    }\n\n                    entries.forEach(entry => {\n                        // recursively read more directories\n                        if (entry.isDirectory) {\n                            readEntries(entry);\n                        } else {\n                            // read as file\n                            fileCounter++;\n\n                            entry.file(file => {\n                                const correctedFile = correctMissingFileType(file);\n                                if (entry.fullPath) correctedFile._relativePath = entry.fullPath;\n                                files.push(correctedFile);\n                                fileCounter--;\n                                resolveIfDone();\n                            });\n                        }\n                    });\n\n                    // try to get next batch of files\n                    readBatch();\n                }, reject);\n            };\n\n            // read first batch of files\n            readBatch();\n        };\n\n        // go!\n        readEntries(entry);\n    });\n\nconst correctMissingFileType = file => {\n    if (file.type.length) return file;\n    const date = file.lastModifiedDate;\n    const name = file.name;\n    const type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n};\n\nconst isDirectoryEntry = item => isEntry(item) && (getAsEntry(item) || {}).isDirectory;\n\nconst isEntry = item => 'webkitGetAsEntry' in item;\n\nconst getAsEntry = item => item.webkitGetAsEntry();\n\n/**\n * Extracts links from a DataTransfer object\n */\nconst getLinks = dataTransfer => {\n    let links = [];\n    try {\n        // look in meta data property\n        links = getLinksFromTransferMetaData(dataTransfer);\n        if (links.length) {\n            return links;\n        }\n        links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n        // nope nope nope (probably IE trouble)\n    }\n    return links;\n};\n\nconst getLinksFromTransferURLData = dataTransfer => {\n    let data = dataTransfer.getData('url');\n    if (typeof data === 'string' && data.length) {\n        return [data];\n    }\n    return [];\n};\n\nconst getLinksFromTransferMetaData = dataTransfer => {\n    let data = dataTransfer.getData('text/html');\n    if (typeof data === 'string' && data.length) {\n        const matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n        if (matches) {\n            return [matches[1]];\n        }\n    }\n    return [];\n};\n\nconst dragNDropObservers = [];\n\nconst eventPosition = e => ({\n    pageLeft: e.pageX,\n    pageTop: e.pageY,\n    scopeLeft: e.offsetX || e.layerX,\n    scopeTop: e.offsetY || e.layerY,\n});\n\nconst createDragNDropClient = (element, scopeToObserve, filterElement) => {\n    const observer = getDragNDropObserver(scopeToObserve);\n\n    const client = {\n        element,\n        filterElement,\n        state: null,\n        ondrop: () => {},\n        onenter: () => {},\n        ondrag: () => {},\n        onexit: () => {},\n        onload: () => {},\n        allowdrop: () => {},\n    };\n\n    client.destroy = observer.addListener(client);\n\n    return client;\n};\n\nconst getDragNDropObserver = element => {\n    // see if already exists, if so, return\n    const observer = dragNDropObservers.find(item => item.element === element);\n    if (observer) {\n        return observer;\n    }\n\n    // create new observer, does not yet exist for this element\n    const newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n};\n\nconst createDragNDropObserver = element => {\n    const clients = [];\n\n    const routes = {\n        dragenter,\n        dragover,\n        dragleave,\n        drop,\n    };\n\n    const handlers = {};\n\n    forin(routes, (event, createHandler) => {\n        handlers[event] = createHandler(element, clients);\n        element.addEventListener(event, handlers[event], false);\n    });\n\n    const observer = {\n        element,\n        addListener: client => {\n            // add as client\n            clients.push(client);\n\n            // return removeListener function\n            return () => {\n                // remove client\n                clients.splice(clients.indexOf(client), 1);\n\n                // if no more clients, clean up observer\n                if (clients.length === 0) {\n                    dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n\n                    forin(routes, event => {\n                        element.removeEventListener(event, handlers[event], false);\n                    });\n                }\n            };\n        },\n    };\n\n    return observer;\n};\n\nconst elementFromPoint = (root, point) => {\n    if (!('elementFromPoint' in root)) {\n        root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n};\n\nconst isEventTarget = (e, target) => {\n    // get root\n    const root = getRootNode(target);\n\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    const elementAtPosition = elementFromPoint(root, {\n        x: e.pageX - window.pageXOffset,\n        y: e.pageY - window.pageYOffset,\n    });\n\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n};\n\nlet initialTarget = null;\n\nconst setDropEffect = (dataTransfer, effect) => {\n    // is in try catch as IE11 will throw error if not\n    try {\n        dataTransfer.dropEffect = effect;\n    } catch (e) {}\n};\n\nconst dragenter = (root, clients) => e => {\n    e.preventDefault();\n\n    initialTarget = e.target;\n\n    clients.forEach(client => {\n        const { element, onenter } = client;\n\n        if (isEventTarget(e, element)) {\n            client.state = 'enter';\n\n            // fire enter event\n            onenter(eventPosition(e));\n        }\n    });\n};\n\nconst dragover = (root, clients) => e => {\n    e.preventDefault();\n\n    const dataTransfer = e.dataTransfer;\n\n    requestDataTransferItems(dataTransfer).then(items => {\n        let overDropTarget = false;\n\n        clients.some(client => {\n            const { filterElement, element, onenter, onexit, ondrag, allowdrop } = client;\n\n            // by default we can drop\n            setDropEffect(dataTransfer, 'copy');\n\n            // allow transfer of these items\n            const allowsTransfer = allowdrop(items);\n\n            // only used when can be dropped on page\n            if (!allowsTransfer) {\n                setDropEffect(dataTransfer, 'none');\n                return;\n            }\n\n            // targetting this client\n            if (isEventTarget(e, element)) {\n                overDropTarget = true;\n\n                // had no previous state, means we are entering this client\n                if (client.state === null) {\n                    client.state = 'enter';\n                    onenter(eventPosition(e));\n                    return;\n                }\n\n                // now over element (no matter if it allows the drop or not)\n                client.state = 'over';\n\n                // needs to allow transfer\n                if (filterElement && !allowsTransfer) {\n                    setDropEffect(dataTransfer, 'none');\n                    return;\n                }\n\n                // dragging\n                ondrag(eventPosition(e));\n            } else {\n                // should be over an element to drop\n                if (filterElement && !overDropTarget) {\n                    setDropEffect(dataTransfer, 'none');\n                }\n\n                // might have just left this client?\n                if (client.state) {\n                    client.state = null;\n                    onexit(eventPosition(e));\n                }\n            }\n        });\n    });\n};\n\nconst drop = (root, clients) => e => {\n    e.preventDefault();\n\n    const dataTransfer = e.dataTransfer;\n\n    requestDataTransferItems(dataTransfer).then(items => {\n        clients.forEach(client => {\n            const { filterElement, element, ondrop, onexit, allowdrop } = client;\n\n            client.state = null;\n\n            // if we're filtering on element we need to be over the element to drop\n            if (filterElement && !isEventTarget(e, element)) return;\n\n            // no transfer for this client\n            if (!allowdrop(items)) return onexit(eventPosition(e));\n\n            // we can drop these items on this client\n            ondrop(eventPosition(e), items);\n        });\n    });\n};\n\nconst dragleave = (root, clients) => e => {\n    if (initialTarget !== e.target) {\n        return;\n    }\n\n    clients.forEach(client => {\n        const { onexit } = client;\n\n        client.state = null;\n\n        onexit(eventPosition(e));\n    });\n};\n\nconst createHopper = (scope, validateItems, options) => {\n    // is now hopper scope\n    scope.classList.add('filepond--hopper');\n\n    // shortcuts\n    const { catchesDropsOnPage, requiresDropOnElement, filterItems = items => items } = options;\n\n    // create a dnd client\n    const client = createDragNDropClient(\n        scope,\n        catchesDropsOnPage ? document.documentElement : scope,\n        requiresDropOnElement\n    );\n\n    // current client state\n    let lastState = '';\n    let currentState = '';\n\n    // determines if a file may be dropped\n    client.allowdrop = items => {\n        // TODO: if we can, throw error to indicate the items cannot by dropped\n\n        return validateItems(filterItems(items));\n    };\n\n    client.ondrop = (position, items) => {\n        const filteredItems = filterItems(items);\n\n        if (!validateItems(filteredItems)) {\n            api.ondragend(position);\n            return;\n        }\n\n        currentState = 'drag-drop';\n\n        api.onload(filteredItems, position);\n    };\n\n    client.ondrag = position => {\n        api.ondrag(position);\n    };\n\n    client.onenter = position => {\n        currentState = 'drag-over';\n\n        api.ondragstart(position);\n    };\n\n    client.onexit = position => {\n        currentState = 'drag-exit';\n\n        api.ondragend(position);\n    };\n\n    const api = {\n        updateHopperState: () => {\n            if (lastState !== currentState) {\n                scope.dataset.hopperState = currentState;\n                lastState = currentState;\n            }\n        },\n        onload: () => {},\n        ondragstart: () => {},\n        ondrag: () => {},\n        ondragend: () => {},\n        destroy: () => {\n            // destroy client\n            client.destroy();\n        },\n    };\n\n    return api;\n};\n\nlet listening = false;\nconst listeners$1 = [];\n\nconst handlePaste = e => {\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    const activeEl = document.activeElement;\n    const isActiveElementEditable =\n        activeEl &&\n        (/textarea|input/i.test(activeEl.nodeName) ||\n            activeEl.getAttribute('contenteditable') === 'true');\n\n    if (isActiveElementEditable) {\n        // test textarea or input is contained in filepond root\n        let inScope = false;\n        let element = activeEl;\n        while (element !== document.body) {\n            if (element.classList.contains('filepond--root')) {\n                inScope = true;\n                break;\n            }\n            element = element.parentNode;\n        }\n\n        if (!inScope) return;\n    }\n\n    requestDataTransferItems(e.clipboardData).then(files => {\n        // no files received\n        if (!files.length) {\n            return;\n        }\n\n        // notify listeners of received files\n        listeners$1.forEach(listener => listener(files));\n    });\n};\n\nconst listen = cb => {\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n        return;\n    }\n\n    // add initial listener\n    listeners$1.push(cb);\n\n    // setup paste listener for entire page\n    if (listening) {\n        return;\n    }\n\n    listening = true;\n    document.addEventListener('paste', handlePaste);\n};\n\nconst unlisten = listener => {\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n\n    // clean up\n    if (listeners$1.length === 0) {\n        document.removeEventListener('paste', handlePaste);\n        listening = false;\n    }\n};\n\nconst createPaster = () => {\n    const cb = files => {\n        api.onload(files);\n    };\n\n    const api = {\n        destroy: () => {\n            unlisten(cb);\n        },\n        onload: () => {},\n    };\n\n    listen(cb);\n\n    return api;\n};\n\n/**\n * Creates the file view\n */\nconst create$d = ({ root, props }) => {\n    root.element.id = `filepond--assistant-${props.id}`;\n    attr(root.element, 'role', 'alert');\n    attr(root.element, 'aria-live', 'polite');\n    attr(root.element, 'aria-relevant', 'additions');\n};\n\nlet addFilesNotificationTimeout = null;\nlet notificationClearTimeout = null;\n\nconst filenames = [];\n\nconst assist = (root, message) => {\n    root.element.textContent = message;\n};\n\nconst clear$1 = root => {\n    root.element.textContent = '';\n};\n\nconst listModified = (root, filename, label) => {\n    const total = root.query('GET_TOTAL_ITEMS');\n    assist(\n        root,\n        `${label} ${filename}, ${total} ${\n            total === 1\n                ? root.query('GET_LABEL_FILE_COUNT_SINGULAR')\n                : root.query('GET_LABEL_FILE_COUNT_PLURAL')\n        }`\n    );\n\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(() => {\n        clear$1(root);\n    }, 1500);\n};\n\nconst isUsingFilePond = root => root.element.parentNode.contains(document.activeElement);\n\nconst itemAdded = ({ root, action }) => {\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n\n    root.element.textContent = '';\n    const item = root.query('GET_ITEM', action.id);\n    filenames.push(item.filename);\n\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(() => {\n        listModified(root, filenames.join(', '), root.query('GET_LABEL_FILE_ADDED'));\n        filenames.length = 0;\n    }, 750);\n};\n\nconst itemRemoved = ({ root, action }) => {\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n\n    const item = action.item;\n    listModified(root, item.filename, root.query('GET_LABEL_FILE_REMOVED'));\n};\n\nconst itemProcessed = ({ root, action }) => {\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    const item = root.query('GET_ITEM', action.id);\n    const filename = item.filename;\n    const label = root.query('GET_LABEL_FILE_PROCESSING_COMPLETE');\n\n    assist(root, `${filename} ${label}`);\n};\n\nconst itemProcessedUndo = ({ root, action }) => {\n    const item = root.query('GET_ITEM', action.id);\n    const filename = item.filename;\n    const label = root.query('GET_LABEL_FILE_PROCESSING_ABORTED');\n\n    assist(root, `${filename} ${label}`);\n};\n\nconst itemError = ({ root, action }) => {\n    const item = root.query('GET_ITEM', action.id);\n    const filename = item.filename;\n\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n\n    assist(root, `${action.status.main} ${filename} ${action.status.sub}`);\n};\n\nconst assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: itemAdded,\n        DID_REMOVE_ITEM: itemRemoved,\n        DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n\n        DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n        DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n\n        DID_THROW_ITEM_REMOVE_ERROR: itemError,\n        DID_THROW_ITEM_LOAD_ERROR: itemError,\n        DID_THROW_ITEM_INVALID: itemError,\n        DID_THROW_ITEM_PROCESSING_ERROR: itemError,\n    }),\n    tag: 'span',\n    name: 'assistant',\n});\n\nconst toCamels = (string, separator = '-') =>\n    string.replace(new RegExp(`${separator}.`, 'g'), sub => sub.charAt(1).toUpperCase());\n\nconst debounce = (func, interval = 16, immidiateOnly = true) => {\n    let last = Date.now();\n    let timeout = null;\n\n    return (...args) => {\n        clearTimeout(timeout);\n\n        const dist = Date.now() - last;\n\n        const fn = () => {\n            last = Date.now();\n            func(...args);\n        };\n\n        if (dist < interval) {\n            // we need to delay by the difference between interval and dist\n            // for example: if distance is 10 ms and interval is 16 ms,\n            // we need to wait an additional 6ms before calling the function)\n            if (!immidiateOnly) {\n                timeout = setTimeout(fn, interval - dist);\n            }\n        } else {\n            // go!\n            fn();\n        }\n    };\n};\n\nconst MAX_FILES_LIMIT = 1000000;\n\nconst prevent = e => e.preventDefault();\n\nconst create$e = ({ root, props }) => {\n    // Add id\n    const id = root.query('GET_ID');\n    if (id) {\n        root.element.id = id;\n    }\n\n    // Add className\n    const className = root.query('GET_CLASS_NAME');\n    if (className) {\n        className\n            .split(' ')\n            .filter(name => name.length)\n            .forEach(name => {\n                root.element.classList.add(name);\n            });\n    }\n\n    // Field label\n    root.ref.label = root.appendChildView(\n        root.createChildView(dropLabel, {\n            ...props,\n            translateY: null,\n            caption: root.query('GET_LABEL_IDLE'),\n        })\n    );\n\n    // List of items\n    root.ref.list = root.appendChildView(root.createChildView(listScroller, { translateY: null }));\n\n    // Background panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, { name: 'panel-root' }));\n\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(root.createChildView(assistant, { ...props }));\n\n    // Data\n    root.ref.data = root.appendChildView(root.createChildView(data, { ...props }));\n\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1('div');\n    root.ref.measure.style.height = '100%';\n    root.element.appendChild(root.ref.measure);\n\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n\n    // apply initial style properties\n    root.query('GET_STYLES')\n        .filter(style => !isEmpty(style.value))\n        .map(({ name, value }) => {\n            root.element.dataset[name] = value;\n        });\n\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(() => {\n        root.ref.updateHistory = [];\n        root.dispatch('DID_RESIZE_ROOT');\n    }, 250);\n\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    const canHover = window.matchMedia('(pointer: fine) and (hover: hover)').matches;\n    const hasPointerEvents = 'PointerEvent' in window;\n    if (root.query('GET_ALLOW_REORDER') && hasPointerEvents && !canHover) {\n        root.element.addEventListener('touchmove', prevent, { passive: false });\n        root.element.addEventListener('gesturestart', prevent);\n    }\n\n    // add credits\n    const credits = root.query('GET_CREDITS');\n    const hasCredits = credits.length === 2;\n    if (hasCredits) {\n        const frag = document.createElement('a');\n        frag.className = 'filepond--credits';\n        frag.href = credits[0];\n        frag.tabIndex = -1;\n        frag.target = '_blank';\n        frag.rel = 'noopener noreferrer nofollow';\n        frag.textContent = credits[1];\n        root.element.appendChild(frag);\n        root.ref.credits = frag;\n    }\n};\n\nconst write$9 = ({ root, props, actions }) => {\n    // route actions\n    route$5({ root, props, actions });\n\n    // apply style properties\n    actions\n        .filter(action => /^DID_SET_STYLE_/.test(action.type))\n        .filter(action => !isEmpty(action.data.value))\n        .map(({ type, data }) => {\n            const name = toCamels(type.substring(8).toLowerCase(), '_');\n            root.element.dataset[name] = data.value;\n            root.invalidateLayout();\n        });\n\n    if (root.rect.element.hidden) return;\n\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n        root.ref.widthPrevious = root.rect.element.width;\n        root.ref.widthUpdated();\n    }\n\n    // get box bounds, we do this only once\n    let bounds = root.ref.bounds;\n    if (!bounds) {\n        bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n\n        // destroy measure element\n        root.element.removeChild(root.ref.measure);\n        root.ref.measure = null;\n    }\n\n    // get quick references to various high level parts of the upload tool\n    const { hopper, label, list, panel } = root.ref;\n\n    // sets correct state to hopper scope\n    if (hopper) {\n        hopper.updateHopperState();\n    }\n\n    // bool to indicate if we're full or not\n    const aspectRatio = root.query('GET_PANEL_ASPECT_RATIO');\n    const isMultiItem = root.query('GET_ALLOW_MULTIPLE');\n    const totalItems = root.query('GET_TOTAL_ITEMS');\n    const maxItems = isMultiItem ? root.query('GET_MAX_FILES') || MAX_FILES_LIMIT : 1;\n    const atMaxCapacity = totalItems === maxItems;\n\n    // action used to add item\n    const addAction = actions.find(action => action.type === 'DID_ADD_ITEM');\n\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n        // get interaction type\n        const interactionMethod = addAction.data.interactionMethod;\n\n        // hide label\n        label.opacity = 0;\n\n        if (isMultiItem) {\n            label.translateY = -40;\n        } else {\n            if (interactionMethod === InteractionMethod.API) {\n                label.translateX = 40;\n            } else if (interactionMethod === InteractionMethod.BROWSE) {\n                label.translateY = 40;\n            } else {\n                label.translateY = 30;\n            }\n        }\n    } else if (!atMaxCapacity) {\n        label.opacity = 1;\n        label.translateX = 0;\n        label.translateY = 0;\n    }\n\n    const listItemMargin = calculateListItemMargin(root);\n\n    const listHeight = calculateListHeight(root);\n\n    const labelHeight = label.rect.element.height;\n    const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n\n    const listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    const listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n\n    const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n\n    // link list to label bottom position\n    list.translateY =\n        Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n\n    if (aspectRatio) {\n        // fixed aspect ratio\n\n        // calculate height based on width\n        const width = root.rect.element.width;\n        const height = width * aspectRatio;\n\n        // clear history if aspect ratio has changed\n        if (aspectRatio !== root.ref.previousAspectRatio) {\n            root.ref.previousAspectRatio = aspectRatio;\n            root.ref.updateHistory = [];\n        }\n\n        // remember this width\n        const history = root.ref.updateHistory;\n        history.push(width);\n\n        const MAX_BOUNCES = 2;\n        if (history.length > MAX_BOUNCES * 2) {\n            const l = history.length;\n            const bottom = l - 10;\n            let bounces = 0;\n            for (let i = l; i >= bottom; i--) {\n                if (history[i] === history[i - 2]) {\n                    bounces++;\n                }\n\n                if (bounces >= MAX_BOUNCES) {\n                    // dont adjust height\n                    return;\n                }\n            }\n        }\n\n        // fix height of panel so it adheres to aspect ratio\n        panel.scalable = false;\n        panel.height = height;\n\n        // available height for list\n        const listAvailableHeight =\n            // the height of the panel minus the label height\n            height -\n            currentLabelHeight -\n            // the room we leave open between the end of the list and the panel bottom\n            (listMarginBottom - listItemMargin.bottom) -\n            // if we're full we need to leave some room between the top of the panel and the list\n            (atMaxCapacity ? listMarginTop : 0);\n\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n\n        // set container bounds (so pushes siblings downwards)\n        root.height = height;\n    } else if (bounds.fixedHeight) {\n        // fixed height\n\n        // fix height of panel\n        panel.scalable = false;\n\n        // available height for list\n        const listAvailableHeight =\n            // the height of the panel minus the label height\n            bounds.fixedHeight -\n            currentLabelHeight -\n            // the room we leave open between the end of the list and the panel bottom\n            (listMarginBottom - listItemMargin.bottom) -\n            // if we're full we need to leave some room between the top of the panel and the list\n            (atMaxCapacity ? listMarginTop : 0);\n\n        // set list height\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n\n        // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n        // max-height\n\n        // not a fixed height panel\n        const isCappedHeight = visualHeight >= bounds.cappedHeight;\n        const panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n        panel.scalable = true;\n        panel.height = isCappedHeight\n            ? panelHeight\n            : panelHeight - listItemMargin.top - listItemMargin.bottom;\n\n        // available height for list\n        const listAvailableHeight =\n            // the height of the panel minus the label height\n            panelHeight -\n            currentLabelHeight -\n            // the room we leave open between the end of the list and the panel bottom\n            (listMarginBottom - listItemMargin.bottom) -\n            // if we're full we need to leave some room between the top of the panel and the list\n            (atMaxCapacity ? listMarginTop : 0);\n\n        // set list height (if is overflowing)\n        if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.min(\n            bounds.cappedHeight,\n            boundsHeight - listItemMargin.top - listItemMargin.bottom\n        );\n    } else {\n        // flexible height\n\n        // not a fixed height panel\n        const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n        panel.scalable = true;\n        panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent)\n        root.ref.credits.style.transform = `translateY(${panel.heightCurrent}px)`;\n};\n\nconst calculateListItemMargin = root => {\n    const item = root.ref.list.childViews[0].childViews[0];\n    return item\n        ? {\n              top: item.rect.element.marginTop,\n              bottom: item.rect.element.marginBottom,\n          }\n        : {\n              top: 0,\n              bottom: 0,\n          };\n};\n\nconst calculateListHeight = root => {\n    let visual = 0;\n    let bounds = 0;\n\n    // get file list reference\n    const scrollList = root.ref.list;\n    const itemList = scrollList.childViews[0];\n    const visibleChildren = itemList.childViews.filter(child => child.rect.element.height);\n    const children = root\n        .query('GET_ACTIVE_ITEMS')\n        .map(item => visibleChildren.find(child => child.id === item.id))\n        .filter(item => item);\n\n    // no children, done!\n    if (children.length === 0) return { visual, bounds };\n\n    const horizontalSpace = itemList.rect.element.width;\n    const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n\n    const childRect = children[0].rect.element;\n\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n\n    const newItem = typeof dragIndex !== 'undefined' && dragIndex >= 0 ? 1 : 0;\n    const removedItem = children.find(child => child.markedForRemoval && child.opacity < 0.45)\n        ? -1\n        : 0;\n    const verticalItemCount = children.length + newItem + removedItem;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n\n    // stack\n    if (itemsPerRow === 1) {\n        children.forEach(item => {\n            const height = item.rect.element.height + itemVerticalMargin;\n            bounds += height;\n            visual += height * item.opacity;\n        });\n    }\n    // grid\n    else {\n        bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n        visual = bounds;\n    }\n\n    return { visual, bounds };\n};\n\nconst calculateRootBoundingBoxHeight = root => {\n    const height = root.ref.measureHeight || null;\n    const cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    const fixedHeight = height === 0 ? null : height;\n\n    return {\n        cappedHeight,\n        fixedHeight,\n    };\n};\n\nconst exceedsMaxFiles = (root, items) => {\n    const allowReplace = root.query('GET_ALLOW_REPLACE');\n    const allowMultiple = root.query('GET_ALLOW_MULTIPLE');\n    const totalItems = root.query('GET_TOTAL_ITEMS');\n    let maxItems = root.query('GET_MAX_FILES');\n\n    // total amount of items being dragged\n    const totalBrowseItems = items.length;\n\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n        root.dispatch('DID_THROW_MAX_FILES', {\n            source: items,\n            error: createResponse('warning', 0, 'Max files'),\n        });\n        return true;\n    }\n\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : 1;\n\n    if (!allowMultiple && allowReplace) {\n        // There is only one item, so there is room to replace or add an item\n        return false;\n    }\n\n    // no more room?\n    const hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n        root.dispatch('DID_THROW_MAX_FILES', {\n            source: items,\n            error: createResponse('warning', 0, 'Max files'),\n        });\n        return true;\n    }\n\n    return false;\n};\n\nconst getDragIndex = (list, children, position) => {\n    const itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n        left: position.scopeLeft - itemList.rect.element.left,\n        top:\n            position.scopeTop -\n            (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop),\n    });\n};\n\n/**\n * Enable or disable file drop functionality\n */\nconst toggleDrop = root => {\n    const isAllowed = root.query('GET_ALLOW_DROP');\n    const isDisabled = root.query('GET_DISABLED');\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n        const hopper = createHopper(\n            root.element,\n            items => {\n                // allow quick validation of dropped items\n                const beforeDropFile = root.query('GET_BEFORE_DROP_FILE') || (() => true);\n\n                // all items should be validated by all filters as valid\n                const dropValidation = root.query('GET_DROP_VALIDATION');\n                return dropValidation\n                    ? items.every(\n                          item =>\n                              applyFilters('ALLOW_HOPPER_ITEM', item, {\n                                  query: root.query,\n                              }).every(result => result === true) && beforeDropFile(item)\n                      )\n                    : true;\n            },\n            {\n                filterItems: items => {\n                    const ignoredFiles = root.query('GET_IGNORED_FILES');\n                    return items.filter(item => {\n                        if (isFile(item)) {\n                            return !ignoredFiles.includes(item.name.toLowerCase());\n                        }\n                        return true;\n                    });\n                },\n                catchesDropsOnPage: root.query('GET_DROP_ON_PAGE'),\n                requiresDropOnElement: root.query('GET_DROP_ON_ELEMENT'),\n            }\n        );\n\n        hopper.onload = (items, position) => {\n            // get item children elements and sort based on list sort\n            const list = root.ref.list.childViews[0];\n            const visibleChildren = list.childViews.filter(child => child.rect.element.height);\n            const children = root\n                .query('GET_ACTIVE_ITEMS')\n                .map(item => visibleChildren.find(child => child.id === item.id))\n                .filter(item => item);\n\n            applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(queue => {\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n\n                // go\n                root.dispatch('ADD_ITEMS', {\n                    items: queue,\n                    index: getDragIndex(root.ref.list, children, position),\n                    interactionMethod: InteractionMethod.DROP,\n                });\n            });\n\n            root.dispatch('DID_DROP', { position });\n\n            root.dispatch('DID_END_DRAG', { position });\n        };\n\n        hopper.ondragstart = position => {\n            root.dispatch('DID_START_DRAG', { position });\n        };\n\n        hopper.ondrag = debounce(position => {\n            root.dispatch('DID_DRAG', { position });\n        });\n\n        hopper.ondragend = position => {\n            root.dispatch('DID_END_DRAG', { position });\n        };\n\n        root.ref.hopper = hopper;\n\n        root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n        root.ref.hopper.destroy();\n        root.ref.hopper = null;\n        root.removeChildView(root.ref.drip);\n    }\n};\n\n/**\n * Enable or disable browse functionality\n */\nconst toggleBrowse = (root, props) => {\n    const isAllowed = root.query('GET_ALLOW_BROWSE');\n    const isDisabled = root.query('GET_DISABLED');\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n        root.ref.browser = root.appendChildView(\n            root.createChildView(browser, {\n                ...props,\n                onload: items => {\n                    applyFilterChain('ADD_ITEMS', items, {\n                        dispatch: root.dispatch,\n                    }).then(queue => {\n                        // these files don't fit so stop here\n                        if (exceedsMaxFiles(root, queue)) return false;\n\n                        // add items!\n                        root.dispatch('ADD_ITEMS', {\n                            items: queue,\n                            index: -1,\n                            interactionMethod: InteractionMethod.BROWSE,\n                        });\n                    });\n                },\n            }),\n            0\n        );\n    } else if (!enabled && root.ref.browser) {\n        root.removeChildView(root.ref.browser);\n        root.ref.browser = null;\n    }\n};\n\n/**\n * Enable or disable paste functionality\n */\nconst togglePaste = root => {\n    const isAllowed = root.query('GET_ALLOW_PASTE');\n    const isDisabled = root.query('GET_DISABLED');\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n        root.ref.paster = createPaster();\n        root.ref.paster.onload = items => {\n            applyFilterChain('ADD_ITEMS', items, { dispatch: root.dispatch }).then(queue => {\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n\n                // add items!\n                root.dispatch('ADD_ITEMS', {\n                    items: queue,\n                    index: -1,\n                    interactionMethod: InteractionMethod.PASTE,\n                });\n            });\n        };\n    } else if (!enabled && root.ref.paster) {\n        root.ref.paster.destroy();\n        root.ref.paster = null;\n    }\n};\n\n/**\n * Route actions\n */\nconst route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: ({ root, props }) => {\n        toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: ({ root }) => {\n        toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: ({ root }) => {\n        togglePaste(root);\n    },\n    DID_SET_DISABLED: ({ root, props }) => {\n        toggleDrop(root);\n        togglePaste(root);\n        toggleBrowse(root, props);\n        const isDisabled = root.query('GET_DISABLED');\n        if (isDisabled) {\n            root.element.dataset.disabled = 'disabled';\n        } else {\n            // delete root.element.dataset.disabled; <= this does not work on iOS 10\n            root.element.removeAttribute('data-disabled');\n        }\n    },\n});\n\nconst root = createView({\n    name: 'root',\n    read: ({ root }) => {\n        if (root.ref.measure) {\n            root.ref.measureHeight = root.ref.measure.offsetHeight;\n        }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: ({ root }) => {\n        if (root.ref.paster) {\n            root.ref.paster.destroy();\n        }\n        if (root.ref.hopper) {\n            root.ref.hopper.destroy();\n        }\n        root.element.removeEventListener('touchmove', prevent);\n        root.element.removeEventListener('gesturestart', prevent);\n    },\n    mixins: {\n        styles: ['height'],\n    },\n});\n\n// creates the app\nconst createApp = (initialOptions = {}) => {\n    // let element\n    let originalElement = null;\n\n    // get default options\n    const defaultOptions = getOptions();\n\n    // create the data store, this will contain all our app info\n    const store = createStore(\n        // initial state (should be serializable)\n        createInitialState(defaultOptions),\n\n        // queries\n        [queries, createOptionQueries(defaultOptions)],\n\n        // action handlers\n        [actions, createOptionActions(defaultOptions)]\n    );\n\n    // set initial options\n    store.dispatch('SET_OPTIONS', { options: initialOptions });\n\n    // kick thread if visibility changes\n    const visibilityHandler = () => {\n        if (document.hidden) return;\n        store.dispatch('KICK');\n    };\n    document.addEventListener('visibilitychange', visibilityHandler);\n\n    // re-render on window resize start and finish\n    let resizeDoneTimer = null;\n    let isResizing = false;\n    let isResizingHorizontally = false;\n    let initialWindowWidth = null;\n    let currentWindowWidth = null;\n    const resizeHandler = () => {\n        if (!isResizing) {\n            isResizing = true;\n        }\n        clearTimeout(resizeDoneTimer);\n        resizeDoneTimer = setTimeout(() => {\n            isResizing = false;\n            initialWindowWidth = null;\n            currentWindowWidth = null;\n            if (isResizingHorizontally) {\n                isResizingHorizontally = false;\n                store.dispatch('DID_STOP_RESIZE');\n            }\n        }, 500);\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    // render initial view\n    const view = root(store, { id: getUniqueId() });\n\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    let isResting = false;\n    let isHidden = false;\n\n    const readWriteApi = {\n        // necessary for update loop\n\n        /**\n         * Reads from dom (never call manually)\n         * @private\n         */\n        _read: () => {\n            // test if we're resizing horizontally\n            // TODO: see if we can optimize this by measuring root rect\n            if (isResizing) {\n                currentWindowWidth = window.innerWidth;\n                if (!initialWindowWidth) {\n                    initialWindowWidth = currentWindowWidth;\n                }\n\n                if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                    store.dispatch('DID_START_RESIZE');\n                    isResizingHorizontally = true;\n                }\n            }\n\n            if (isHidden && isResting) {\n                // test if is no longer hidden\n                isResting = view.element.offsetParent === null;\n            }\n\n            // if resting, no need to read as numbers will still all be correct\n            if (isResting) return;\n\n            // read view data\n            view._read();\n\n            // if is hidden we need to know so we exit rest mode when revealed\n            isHidden = view.rect.element.hidden;\n        },\n\n        /**\n         * Writes to dom (never call manually)\n         * @private\n         */\n        _write: ts => {\n            // get all actions from store\n            const actions = store\n                .processActionQueue()\n\n                // filter out set actions (these will automatically trigger DID_SET)\n                .filter(action => !/^SET_/.test(action.type));\n\n            // if was idling and no actions stop here\n            if (isResting && !actions.length) return;\n\n            // some actions might trigger events\n            routeActionsToEvents(actions);\n\n            // update the view\n            isResting = view._write(ts, actions, isResizingHorizontally);\n\n            // will clean up all archived items\n            removeReleasedItems(store.query('GET_ITEMS'));\n\n            // now idling\n            if (isResting) {\n                store.processDispatchQueue();\n            }\n        },\n    };\n\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    const createEvent = name => data => {\n        // create default event\n        const event = {\n            type: name,\n        };\n\n        // no data to add\n        if (!data) {\n            return event;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('error')) {\n            event.error = data.error ? { ...data.error } : null;\n        }\n\n        if (data.status) {\n            event.status = { ...data.status };\n        }\n\n        if (data.file) {\n            event.output = data.file;\n        }\n\n        // only source is available, else add item if possible\n        if (data.source) {\n            event.file = data.source;\n        } else if (data.item || data.id) {\n            const item = data.item ? data.item : store.query('GET_ITEM', data.id);\n            event.file = item ? createItemAPI(item) : null;\n        }\n\n        // map all items in a possible items array\n        if (data.items) {\n            event.items = data.items.map(createItemAPI);\n        }\n\n        // if this is a progress event add the progress amount\n        if (/progress/.test(name)) {\n            event.progress = data.progress;\n        }\n\n        // copy relevant props\n        if (data.hasOwnProperty('origin') && data.hasOwnProperty('target')) {\n            event.origin = data.origin;\n            event.target = data.target;\n        }\n\n        return event;\n    };\n\n    const eventRoutes = {\n        DID_DESTROY: createEvent('destroy'),\n\n        DID_INIT: createEvent('init'),\n\n        DID_THROW_MAX_FILES: createEvent('warning'),\n\n        DID_INIT_ITEM: createEvent('initfile'),\n        DID_START_ITEM_LOAD: createEvent('addfilestart'),\n        DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent('addfileprogress'),\n        DID_LOAD_ITEM: createEvent('addfile'),\n\n        DID_THROW_ITEM_INVALID: [createEvent('error'), createEvent('addfile')],\n\n        DID_THROW_ITEM_LOAD_ERROR: [createEvent('error'), createEvent('addfile')],\n\n        DID_THROW_ITEM_REMOVE_ERROR: [createEvent('error'), createEvent('removefile')],\n\n        DID_PREPARE_OUTPUT: createEvent('preparefile'),\n\n        DID_START_ITEM_PROCESSING: createEvent('processfilestart'),\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent('processfileprogress'),\n        DID_ABORT_ITEM_PROCESSING: createEvent('processfileabort'),\n        DID_COMPLETE_ITEM_PROCESSING: createEvent('processfile'),\n        DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent('processfiles'),\n        DID_REVERT_ITEM_PROCESSING: createEvent('processfilerevert'),\n\n        DID_THROW_ITEM_PROCESSING_ERROR: [createEvent('error'), createEvent('processfile')],\n\n        DID_REMOVE_ITEM: createEvent('removefile'),\n\n        DID_UPDATE_ITEMS: createEvent('updatefiles'),\n\n        DID_ACTIVATE_ITEM: createEvent('activatefile'),\n\n        DID_REORDER_ITEMS: createEvent('reorderfiles'),\n    };\n\n    const exposeEvent = event => {\n        // create event object to be dispatched\n        const detail = { pond: exports, ...event };\n        delete detail.type;\n        view.element.dispatchEvent(\n            new CustomEvent(`FilePond:${event.type}`, {\n                // event info\n                detail,\n\n                // event behaviour\n                bubbles: true,\n                cancelable: true,\n                composed: true, // triggers listeners outside of shadow root\n            })\n        );\n\n        // event object to params used for `on()` event handlers and callbacks `oninit()`\n        const params = [];\n\n        // if is possible error event, make it the first param\n        if (event.hasOwnProperty('error')) {\n            params.push(event.error);\n        }\n\n        // file is always section\n        if (event.hasOwnProperty('file')) {\n            params.push(event.file);\n        }\n\n        // append other props\n        const filtered = ['type', 'error', 'file'];\n        Object.keys(event)\n            .filter(key => !filtered.includes(key))\n            .forEach(key => params.push(event[key]));\n\n        // on(type, () => { })\n        exports.fire(event.type, ...params);\n\n        // oninit = () => {}\n        const handler = store.query(`GET_ON${event.type.toUpperCase()}`);\n        if (handler) {\n            handler(...params);\n        }\n    };\n\n    const routeActionsToEvents = actions => {\n        if (!actions.length) return;\n        actions\n            .filter(action => eventRoutes[action.type])\n            .forEach(action => {\n                const routes = eventRoutes[action.type];\n                (Array.isArray(routes) ? routes : [routes]).forEach(route => {\n                    // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                    if (action.type === 'DID_INIT_ITEM') {\n                        exposeEvent(route(action.data));\n                    } else {\n                        setTimeout(() => {\n                            exposeEvent(route(action.data));\n                        }, 0);\n                    }\n                });\n            });\n    };\n\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    const setOptions = options => store.dispatch('SET_OPTIONS', { options });\n\n    const getFile = query => store.query('GET_ACTIVE_ITEM', query);\n\n    const prepareFile = query =>\n        new Promise((resolve, reject) => {\n            store.dispatch('REQUEST_ITEM_PREPARE', {\n                query,\n                success: item => {\n                    resolve(item);\n                },\n                failure: error => {\n                    reject(error);\n                },\n            });\n        });\n\n    const addFile = (source, options = {}) =>\n        new Promise((resolve, reject) => {\n            addFiles([{ source, options }], { index: options.index })\n                .then(items => resolve(items && items[0]))\n                .catch(reject);\n        });\n\n    const isFilePondFile = obj => obj.file && obj.id;\n\n    const removeFile = (query, options) => {\n        // if only passed options\n        if (typeof query === 'object' && !isFilePondFile(query) && !options) {\n            options = query;\n            query = undefined;\n        }\n\n        // request item removal\n        store.dispatch('REMOVE_ITEM', { ...options, query });\n\n        // see if item has been removed\n        return store.query('GET_ACTIVE_ITEM', query) === null;\n    };\n\n    const addFiles = (...args) =>\n        new Promise((resolve, reject) => {\n            const sources = [];\n            const options = {};\n\n            // user passed a sources array\n            if (isArray(args[0])) {\n                sources.push.apply(sources, args[0]);\n                Object.assign(options, args[1] || {});\n            } else {\n                // user passed sources as arguments, last one might be options object\n                const lastArgument = args[args.length - 1];\n                if (typeof lastArgument === 'object' && !(lastArgument instanceof Blob)) {\n                    Object.assign(options, args.pop());\n                }\n\n                // add rest to sources\n                sources.push(...args);\n            }\n\n            store.dispatch('ADD_ITEMS', {\n                items: sources,\n                index: options.index,\n                interactionMethod: InteractionMethod.API,\n                success: resolve,\n                failure: reject,\n            });\n        });\n\n    const getFiles = () => store.query('GET_ACTIVE_ITEMS');\n\n    const processFile = query =>\n        new Promise((resolve, reject) => {\n            store.dispatch('REQUEST_ITEM_PROCESSING', {\n                query,\n                success: item => {\n                    resolve(item);\n                },\n                failure: error => {\n                    reject(error);\n                },\n            });\n        });\n\n    const prepareFiles = (...args) => {\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        const items = queries.length ? queries : getFiles();\n        return Promise.all(items.map(prepareFile));\n    };\n\n    const processFiles = (...args) => {\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        if (!queries.length) {\n            const files = getFiles().filter(\n                item =>\n                    !(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) &&\n                    item.status !== ItemStatus.PROCESSING &&\n                    item.status !== ItemStatus.PROCESSING_COMPLETE &&\n                    item.status !== ItemStatus.PROCESSING_REVERT_ERROR\n            );\n            return Promise.all(files.map(processFile));\n        }\n        return Promise.all(queries.map(processFile));\n    };\n\n    const removeFiles = (...args) => {\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n\n        let options;\n        if (typeof queries[queries.length - 1] === 'object') {\n            options = queries.pop();\n        } else if (Array.isArray(args[0])) {\n            options = args[1];\n        }\n\n        const files = getFiles();\n\n        if (!queries.length) return Promise.all(files.map(file => removeFile(file, options)));\n\n        // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n        const mappedQueries = queries\n            .map(query => (isNumber(query) ? (files[query] ? files[query].id : null) : query))\n            .filter(query => query);\n\n        return mappedQueries.map(q => removeFile(q, options));\n    };\n\n    const exports = {\n        // supports events\n        ...on(),\n\n        // inject private api methods\n        ...readWriteApi,\n\n        // inject all getters and setters\n        ...createOptionAPI(store, defaultOptions),\n\n        /**\n         * Override options defined in options object\n         * @param options\n         */\n        setOptions,\n\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */\n        addFile,\n\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */\n        addFiles,\n\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */\n        getFile,\n\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */\n        processFile,\n\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */\n        prepareFile,\n\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */\n        removeFile,\n\n        /**\n         * Moves a file to a new location in the files list\n         */\n        moveFile: (query, index) => store.dispatch('MOVE_ITEM', { query, index }),\n\n        /**\n         * Returns all files (wrapped in public api)\n         */\n        getFiles,\n\n        /**\n         * Starts uploading all files\n         */\n        processFiles,\n\n        /**\n         * Clears all files from the files list\n         */\n        removeFiles,\n\n        /**\n         * Starts preparing output of all files\n         */\n        prepareFiles,\n\n        /**\n         * Sort list of files\n         */\n        sort: compare => store.dispatch('SORT', { compare }),\n\n        /**\n         * Browse the file system for a file\n         */\n        browse: () => {\n            // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n            var input = view.element.querySelector('input[type=file]');\n            if (input) {\n                input.click();\n            }\n        },\n\n        /**\n         * Destroys the app\n         */\n        destroy: () => {\n            // request destruction\n            exports.fire('destroy', view.element);\n\n            // stop active processes (file uploads, fetches, stuff like that)\n            // loop over items and depending on states call abort for ongoing processes\n            store.dispatch('ABORT_ALL');\n\n            // destroy view\n            view._destroy();\n\n            // stop listening to resize\n            window.removeEventListener('resize', resizeHandler);\n\n            // stop listening to the visiblitychange event\n            document.removeEventListener('visibilitychange', visibilityHandler);\n\n            // dispatch destroy\n            store.dispatch('DID_DESTROY');\n        },\n\n        /**\n         * Inserts the plugin before the target element\n         */\n        insertBefore: element => insertBefore(view.element, element),\n\n        /**\n         * Inserts the plugin after the target element\n         */\n        insertAfter: element => insertAfter(view.element, element),\n\n        /**\n         * Appends the plugin to the target element\n         */\n        appendTo: element => element.appendChild(view.element),\n\n        /**\n         * Replaces an element with the app\n         */\n        replaceElement: element => {\n            // insert the app before the element\n            insertBefore(view.element, element);\n\n            // remove the original element\n            element.parentNode.removeChild(element);\n\n            // remember original element\n            originalElement = element;\n        },\n\n        /**\n         * Restores the original element\n         */\n        restoreElement: () => {\n            if (!originalElement) {\n                return; // no element to restore\n            }\n\n            // restore original element\n            insertAfter(originalElement, view.element);\n\n            // remove our element\n            view.element.parentNode.removeChild(view.element);\n\n            // remove reference\n            originalElement = null;\n        },\n\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */\n        isAttachedTo: element => view.element === element || originalElement === element,\n\n        /**\n         * Returns the root element\n         */\n        element: {\n            get: () => view.element,\n        },\n\n        /**\n         * Returns the current pond status\n         */\n        status: {\n            get: () => store.query('GET_STATUS'),\n        },\n    };\n\n    // Done!\n    store.dispatch('DID_INIT');\n\n    // create actual api object\n    return createObject(exports);\n};\n\nconst createAppObject = (customOptions = {}) => {\n    // default options\n    const defaultOptions = {};\n    forin(getOptions(), (key, value) => {\n        defaultOptions[key] = value[0];\n    });\n\n    // set app options\n    const app = createApp({\n        // default options\n        ...defaultOptions,\n\n        // custom options\n        ...customOptions,\n    });\n\n    // return the plugin instance\n    return app;\n};\n\nconst lowerCaseFirstLetter = string => string.charAt(0).toLowerCase() + string.slice(1);\n\nconst attributeNameToPropertyName = attributeName => toCamels(attributeName.replace(/^data-/, ''));\n\nconst mapObject = (object, propertyMap) => {\n    // remove unwanted\n    forin(propertyMap, (selector, mapping) => {\n        forin(object, (property, value) => {\n            // create regexp shortcut\n            const selectorRegExp = new RegExp(selector);\n\n            // tests if\n            const matches = selectorRegExp.test(property);\n\n            // no match, skip\n            if (!matches) {\n                return;\n            }\n\n            // if there's a mapping, the original property is always removed\n            delete object[property];\n\n            // should only remove, we done!\n            if (mapping === false) {\n                return;\n            }\n\n            // move value to new property\n            if (isString(mapping)) {\n                object[mapping] = value;\n                return;\n            }\n\n            // move to group\n            const group = mapping.group;\n            if (isObject(mapping) && !object[group]) {\n                object[group] = {};\n            }\n\n            object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ''))] = value;\n        });\n\n        // do submapping\n        if (mapping.mapping) {\n            mapObject(object[mapping.group], mapping.mapping);\n        }\n    });\n};\n\nconst getAttributesAsObject = (node, attributeMapping = {}) => {\n    // turn attributes into object\n    const attributes = [];\n    forin(node.attributes, index => {\n        attributes.push(node.attributes[index]);\n    });\n\n    const output = attributes\n        .filter(attribute => attribute.name)\n        .reduce((obj, attribute) => {\n            const value = attr(node, attribute.name);\n\n            obj[attributeNameToPropertyName(attribute.name)] =\n                value === attribute.name ? true : value;\n            return obj;\n        }, {});\n\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n\n    return output;\n};\n\nconst createAppAtElement = (element, options = {}) => {\n    // how attributes of the input element are mapped to the options for the plugin\n    const attributeMapping = {\n        // translate to other name\n        '^class$': 'className',\n        '^multiple$': 'allowMultiple',\n        '^capture$': 'captureMethod',\n        '^webkitdirectory$': 'allowDirectoriesOnly',\n\n        // group under single property\n        '^server': {\n            group: 'server',\n            mapping: {\n                '^process': {\n                    group: 'process',\n                },\n                '^revert': {\n                    group: 'revert',\n                },\n                '^fetch': {\n                    group: 'fetch',\n                },\n                '^restore': {\n                    group: 'restore',\n                },\n                '^load': {\n                    group: 'load',\n                },\n            },\n        },\n\n        // don't include in object\n        '^type$': false,\n        '^files$': false,\n    };\n\n    // add additional option translators\n    applyFilters('SET_ATTRIBUTE_TO_OPTION_MAP', attributeMapping);\n\n    // create final options object by setting options object and then overriding options supplied on element\n    const mergedOptions = {\n        ...options,\n    };\n\n    const attributeOptions = getAttributesAsObject(\n        element.nodeName === 'FIELDSET' ? element.querySelector('input[type=file]') : element,\n        attributeMapping\n    );\n\n    // merge with options object\n    Object.keys(attributeOptions).forEach(key => {\n        if (isObject(attributeOptions[key])) {\n            if (!isObject(mergedOptions[key])) {\n                mergedOptions[key] = {};\n            }\n            Object.assign(mergedOptions[key], attributeOptions[key]);\n        } else {\n            mergedOptions[key] = attributeOptions[key];\n        }\n    });\n\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(\n        Array.from(element.querySelectorAll('input:not([type=file])')).map(input => ({\n            source: input.value,\n            options: {\n                type: input.dataset.type,\n            },\n        }))\n    );\n\n    // build plugin\n    const app = createAppObject(mergedOptions);\n\n    // add already selected files\n    if (element.files) {\n        Array.from(element.files).forEach(file => {\n            app.addFile(file);\n        });\n    }\n\n    // replace the target element\n    app.replaceElement(element);\n\n    // expose\n    return app;\n};\n\n// if an element is passed, we create the instance at that element, if not, we just create an up object\nconst createApp$1 = (...args) =>\n    isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);\n\nconst PRIVATE_METHODS = ['fire', '_read', '_write'];\n\nconst createAppAPI = app => {\n    const api = {};\n\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n\n    return api;\n};\n\n/**\n * Replaces placeholders in given string with replacements\n * @param string - \"Foo {bar}\"\"\n * @param replacements - { \"bar\": 10 }\n */\nconst replaceInString = (string, replacements) =>\n    string.replace(/(?:{([a-zA-Z]+)})/g, (match, group) => replacements[group]);\n\nconst createWorker = fn => {\n    const workerBlob = new Blob(['(', fn.toString(), ')()'], {\n        type: 'application/javascript',\n    });\n    const workerURL = URL.createObjectURL(workerBlob);\n    const worker = new Worker(workerURL);\n\n    return {\n        transfer: (message, cb) => {},\n        post: (message, cb, transferList) => {\n            const id = getUniqueId();\n\n            worker.onmessage = e => {\n                if (e.data.id === id) {\n                    cb(e.data.message);\n                }\n            };\n\n            worker.postMessage(\n                {\n                    id,\n                    message,\n                },\n                transferList\n            );\n        },\n        terminate: () => {\n            worker.terminate();\n            URL.revokeObjectURL(workerURL);\n        },\n    };\n};\n\nconst loadImage = url =>\n    new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => {\n            resolve(img);\n        };\n        img.onerror = e => {\n            reject(e);\n        };\n        img.src = url;\n    });\n\nconst renameFile = (file, name) => {\n    const renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n};\n\nconst copyFile = file => renameFile(file, file.name);\n\n// already registered plugins (can't register twice)\nconst registeredPlugins = [];\n\n// pass utils to plugin\nconst createAppPlugin = plugin => {\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n        return;\n    }\n\n    // remember this plugin\n    registeredPlugins.push(plugin);\n\n    // setup!\n    const pluginOutline = plugin({\n        addFilter,\n        utils: {\n            Type,\n            forin,\n            isString,\n            isFile,\n            toNaturalFileSize,\n            replaceInString,\n            getExtensionFromFilename,\n            getFilenameWithoutExtension,\n            guesstimateMimeType,\n            getFileFromBlob,\n            getFilenameFromURL,\n            createRoute,\n            createWorker,\n            createView,\n            createItemAPI,\n            loadImage,\n            copyFile,\n            renameFile,\n            createBlob,\n            applyFilterChain,\n            text,\n            getNumericAspectRatioFromString,\n        },\n        views: {\n            fileActionButton,\n        },\n    });\n\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n};\n\n// feature detection used by supported() method\nconst isOperaMini = () => Object.prototype.toString.call(window.operamini) === '[object OperaMini]';\nconst hasPromises = () => 'Promise' in window;\nconst hasBlobSlice = () => 'slice' in Blob.prototype;\nconst hasCreateObjectURL = () => 'URL' in window && 'createObjectURL' in window.URL;\nconst hasVisibility = () => 'visibilityState' in document;\nconst hasTiming = () => 'performance' in window; // iOS 8.x\nconst hasCSSSupports = () => 'supports' in (window.CSS || {}); // use to detect Safari 9+\nconst isIE11 = () => /MSIE|Trident/.test(window.navigator.userAgent);\n\nconst supported = (() => {\n    // Runs immediately and then remembers result for subsequent calls\n    const isSupported =\n        // Has to be a browser\n        isBrowser() &&\n        // Can't run on Opera Mini due to lack of everything\n        !isOperaMini() &&\n        // Require these APIs to feature detect a modern browser\n        hasVisibility() &&\n        hasPromises() &&\n        hasBlobSlice() &&\n        hasCreateObjectURL() &&\n        hasTiming() &&\n        // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n        (hasCSSSupports() || isIE11());\n\n    return () => isSupported;\n})();\n\n/**\n * Plugin internal state (over all instances)\n */\nconst state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: [],\n};\n\n// plugin name\nconst name = 'filepond';\n\n/**\n * Public Plugin methods\n */\nconst fn = () => {};\nlet Status$1 = {};\nlet FileStatus = {};\nlet FileOrigin$1 = {};\nlet OptionTypes = {};\nlet create$f = fn;\nlet destroy = fn;\nlet parse = fn;\nlet find = fn;\nlet registerPlugin = fn;\nlet getOptions$1 = fn;\nlet setOptions$1 = fn;\n\n// if not supported, no API\nif (supported()) {\n    // start painter and fire load event\n    createPainter(\n        () => {\n            state.apps.forEach(app => app._read());\n        },\n        ts => {\n            state.apps.forEach(app => app._write(ts));\n        }\n    );\n\n    // fire loaded event so we know when FilePond is available\n    const dispatch = () => {\n        // let others know we have area ready\n        document.dispatchEvent(\n            new CustomEvent('FilePond:loaded', {\n                detail: {\n                    supported,\n                    create: create$f,\n                    destroy,\n                    parse,\n                    find,\n                    registerPlugin,\n                    setOptions: setOptions$1,\n                },\n            })\n        );\n\n        // clean up event\n        document.removeEventListener('DOMContentLoaded', dispatch);\n    };\n\n    if (document.readyState !== 'loading') {\n        // move to back of execution queue, FilePond should have been exported by then\n        setTimeout(() => dispatch(), 0);\n    } else {\n        document.addEventListener('DOMContentLoaded', dispatch);\n    }\n\n    // updates the OptionTypes object based on the current options\n    const updateOptionTypes = () =>\n        forin(getOptions(), (key, value) => {\n            OptionTypes[key] = value[1];\n        });\n\n    Status$1 = { ...Status };\n    FileOrigin$1 = { ...FileOrigin };\n    FileStatus = { ...ItemStatus };\n\n    OptionTypes = {};\n    updateOptionTypes();\n\n    // create method, creates apps and adds them to the app array\n    create$f = (...args) => {\n        const app = createApp$1(...args);\n        app.on('destroy', destroy);\n        state.apps.push(app);\n        return createAppAPI(app);\n    };\n\n    // destroys apps and removes them from the app array\n    destroy = hook => {\n        // returns true if the app was destroyed successfully\n        const indexToRemove = state.apps.findIndex(app => app.isAttachedTo(hook));\n        if (indexToRemove >= 0) {\n            // remove from apps\n            const app = state.apps.splice(indexToRemove, 1)[0];\n\n            // restore original dom element\n            app.restoreElement();\n\n            return true;\n        }\n\n        return false;\n    };\n\n    // parses the given context for plugins (does not include the context element itself)\n    parse = context => {\n        // get all possible hooks\n        const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));\n\n        // filter out already active hooks\n        const newHooks = matchedHooks.filter(\n            newHook => !state.apps.find(app => app.isAttachedTo(newHook))\n        );\n\n        // create new instance for each hook\n        return newHooks.map(hook => create$f(hook));\n    };\n\n    // returns an app based on the given element hook\n    find = hook => {\n        const app = state.apps.find(app => app.isAttachedTo(hook));\n        if (!app) {\n            return null;\n        }\n        return createAppAPI(app);\n    };\n\n    // adds a plugin extension\n    registerPlugin = (...plugins) => {\n        // register plugins\n        plugins.forEach(createAppPlugin);\n\n        // update OptionTypes, each plugin might have extended the default options\n        updateOptionTypes();\n    };\n\n    getOptions$1 = () => {\n        const opts = {};\n        forin(getOptions(), (key, value) => {\n            opts[key] = value[0];\n        });\n        return opts;\n    };\n\n    setOptions$1 = opts => {\n        if (isObject(opts)) {\n            // update existing plugins\n            state.apps.forEach(app => {\n                app.setOptions(opts);\n            });\n\n            // override defaults\n            setOptions(opts);\n        }\n\n        // return new options\n        return getOptions$1();\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixVQUFVOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHdCQUF3QjtBQUM3RCxxQ0FBcUMsd0JBQXdCO0FBQzdELFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QyxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3RELGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1Q0FBdUMsc0RBQXNEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBNkQ7QUFDL0Y7QUFDQTtBQUNBLGFBQWEsaURBQWlEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7O0FBRUEsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0NBQWtDOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLHdCQUF3QiwyQkFBMkI7QUFDeEY7QUFDQTs7QUFFQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLG1CQUFtQixHQUFHLG1DQUFtQyxHQUFHO0FBQ25FO0FBQ0E7QUFDQSxNQUFNLEdBQUcsK0JBQStCLEdBQUcsaUNBQWlDLEdBQUc7QUFDL0U7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUksSUFBSTtBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixJQUFJLEVBQUUsMkVBQTJFO0FBQ2xHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDREQUE0RDs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVLEVBQUUsZUFBZTtBQUNoRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSw2QkFBNkI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxvQkFBb0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsNERBQTRELEdBQUc7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFlRSIsInNvdXJjZXMiOlsiSDpcXEtBTkhBSVlBXFxNYWluUHJvXFxMZWFyblByb1xcY2xpZW50XFxub2RlX21vZHVsZXNcXGZpbGVwb25kXFxkaXN0XFxmaWxlcG9uZC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZCA0LjMyLjZcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuY29uc3QgaXNOb2RlID0gdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW5pdGlhbFN0YXRlLCBxdWVyaWVzID0gW10sIGFjdGlvbnMgPSBbXSkgPT4ge1xuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICB9O1xuXG4gICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgY29uc3QgYWN0aW9uUXVldWUgPSBbXTtcbiAgICBjb25zdCBkaXNwYXRjaFF1ZXVlID0gW107XG5cbiAgICAvLyByZXR1cm5zIGEgZHVwbGljYXRlIG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiAoeyAuLi5zdGF0ZSB9KTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgIGNvbnN0IHByb2Nlc3NBY3Rpb25RdWV1ZSA9ICgpID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICBjb25zdCBxdWV1ZSA9IFsuLi5hY3Rpb25RdWV1ZV07XG5cbiAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3NlcyBhY3Rpb25zIHRoYXQgbWlnaHQgYmxvY2sgdGhlIG1haW4gVUkgdGhyZWFkXG4gICAgY29uc3QgcHJvY2Vzc0Rpc3BhdGNoUXVldWUgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBjb3B5IG9mIGFjdGlvbnMgcXVldWVcbiAgICAgICAgY29uc3QgcXVldWUgPSBbLi4uZGlzcGF0Y2hRdWV1ZV07XG5cbiAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIG5vdyBkaXNwYXRjaCB0aGVzZSBhY3Rpb25zXG4gICAgICAgIHF1ZXVlLmZvckVhY2goKHsgdHlwZSwgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCh0eXBlLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICBjb25zdCBkaXNwYXRjaCA9ICh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSA9PiB7XG4gICAgICAgIC8vIGlzIGJsb2NraW5nIGFjdGlvbiAoc2hvdWxkIG5ldmVyIGJsb2NrIGlmIGRvY3VtZW50IGlzIGhpZGRlbilcbiAgICAgICAgaWYgKGlzQmxvY2tpbmcgJiYgIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgdHlwZSwgZGF0YSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgYWN0aW9uIGhhcyBhIGhhbmRsZXIsIGhhbmRsZSB0aGUgYWN0aW9uXG4gICAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcnNbdHlwZV0oZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgYWRkIGFjdGlvblxuICAgICAgICBhY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcXVlcnkgPSAoc3RyLCAuLi5hcmdzKSA9PiAocXVlcnlIYW5kbGVzW3N0cl0gPyBxdWVyeUhhbmRsZXNbc3RyXSguLi5hcmdzKSA6IG51bGwpO1xuXG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlLFxuICAgICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHF1ZXJ5LFxuICAgIH07XG5cbiAgICBsZXQgcXVlcnlIYW5kbGVzID0ge307XG4gICAgcXVlcmllcy5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnlIYW5kbGVzID0ge1xuICAgICAgICAgICAgLi4ucXVlcnkoc3RhdGUpLFxuICAgICAgICAgICAgLi4ucXVlcnlIYW5kbGVzLFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGV0IGFjdGlvbkhhbmRsZXJzID0ge307XG4gICAgYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgIGFjdGlvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgLi4uYWN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpLFxuICAgICAgICAgICAgLi4uYWN0aW9uSGFuZGxlcnMsXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgZGVmaW5lUHJvcGVydHkgPSAob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgeyAuLi5kZWZpbml0aW9uIH0pO1xufTtcblxuY29uc3QgZm9yaW4gPSAob2JqLCBjYikgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZU9iamVjdCA9IGRlZmluaXRpb24gPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKGRlZmluaXRpb24sIHByb3BlcnR5ID0+IHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBhdHRyID0gKG5vZGUsIG5hbWUsIHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbn07XG5cbmNvbnN0IG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbmNvbnN0IGlzU1ZHRWxlbWVudCA9IHRhZyA9PiBzdmdFbGVtZW50cy5pbmNsdWRlcyh0YWcpO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKHRhZywgY2xhc3NOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+IHtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgY2xhc3NOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU1ZHRWxlbWVudCh0YWcpXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGlzU1ZHRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBhdHRyKGVsZW1lbnQsICdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JpbihhdHRyaWJ1dGVzLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5jb25zdCBhcHBlbmRDaGlsZCA9IHBhcmVudCA9PiAoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFyZW50LmNoaWxkcmVuW2luZGV4XSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbn07XG5cbmNvbnN0IGFwcGVuZENoaWxkVmlldyA9IChwYXJlbnQsIGNoaWxkVmlld3MpID0+ICh2aWV3LCBpbmRleCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGluZGV4LCAwLCB2aWV3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG59O1xuXG5jb25zdCByZW1vdmVDaGlsZFZpZXcgPSAocGFyZW50LCBjaGlsZFZpZXdzKSA9PiB2aWV3ID0+IHtcbiAgICAvLyByZW1vdmUgZnJvbSBjaGlsZCB2aWV3c1xuICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnRcbiAgICBpZiAodmlldy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG59O1xuXG5jb25zdCBJU19CUk9XU0VSID0gKCgpID0+XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpKCk7XG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiBJU19CUk9XU0VSO1xuXG5jb25zdCB0ZXN0RWxlbWVudCA9IGlzQnJvd3NlcigpID8gY3JlYXRlRWxlbWVudCgnc3ZnJykgOiB7fTtcbmNvbnN0IGdldENoaWxkQ291bnQgPVxuICAgICdjaGlsZHJlbicgaW4gdGVzdEVsZW1lbnQgPyBlbCA9PiBlbC5jaGlsZHJlbi5sZW5ndGggOiBlbCA9PiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcblxuY29uc3QgZ2V0Vmlld1JlY3QgPSAoZWxlbWVudFJlY3QsIGNoaWxkVmlld3MsIG9mZnNldCwgc2NhbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gb2Zmc2V0WzBdIHx8IGVsZW1lbnRSZWN0LmxlZnQ7XG4gICAgY29uc3QgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBjb25zdCByaWdodCA9IGxlZnQgKyBlbGVtZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQgKiAoc2NhbGVbMV0gfHwgMSk7XG5cbiAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAuLi5lbGVtZW50UmVjdCxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuLCBkb2VzIG5vdCBpbmNsdWRlIGFueSBtYXJnaW5zXG4gICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICBsZWZ0OiBlbGVtZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgICAgICByaWdodDogZWxlbWVudFJlY3QucmlnaHQsXG4gICAgICAgICAgICBib3R0b206IGVsZW1lbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuIGluY2x1ZGluZyBvd24gbWFyZ2luIGFuZCBjaGlsZCBtYXJnaW5zXG4gICAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgICAgb3V0ZXI6IHtcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gZXhwYW5kIHJlY3QgdG8gZml0IGFsbCBjaGlsZCByZWN0YW5nbGVzXG4gICAgY2hpbGRWaWV3c1xuICAgICAgICAuZmlsdGVyKGNoaWxkVmlldyA9PiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKSlcbiAgICAgICAgLm1hcChjaGlsZFZpZXcgPT4gY2hpbGRWaWV3LnJlY3QpXG4gICAgICAgIC5mb3JFYWNoKGNoaWxkVmlld1JlY3QgPT4ge1xuICAgICAgICAgICAgZXhwYW5kUmVjdChyZWN0LmlubmVyLCB7IC4uLmNoaWxkVmlld1JlY3QuaW5uZXIgfSk7XG4gICAgICAgICAgICBleHBhbmRSZWN0KHJlY3Qub3V0ZXIsIHsgLi4uY2hpbGRWaWV3UmVjdC5vdXRlciB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaW5uZXIgd2lkdGggYW5kIGhlaWdodFxuICAgIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QuaW5uZXIpO1xuXG4gICAgLy8gYXBwZW5kIGFkZGl0aW9uYWwgbWFyZ2luICh0b3AgYW5kIGxlZnQgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW4gdG9wIGFuZCBsZWZ0IGF1dG9tYXRpY2FsbHkpXG4gICAgcmVjdC5vdXRlci5ib3R0b20gKz0gcmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcbiAgICByZWN0Lm91dGVyLnJpZ2h0ICs9IHJlY3QuZWxlbWVudC5tYXJnaW5SaWdodDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvdXRlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5vdXRlcik7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbmNvbnN0IGV4cGFuZFJlY3QgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgIC8vIGFkanVzdCBmb3IgcGFyZW50IG9mZnNldFxuICAgIGNoaWxkLnRvcCArPSBwYXJlbnQudG9wO1xuICAgIGNoaWxkLnJpZ2h0ICs9IHBhcmVudC5sZWZ0O1xuICAgIGNoaWxkLmJvdHRvbSArPSBwYXJlbnQudG9wO1xuICAgIGNoaWxkLmxlZnQgKz0gcGFyZW50LmxlZnQ7XG5cbiAgICBpZiAoY2hpbGQuYm90dG9tID4gcGFyZW50LmJvdHRvbSkge1xuICAgICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgICBwYXJlbnQucmlnaHQgPSBjaGlsZC5yaWdodDtcbiAgICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVSZWN0U2l6ZSA9IHJlY3QgPT4ge1xuICAgIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbn07XG5cbmNvbnN0IGlzTnVtYmVyID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHBvc2l0aW9uIGlzIGF0IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEBwYXJhbSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHZlbG9jaXR5XG4gKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCB0aGVyZVlldCA9IChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5LCBlcnJvck1hcmdpbiA9IDAuMDAxKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiYgTWF0aC5hYnModmVsb2NpdHkpIDwgZXJyb3JNYXJnaW47XG59O1xuXG4vKipcbiAqIFNwcmluZyBhbmltYXRpb25cbiAqL1xuY29uc3Qgc3ByaW5nID1cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAoeyBzdGlmZm5lc3MgPSAwLjUsIGRhbXBpbmcgPSAwLjc1LCBtYXNzID0gMTAgfSA9IHt9KSA9PlxuICAgICAgICAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlcyBzcHJpbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gKHRzLCBza2lwVG9FbmRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgICAgICAgICBpZiAocmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZCBhdCBsZWFzdCBhIHRhcmdldCBvciBwb3NpdGlvbiB0byBkbyBzcHJpbmd5IHRoaW5nc1xuICAgICAgICAgICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHNwcmluZyBmb3JjZVxuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSAtKHBvc2l0aW9uIC0gdGFyZ2V0KSAqIHN0aWZmbmVzcztcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2ZWxvY2l0eSBieSBhZGRpbmcgZm9yY2UgYmFzZWQgb24gbWFzc1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGJ5IGFkZGluZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHZlbG9jaXR5O1xuXG4gICAgICAgICAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKj0gZGFtcGluZztcblxuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGFycml2ZWQgaWYgd2UncmUgbmVhciB0YXJnZXQgYW5kIG91ciB2ZWxvY2l0eSBpcyBuZWFyIHplcm9cbiAgICAgICAgICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzZXRUYXJnZXQgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IGhhcyBubyBwb3NpdGlvbiwgc2V0IHRhcmdldCBhbmQgcG9zaXRpb24gdG8gdGhpcyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkgJiYgIWlzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgc3RhcnQgbW92aW5nIHRvIHRhcmdldFxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgY29uc3QgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBzZXRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGFyZ2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJlc3RpbmcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuY29uc3QgZWFzZUxpbmVhciA9IHQgPT4gdDtcbmNvbnN0IGVhc2VJbk91dFF1YWQgPSB0ID0+ICh0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQpO1xuXG5jb25zdCB0d2VlbiA9XG4gICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICAoeyBkdXJhdGlvbiA9IDUwMCwgZWFzaW5nID0gZWFzZUluT3V0UXVhZCwgZGVsYXkgPSAwIH0gPSB7fSkgPT5cbiAgICAgICAgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICBsZXQgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gKHRzLCBza2lwVG9FbmRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0aW5nIHx8IHRhcmdldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRzIC0gc3RhcnQgPCBkZWxheSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdCA9IHRzIC0gc3RhcnQgLSBkZWxheTtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcmV2ZXJzZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHAgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBuZWVkICdhcGknIHRvIGNhbGwgb251cGRhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gKHJldmVyc2UgPyAwIDogdGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHR3ZWVuIHRvIGEgc21hbGxlciB2YWx1ZSBhbmQgaGF2ZSBhIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCB0d2VlbmluZyB0byBhIHNtYWxsZXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJlc3RpbmcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuY29uc3QgYW5pbWF0b3IgPSB7XG4gICAgc3ByaW5nLFxuICAgIHR3ZWVuLFxufTtcblxuLypcbiB7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IC41LCBkYW1waW5nOiAuNzUsIG1hc3M6IDEwIH07XG4geyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4geyB0cmFuc2xhdGlvbjogeyB4OiB7IHR5cGU6ICdzcHJpbmcnLCAuLi4gfSB9IH1cbiovXG5jb25zdCBjcmVhdGVBbmltYXRvciA9IChkZWZpbml0aW9uLCBjYXRlZ29yeSwgcHJvcGVydHkpID0+IHtcbiAgICAvLyBkZWZhdWx0IGlzIHNpbmdsZSBkZWZpbml0aW9uXG4gICAgLy8gd2UgY2hlY2sgaWYgdHJhbnNmb3JtIGlzIHNldCwgaWYgc28sIHdlIGNoZWNrIGlmIHByb3BlcnR5IGlzIHNldFxuICAgIGNvbnN0IGRlZiA9XG4gICAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IGRlZmluaXRpb25bY2F0ZWdvcnldW3Byb3BlcnR5XVxuICAgICAgICAgICAgOiBkZWZpbml0aW9uW2NhdGVnb3J5XSB8fCBkZWZpbml0aW9uO1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLnR5cGU7XG4gICAgY29uc3QgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IHsgLi4uZGVmIH0gOiB7fTtcblxuICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG59O1xuXG5jb25zdCBhZGRHZXRTZXQgPSAoa2V5cywgb2JqLCBwcm9wcywgb3ZlcndyaXRlID0gZmFsc2UpID0+IHtcbiAgICBvYmogPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcbiAgICBvYmouZm9yRWFjaChvID0+IHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGtleTtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSAoKSA9PiBwcm9wc1trZXldO1xuICAgICAgICAgICAgbGV0IHNldHRlciA9IHZhbHVlID0+IChwcm9wc1trZXldID0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0ga2V5LmtleTtcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBrZXkuZ2V0dGVyIHx8IGdldHRlcjtcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBrZXkuc2V0dGVyIHx8IHNldHRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9bbmFtZV0gJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8gYWRkIHRvIHN0YXRlLFxuLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGFwaSAoaWYgbm90IHNldClcbi8vIHNldHVwIGFuaW1hdG9yc1xuXG5jb25zdCBhbmltYXRpb25zID0gKHsgbWl4aW5Db25maWcsIHZpZXdQcm9wcywgdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEkgfSkgPT4ge1xuICAgIC8vIGluaXRpYWwgcHJvcGVydGllc1xuICAgIGNvbnN0IGluaXRpYWxQcm9wcyA9IHsgLi4udmlld1Byb3BzIH07XG5cbiAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcblxuICAgIC8vIHNldHVwIGFuaW1hdG9yc1xuICAgIGZvcmluKG1peGluQ29uZmlnLCAocHJvcGVydHksIGFuaW1hdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IGNyZWF0ZUFuaW1hdG9yKGFuaW1hdGlvbik7XG4gICAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gdGhlIGFuaW1hdG9yIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmlldyBzdGF0ZSB2YWx1ZVxuICAgICAgICBhbmltYXRvci5vbnVwZGF0ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHZpZXdQcm9wc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgYW5pbWF0b3IgdGFyZ2V0XG4gICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IGluaXRpYWxQcm9wc1twcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICAgIGNvbnN0IHByb3AgPSB7XG4gICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgc2V0dGVyOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBhdCB0YXJnZXQsIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yLnRhcmdldCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldHRlcjogKCkgPT4gdmlld1Byb3BzW3Byb3BlcnR5XSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICBhZGRHZXRTZXQoW3Byb3BdLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMsIHRydWUpO1xuXG4gICAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRvcik7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgd3JpdGUgYXBpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IHRzID0+IHtcbiAgICAgICAgICAgIGxldCBza2lwVG9FbmRTdGF0ZSA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgIGxldCByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLnJlc3RpbmcpIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHt9LFxuICAgIH07XG59O1xuXG5jb25zdCBhZGRFdmVudCA9IGVsZW1lbnQgPT4gKHR5cGUsIGZuKSA9PiB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbn07XG5cbmNvbnN0IHJlbW92ZUV2ZW50ID0gZWxlbWVudCA9PiAodHlwZSwgZm4pID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xufTtcblxuLy8gbWl4aW5cbmNvbnN0IGxpc3RlbmVycyA9ICh7XG4gICAgbWl4aW5Db25maWcsXG4gICAgdmlld1Byb3BzLFxuICAgIHZpZXdJbnRlcm5hbEFQSSxcbiAgICB2aWV3RXh0ZXJuYWxBUEksXG4gICAgdmlld1N0YXRlLFxuICAgIHZpZXcsXG59KSA9PiB7XG4gICAgY29uc3QgZXZlbnRzID0gW107XG5cbiAgICBjb25zdCBhZGQgPSBhZGRFdmVudCh2aWV3LmVsZW1lbnQpO1xuICAgIGNvbnN0IHJlbW92ZSA9IHJlbW92ZUV2ZW50KHZpZXcuZWxlbWVudCk7XG5cbiAgICB2aWV3RXh0ZXJuYWxBUEkub24gPSAodHlwZSwgZm4pID0+IHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZuLFxuICAgICAgICB9KTtcbiAgICAgICAgYWRkKHR5cGUsIGZuKTtcbiAgICB9O1xuXG4gICAgdmlld0V4dGVybmFsQVBJLm9mZiA9ICh0eXBlLCBmbikgPT4ge1xuICAgICAgICBldmVudHMuc3BsaWNlKGV2ZW50cy5maW5kSW5kZXgoZXZlbnQgPT4gZXZlbnQudHlwZSA9PT0gdHlwZSAmJiBldmVudC5mbiA9PT0gZm4pLCAxKTtcbiAgICAgICAgcmVtb3ZlKHR5cGUsIGZuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZShldmVudC50eXBlLCBldmVudC5mbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuLy8gYWRkIHRvIGV4dGVybmFsIGFwaSBhbmQgbGluayB0byBwcm9wc1xuXG5jb25zdCBhcGlzID0gKHsgbWl4aW5Db25maWcsIHZpZXdQcm9wcywgdmlld0V4dGVybmFsQVBJIH0pID0+IHtcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbn07XG5cbmNvbnN0IGlzRGVmaW5lZCA9IHZhbHVlID0+IHZhbHVlICE9IG51bGw7XG5cbi8vIGFkZCB0byBzdGF0ZSxcbi8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIGludGVybmFsIGFuZCBleHRlcm5hbCBhcGkgKGlmIG5vdCBzZXQpXG4vLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbi8vIGFwcGx5IGFzIHRyYW5zZm9ybXMgZWFjaCBmcmFtZVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHNjYWxlWDogMSxcbiAgICBzY2FsZVk6IDEsXG4gICAgdHJhbnNsYXRlWDogMCxcbiAgICB0cmFuc2xhdGVZOiAwLFxuICAgIHJvdGF0ZVg6IDAsXG4gICAgcm90YXRlWTogMCxcbiAgICByb3RhdGVaOiAwLFxuICAgIG9yaWdpblg6IDAsXG4gICAgb3JpZ2luWTogMCxcbn07XG5cbmNvbnN0IHN0eWxlcyA9ICh7IG1peGluQ29uZmlnLCB2aWV3UHJvcHMsIHZpZXdJbnRlcm5hbEFQSSwgdmlld0V4dGVybmFsQVBJLCB2aWV3IH0pID0+IHtcbiAgICAvLyBpbml0aWFsIHByb3BzXG4gICAgY29uc3QgaW5pdGlhbFByb3BzID0geyAuLi52aWV3UHJvcHMgfTtcblxuICAgIC8vIGN1cnJlbnQgcHJvcHNcbiAgICBjb25zdCBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICBjb25zdCBnZXRPZmZzZXQgPSAoKSA9PiBbdmlld1Byb3BzWyd0cmFuc2xhdGVYJ10gfHwgMCwgdmlld1Byb3BzWyd0cmFuc2xhdGVZJ10gfHwgMF07XG4gICAgY29uc3QgZ2V0U2NhbGUgPSAoKSA9PiBbdmlld1Byb3BzWydzY2FsZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3NjYWxlWSddIHx8IDBdO1xuICAgIGNvbnN0IGdldFJlY3QgPSAoKSA9PlxuICAgICAgICB2aWV3LnJlY3QgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpIDogbnVsbDtcbiAgICB2aWV3SW50ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG4gICAgdmlld0V4dGVybmFsQVBJLnJlY3QgPSB7IGdldDogZ2V0UmVjdCB9O1xuXG4gICAgLy8gYXBwbHkgdmlldyBwcm9wc1xuICAgIG1peGluQ29uZmlnLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdmlld1Byb3BzW2tleV0gPVxuICAgICAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzW2tleV0gOiBpbml0aWFsUHJvcHNba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIGV4cG9zZSBhcGlcbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKCFwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgdmlld1Byb3BzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICAgICAgYXBwbHlTdHlsZXModmlldy5lbGVtZW50LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBuZXcgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIHsgLi4udmlld1Byb3BzIH0pO1xuXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgYnVzeVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHt9LFxuICAgIH07XG59O1xuXG5jb25zdCBwcm9wc0hhdmVDaGFuZ2VkID0gKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpID0+IHtcbiAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gbGV0cyBhbmFseXplIHRoZSBpbmRpdmlkdWFsIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGFwcGx5U3R5bGVzID0gKFxuICAgIGVsZW1lbnQsXG4gICAge1xuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgICAgdHJhbnNsYXRlWCxcbiAgICAgICAgdHJhbnNsYXRlWSxcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHJvdGF0ZVgsXG4gICAgICAgIHJvdGF0ZVksXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfVxuKSA9PiB7XG4gICAgbGV0IHRyYW5zZm9ybXMgPSAnJztcbiAgICBsZXQgc3R5bGVzID0gJyc7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNmb3JtIG9yaWdpblxuICAgIGlmIChpc0RlZmluZWQob3JpZ2luWCkgfHwgaXNEZWZpbmVkKG9yaWdpblkpKSB7XG4gICAgICAgIHN0eWxlcyArPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtvcmlnaW5YIHx8IDB9cHggJHtvcmlnaW5ZIHx8IDB9cHg7YDtcbiAgICB9XG5cbiAgICAvLyB0cmFuc2Zvcm0gb3JkZXIgaXMgcmVsZXZhbnRcbiAgICAvLyAwLiBwZXJzcGVjdGl2ZVxuICAgIGlmIChpc0RlZmluZWQocGVyc3BlY3RpdmUpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHBlcnNwZWN0aXZlKCR7cGVyc3BlY3RpdmV9cHgpIGA7XG4gICAgfVxuXG4gICAgLy8gMS4gdHJhbnNsYXRlXG4gICAgaWYgKGlzRGVmaW5lZCh0cmFuc2xhdGVYKSB8fCBpc0RlZmluZWQodHJhbnNsYXRlWSkpIHtcbiAgICAgICAgdHJhbnNmb3JtcyArPSBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYIHx8IDB9cHgsICR7dHJhbnNsYXRlWSB8fCAwfXB4LCAwKSBgO1xuICAgIH1cblxuICAgIC8vIDIuIHNjYWxlXG4gICAgaWYgKGlzRGVmaW5lZChzY2FsZVgpIHx8IGlzRGVmaW5lZChzY2FsZVkpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHNjYWxlM2QoJHtpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDF9LCAke1xuICAgICAgICAgICAgaXNEZWZpbmVkKHNjYWxlWSkgPyBzY2FsZVkgOiAxXG4gICAgICAgIH0sIDEpIGA7XG4gICAgfVxuXG4gICAgLy8gMy4gcm90YXRlXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVaKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVaKCR7cm90YXRlWn1yYWQpIGA7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVYKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVYKCR7cm90YXRlWH1yYWQpIGA7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVZKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVZKCR7cm90YXRlWX1yYWQpIGA7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRyYW5zZm9ybXNcbiAgICBpZiAodHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgc3R5bGVzICs9IGB0cmFuc2Zvcm06JHt0cmFuc2Zvcm1zfTtgO1xuICAgIH1cblxuICAgIC8vIGFkZCBvcGFjaXR5XG4gICAgaWYgKGlzRGVmaW5lZChvcGFjaXR5KSkge1xuICAgICAgICBzdHlsZXMgKz0gYG9wYWNpdHk6JHtvcGFjaXR5fTtgO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gYHZpc2liaWxpdHk6aGlkZGVuO2A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSdyZSBiZWxvdyAxMDAlIG9wYWNpdHkgdGhpcyBlbGVtZW50IGNhbid0IGJlIGNsaWNrZWRcbiAgICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gYHBvaW50ZXItZXZlbnRzOm5vbmU7YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBoZWlnaHRcbiAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgICAgc3R5bGVzICs9IGBoZWlnaHQ6JHtoZWlnaHR9cHg7YDtcbiAgICB9XG5cbiAgICAvLyBhZGQgd2lkdGhcbiAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgICBzdHlsZXMgKz0gYHdpZHRoOiR7d2lkdGh9cHg7YDtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBzdHlsZXNcbiAgICBjb25zdCBlbGVtZW50Q3VycmVudFN0eWxlID0gZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlIHx8ICcnO1xuXG4gICAgLy8gaWYgbmV3IHN0eWxlcyBkb2VzIG5vdCBtYXRjaCBjdXJyZW50IHN0eWxlcywgbGV0cyB1cGRhdGUhXG4gICAgaWYgKHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8IHN0eWxlcyAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgICAvLyBfbm90XyBnZXR0aW5nIHRoZSBzdHlsZSB2YWx1ZSBpcyBmYXN0ZXJcbiAgICAgICAgZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlID0gc3R5bGVzO1xuICAgIH1cbn07XG5cbmNvbnN0IE1peGlucyA9IHtcbiAgICBzdHlsZXMsXG4gICAgbGlzdGVuZXJzLFxuICAgIGFuaW1hdGlvbnMsXG4gICAgYXBpcyxcbn07XG5cbmNvbnN0IHVwZGF0ZVJlY3QgPSAocmVjdCA9IHt9LCBlbGVtZW50ID0ge30sIHN0eWxlID0ge30pID0+IHtcbiAgICBpZiAoIWVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCkge1xuICAgICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgcmVjdC5tYXJnaW5Ub3AgPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSB8fCAwO1xuICAgICAgICByZWN0Lm1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICAgIHJlY3QubWFyZ2luTGVmdCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSB8fCAwO1xuICAgICAgICBlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlY3QubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgIHJlY3QudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICByZWN0LndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwO1xuICAgIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcblxuICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyByZWN0LmhlaWdodDtcblxuICAgIHJlY3Quc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICByZWN0LmhpZGRlbiA9IGVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5jb25zdCBjcmVhdGVWaWV3ID1cbiAgICAvLyBkZWZhdWx0IHZpZXcgZGVmaW5pdGlvblxuICAgICh7XG4gICAgICAgIC8vIGVsZW1lbnQgZGVmaW5pdGlvblxuICAgICAgICB0YWcgPSAnZGl2JyxcbiAgICAgICAgbmFtZSA9IG51bGwsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fSxcblxuICAgICAgICAvLyB2aWV3IGludGVyYWN0aW9uXG4gICAgICAgIHJlYWQgPSAoKSA9PiB7fSxcbiAgICAgICAgd3JpdGUgPSAoKSA9PiB7fSxcbiAgICAgICAgY3JlYXRlID0gKCkgPT4ge30sXG4gICAgICAgIGRlc3Ryb3kgPSAoKSA9PiB7fSxcblxuICAgICAgICAvLyBob29rc1xuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9IChjaGlsZCwgYWN0aW9ucykgPT4gYWN0aW9ucyxcbiAgICAgICAgZGlkQ3JlYXRlVmlldyA9ICgpID0+IHt9LFxuICAgICAgICBkaWRXcml0ZVZpZXcgPSAoKSA9PiB7fSxcblxuICAgICAgICAvLyByZWN0IHJlbGF0ZWRcbiAgICAgICAgaWdub3JlUmVjdCA9IGZhbHNlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlID0gZmFsc2UsXG5cbiAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgIG1peGlucyA9IFtdLFxuICAgIH0gPSB7fSkgPT4gKFxuICAgICAgICAvLyBlYWNoIHZpZXcgcmVxdWlyZXMgcmVmZXJlbmNlIHRvIHN0b3JlXG4gICAgICAgIHN0b3JlLFxuICAgICAgICAvLyBzcGVjaWZpYyBwcm9wZXJ0aWVzIGZvciB0aGlzIHZpZXdcbiAgICAgICAgcHJvcHMgPSB7fVxuICAgICkgPT4ge1xuICAgICAgICAvLyByb290IGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHRhZywgYGZpbGVwb25kLS0ke25hbWV9YCwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgLy8gc3R5bGUgcmVmZXJlbmNlIHNob3VsZCBhbHNvIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgY29uc3QgcmVjdCA9IHVwZGF0ZVJlY3QoKTtcbiAgICAgICAgbGV0IGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgLy8gcmVzdCBzdGF0ZVxuICAgICAgICBsZXQgaXNSZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcHJldHR5IHNlbGYgZXhwbGFuYXRvcnlcbiAgICAgICAgY29uc3QgY2hpbGRWaWV3cyA9IFtdO1xuXG4gICAgICAgIC8vIGxvYWRlZCBtaXhpbnNcbiAgICAgICAgY29uc3QgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IHJlZiA9IHt9O1xuXG4gICAgICAgIC8vIHN0YXRlIHVzZWQgZm9yIGVhY2ggaW5zdGFuY2VcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7fTtcblxuICAgICAgICAvLyBsaXN0IG9mIHdyaXRlcnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhpcyB2aWV3XG4gICAgICAgIGNvbnN0IHdyaXRlcnMgPSBbXG4gICAgICAgICAgICB3cml0ZSwgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCByZWFkZXJzID0gW1xuICAgICAgICAgICAgcmVhZCwgLy8gZGVmYXVsdCByZWFkZXJcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBkZXN0cm95ZXJzID0gW1xuICAgICAgICAgICAgZGVzdHJveSwgLy8gZGVmYXVsdCBkZXN0cm95XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gY29yZSB2aWV3IG1ldGhvZHNcbiAgICAgICAgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGdldENoaWxkVmlld3MgPSAoKSA9PiBjaGlsZFZpZXdzLmNvbmNhdCgpO1xuICAgICAgICBjb25zdCBnZXRSZWZlcmVuY2UgPSAoKSA9PiByZWY7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNoaWxkVmlldyA9IHN0b3JlID0+ICh2aWV3LCBwcm9wcykgPT4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICBjb25zdCBnZXRSZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyYW1lUmVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXRTdHlsZSA9ICgpID0+IHN0eWxlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IF9yZWFkID0gKCkgPT4ge1xuICAgICAgICAgICAgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gcmVhZCBjaGlsZCB2aWV3c1xuICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLl9yZWFkKCkpO1xuXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzLCByZWN0IH07XG4gICAgICAgICAgICByZWFkZXJzLmZvckVhY2gocmVhZGVyID0+IHJlYWRlcihhcGkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgZGF0YSB0byBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IF93cml0ZSA9ICh0cywgZnJhbWVBY3Rpb25zLCBzaG91bGRPcHRpbWl6ZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgICAgbGV0IHJlc3RpbmcgPSBmcmFtZUFjdGlvbnMubGVuZ3RoID09PSAwO1xuXG4gICAgICAgICAgICAvLyB3cml0ZXJzXG4gICAgICAgICAgICB3cml0ZXJzLmZvckVhY2god3JpdGVyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXJSZXN0aW5nID0gd3JpdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBmcmFtZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZXJSZXN0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKG1peGluID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1peGlucyBpcyBzdGlsbCBidXN5IGFmdGVyIHdyaXRlIG9wZXJhdGlvbiwgd2UgYXJlIG5vdCByZXN0aW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbWl4aW5SZXN0aW5nID0gbWl4aW4ud3JpdGUodHMpO1xuICAgICAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlcyBjaGlsZCB2aWV3cyB0aGF0IGFyZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhlIERPTVxuICAgICAgICAgICAgY2hpbGRWaWV3c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gISFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlc3RpbmcgPSBjaGlsZC5fd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmV3IGVsZW1lbnRzIHRvIERPTSBhbmQgdXBkYXRlIHRob3NlXG4gICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgLy8uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZChjaGlsZCwgZnJhbWVBY3Rpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICAgIGlzUmVzdGluZyA9IHJlc3Rpbmc7XG5cbiAgICAgICAgICAgIGRpZFdyaXRlVmlldyh7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKG1peGluID0+IG1peGluLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICBkZXN0cm95ZXJzLmZvckVhY2goZGVzdHJveWVyID0+IHtcbiAgICAgICAgICAgICAgICBkZXN0cm95ZXIoeyByb290OiBpbnRlcm5hbEFQSSwgcHJvcHMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5fZGVzdHJveSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzaGFyZWRBUElcbiAgICAgICAgY29uc3Qgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFN0eWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgY29uc3QgaW50ZXJuYWxBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uc2hhcmVkQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBhY2Nlc3MgdG8gY3VzdG9tIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJlZjoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0UmVmZXJlbmNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZG9tIG1vZGlmaWVyc1xuICAgICAgICAgICAgaXM6IG5lZWRsZSA9PiBuYW1lID09PSBuZWVkbGUsXG4gICAgICAgICAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQoZWxlbWVudCksXG4gICAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgICBsaW5rVmlldzogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVubGlua1ZpZXc6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgICByZW1vdmVDaGlsZFZpZXc6IHJlbW92ZUNoaWxkVmlldyhlbGVtZW50LCBjaGlsZFZpZXdzKSxcbiAgICAgICAgICAgIHJlZ2lzdGVyV3JpdGVyOiB3cml0ZXIgPT4gd3JpdGVycy5wdXNoKHdyaXRlciksXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcjogcmVhZGVyID0+IHJlYWRlcnMucHVzaChyZWFkZXIpLFxuICAgICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGRlc3Ryb3llciA9PiBkZXN0cm95ZXJzLnB1c2goZGVzdHJveWVyKSxcbiAgICAgICAgICAgIGludmFsaWRhdGVMYXlvdXQ6ICgpID0+IChlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSBmYWxzZSksXG5cbiAgICAgICAgICAgIC8vIGFjY2VzcyB0byBkYXRhIHN0b3JlXG4gICAgICAgICAgICBkaXNwYXRjaDogc3RvcmUuZGlzcGF0Y2gsXG4gICAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZFZpZXdzOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gaXNSZXN0aW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmVjdElnbm9yZWQ6ICgpID0+IGlnbm9yZVJlY3QsXG4gICAgICAgICAgICBfcmVhZCxcbiAgICAgICAgICAgIF93cml0ZSxcbiAgICAgICAgICAgIF9kZXN0cm95LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgIGNvbnN0IG1peGluQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnNoYXJlZEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiByZWN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgbWl4aW4gZnVuY3Rpb25hbGl0eVxuICAgICAgICBPYmplY3Qua2V5cyhtaXhpbnMpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWl4aW5BUEkgPSBNaXhpbnNba2V5XSh7XG4gICAgICAgICAgICAgICAgICAgIG1peGluQ29uZmlnOiBtaXhpbnNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgdmlld1Byb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1N0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmlld0ludGVybmFsQVBJOiBpbnRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSTogZXh0ZXJuYWxBUElEZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjcmVhdGVPYmplY3QobWl4aW5BUElEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtaXhpbkFQSSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMucHVzaChtaXhpbkFQSSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY29uc3RydWN0IHByaXZhdGUgYXBpXG4gICAgICAgIGNvbnN0IGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcHBlbmQgY3JlYXRlZCBjaGlsZCB2aWV3cyB0byByb290IG5vZGVcbiAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZVBhaW50ZXIgPSAocmVhZCwgd3JpdGUsIGZwcyA9IDYwKSA9PiB7XG4gICAgY29uc3QgbmFtZSA9ICdfX2ZyYW1lUGFpbnRlcic7XG5cbiAgICAvLyBzZXQgZ2xvYmFsIHBhaW50ZXJcbiAgICBpZiAod2luZG93W25hbWVdKSB7XG4gICAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICAgIHdpbmRvd1tuYW1lXS53cml0ZXJzLnB1c2god3JpdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93W25hbWVdID0ge1xuICAgICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICAgIHdyaXRlcnM6IFt3cml0ZV0sXG4gICAgfTtcblxuICAgIGNvbnN0IHBhaW50ZXIgPSB3aW5kb3dbbmFtZV07XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG4gICAgbGV0IGxhc3QgPSBudWxsO1xuICAgIGxldCBpZCA9IG51bGw7XG4gICAgbGV0IHJlcXVlc3RUaWNrID0gbnVsbDtcbiAgICBsZXQgY2FuY2VsVGljayA9IG51bGw7XG5cbiAgICBjb25zdCBzZXRUaW1lclR5cGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gKCkgPT4gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGljayhwZXJmb3JtYW5jZS5ub3coKSksIGludGVydmFsKTtcbiAgICAgICAgICAgIGNhbmNlbFRpY2sgPSAoKSA9PiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gKCkgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgICAgIGNhbmNlbFRpY2sgPSAoKSA9PiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICAgIHNldFRpbWVyVHlwZSgpO1xuICAgICAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRpY2sgPSB0cyA9PiB7XG4gICAgICAgIC8vIHF1ZXVlIG5leHQgdGlja1xuICAgICAgICBpZCA9IHJlcXVlc3RUaWNrKHRpY2spO1xuXG4gICAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSB0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICAgIGlmIChkZWx0YSA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxpZ24gbmV4dCBmcmFtZVxuICAgICAgICBsYXN0ID0gdHMgLSAoZGVsdGEgJSBpbnRlcnZhbCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgICAgcGFpbnRlci5yZWFkZXJzLmZvckVhY2gocmVhZCA9PiByZWFkKCkpO1xuICAgICAgICBwYWludGVyLndyaXRlcnMuZm9yRWFjaCh3cml0ZSA9PiB3cml0ZSh0cykpO1xuICAgIH07XG5cbiAgICBzZXRUaW1lclR5cGUoKTtcbiAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdXNlOiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxUaWNrKGlkKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlUm91dGUgPSAocm91dGVzLCBmbikgPT4gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgPSBbXSwgdGltZXN0YW1wLCBzaG91bGRPcHRpbWl6ZSB9KSA9PiB7XG4gICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiByb3V0ZXNbYWN0aW9uLnR5cGVdKVxuICAgICAgICAuZm9yRWFjaChhY3Rpb24gPT5cbiAgICAgICAgICAgIHJvdXRlc1thY3Rpb24udHlwZV0oeyByb290LCBwcm9wcywgYWN0aW9uOiBhY3Rpb24uZGF0YSwgdGltZXN0YW1wLCBzaG91bGRPcHRpbWl6ZSB9KVxuICAgICAgICApO1xuICAgIGlmIChmbikge1xuICAgICAgICBmbih7IHJvb3QsIHByb3BzLCBhY3Rpb25zLCB0aW1lc3RhbXAsIHNob3VsZE9wdGltaXplIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IGluc2VydEJlZm9yZSA9IChuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSA9PlxuICAgIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG5cbmNvbnN0IGluc2VydEFmdGVyID0gKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpID0+IHtcbiAgICByZXR1cm4gcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbn07XG5cbmNvbnN0IGlzQXJyYXkgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuY29uc3QgaXNFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IHRyaW0gPSBzdHIgPT4gc3RyLnRyaW0oKTtcblxuY29uc3QgdG9TdHJpbmcgPSB2YWx1ZSA9PiAnJyArIHZhbHVlO1xuXG5jb25zdCB0b0FycmF5ID0gKHZhbHVlLCBzcGxpdHRlciA9ICcsJykgPT4ge1xuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSlcbiAgICAgICAgLnNwbGl0KHNwbGl0dGVyKVxuICAgICAgICAubWFwKHRyaW0pXG4gICAgICAgIC5maWx0ZXIoc3RyID0+IHN0ci5sZW5ndGgpO1xufTtcblxuY29uc3QgaXNCb29sZWFuID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbmNvbnN0IHRvQm9vbGVhbiA9IHZhbHVlID0+IChpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnKTtcblxuY29uc3QgaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG5jb25zdCB0b051bWJlciA9IHZhbHVlID0+XG4gICAgaXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBpc1N0cmluZyh2YWx1ZSkgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJykgOiAwO1xuXG5jb25zdCB0b0ludCA9IHZhbHVlID0+IHBhcnNlSW50KHRvTnVtYmVyKHZhbHVlKSwgMTApO1xuXG5jb25zdCB0b0Zsb2F0ID0gdmFsdWUgPT4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuXG5jb25zdCBpc0ludCA9IHZhbHVlID0+IGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuXG5jb25zdCB0b0J5dGVzID0gKHZhbHVlLCBiYXNlID0gMTAwMCkgPT4ge1xuICAgIC8vIGlzIGluIGJ5dGVzXG4gICAgaWYgKGlzSW50KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gaXMgbmF0dXJhbCBmaWxlIHNpemVcbiAgICBsZXQgbmF0dXJhbEZpbGVTaXplID0gdG9TdHJpbmcodmFsdWUpLnRyaW0oKTtcblxuICAgIC8vIGlmIGlzIHZhbHVlIGluIG1lZ2FieXRlc1xuICAgIGlmICgvTUIkL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlICogYmFzZTtcbiAgICB9XG5cbiAgICAvLyBpZiBpcyB2YWx1ZSBpbiBraWxvYnl0ZXNcbiAgICBpZiAoL0tCL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9LQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgIH1cblxuICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xufTtcblxuY29uc3QgaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuY29uc3QgdG9GdW5jdGlvblJlZmVyZW5jZSA9IHN0cmluZyA9PiB7XG4gICAgbGV0IHJlZiA9IHNlbGY7XG4gICAgbGV0IGxldmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgIGxldCBsZXZlbCA9IG51bGw7XG4gICAgd2hpbGUgKChsZXZlbCA9IGxldmVscy5zaGlmdCgpKSkge1xuICAgICAgICByZWYgPSByZWZbbGV2ZWxdO1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn07XG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gICAgcHJvY2VzczogJ1BPU1QnLFxuICAgIHBhdGNoOiAnUEFUQ0gnLFxuICAgIHJldmVydDogJ0RFTEVURScsXG4gICAgZmV0Y2g6ICdHRVQnLFxuICAgIHJlc3RvcmU6ICdHRVQnLFxuICAgIGxvYWQ6ICdHRVQnLFxufTtcblxuY29uc3QgY3JlYXRlU2VydmVyQVBJID0gb3V0bGluZSA9PiB7XG4gICAgY29uc3QgYXBpID0ge307XG5cbiAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgIGZvcmluKG1ldGhvZHMsIGtleSA9PiB7XG4gICAgICAgIGFwaVtrZXldID0gY3JlYXRlQWN0aW9uKGtleSwgb3V0bGluZVtrZXldLCBtZXRob2RzW2tleV0sIGFwaS50aW1lb3V0LCBhcGkuaGVhZGVycyk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgcHJvY2VzcyBpZiBubyB1cmwgb3IgcHJvY2VzcyBvbiBvdXRsaW5lXG4gICAgYXBpLnByb2Nlc3MgPSBvdXRsaW5lLnByb2Nlc3MgfHwgaXNTdHJpbmcob3V0bGluZSkgfHwgb3V0bGluZS51cmwgPyBhcGkucHJvY2VzcyA6IG51bGw7XG5cbiAgICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3IgcmVtb3ZlXG4gICAgYXBpLnJlbW92ZSA9IG91dGxpbmUucmVtb3ZlIHx8IG51bGw7XG5cbiAgICAvLyByZW1vdmUgZ2VuZXJpYyBoZWFkZXJzIGZyb20gYXBpIG9iamVjdFxuICAgIGRlbGV0ZSBhcGkuaGVhZGVycztcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBjcmVhdGVBY3Rpb24gPSAobmFtZSwgb3V0bGluZSwgbWV0aG9kLCB0aW1lb3V0LCBoZWFkZXJzKSA9PiB7XG4gICAgLy8gaXMgZXhwbGljaXRlbHkgc2V0IHRvIG51bGwgc28gZGlzYWJsZVxuICAgIGlmIChvdXRsaW5lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIGN1c3RvbSBmdW5jdGlvbiwgZG9uZSEgRGV2IGhhbmRsZXMgZXZlcnl0aGluZy5cbiAgICBpZiAodHlwZW9mIG91dGxpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgdXJsOiBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ1BBVENIJyA/IGA/JHtuYW1lfT1gIDogJycsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgb25sb2FkOiBudWxsLFxuICAgICAgICBvbmRhdGE6IG51bGwsXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgICBhY3Rpb24udXJsID0gb3V0bGluZTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBvdmVyd3JpdGVcbiAgICBPYmplY3QuYXNzaWduKGFjdGlvbiwgb3V0bGluZSk7XG5cbiAgICAvLyBzZWUgaWYgc2hvdWxkIHJlZm9ybWF0IGhlYWRlcnM7XG4gICAgaWYgKGlzU3RyaW5nKGFjdGlvbi5oZWFkZXJzKSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGFjdGlvbi5oZWFkZXJzLnNwbGl0KC86KC4rKS8pO1xuICAgICAgICBhY3Rpb24uaGVhZGVycyA9IHtcbiAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICB2YWx1ZTogcGFydHNbMV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbn07XG5cbmNvbnN0IHRvU2VydmVyQVBJID0gdmFsdWUgPT4gY3JlYXRlU2VydmVyQVBJKHZhbHVlKTtcblxuY29uc3QgaXNOdWxsID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcblxuY29uc3QgaXNBUEkgPSB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgICAgaXNPYmplY3QodmFsdWUucHJvY2VzcykgJiZcbiAgICAgICAgaXNPYmplY3QodmFsdWUucmV2ZXJ0KSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5mZXRjaClcbiAgICApO1xufTtcblxuY29uc3QgZ2V0VHlwZSA9IHZhbHVlID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAoaXNJbnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdieXRlcyc7XG4gICAgfVxuXG4gICAgaWYgKGlzQVBJKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ2FwaSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZTtcbn07XG5cbmNvbnN0IHJlcGxhY2VTaW5nbGVRdW90ZXMgPSBzdHIgPT5cbiAgICBzdHJcbiAgICAgICAgLnJlcGxhY2UoL3tcXHMqJy9nLCAne1wiJylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqOi9nLCAnXCI6JylcbiAgICAgICAgLnJlcGxhY2UoLzpcXHMqJy9nLCAnOlwiJylcbiAgICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqLC9nLCAnXCIsJyk7XG5cbmNvbnN0IGNvbnZlcnNpb25UYWJsZSA9IHtcbiAgICBhcnJheTogdG9BcnJheSxcbiAgICBib29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgaW50OiB2YWx1ZSA9PiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKSksXG4gICAgbnVtYmVyOiB0b0Zsb2F0LFxuICAgIGZsb2F0OiB0b0Zsb2F0LFxuICAgIGJ5dGVzOiB0b0J5dGVzLFxuICAgIHN0cmluZzogdmFsdWUgPT4gKGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSkpLFxuICAgIGZ1bmN0aW9uOiB2YWx1ZSA9PiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHZhbHVlKSxcbiAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgIG9iamVjdDogdmFsdWUgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVwbGFjZVNpbmdsZVF1b3Rlcyh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5jb25zdCBjb252ZXJ0VG8gPSAodmFsdWUsIHR5cGUpID0+IGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG5cbmNvbnN0IGdldFZhbHVlQnlUeXBlID0gKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSkgPT4ge1xuICAgIC8vIGNhbiBhbHdheXMgYXNzaWduIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAobmV3VmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHRoZSBuZXcgdmFsdWVcbiAgICBsZXQgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShuZXdWYWx1ZSk7XG5cbiAgICAvLyBpcyB2YWxpZCB0eXBlP1xuICAgIGlmIChuZXdWYWx1ZVR5cGUgIT09IHZhbHVlVHlwZSkge1xuICAgICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRUbyhuZXdWYWx1ZSwgdmFsdWVUeXBlKTtcblxuICAgICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgICBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKGNvbnZlcnRlZFZhbHVlKTtcblxuICAgICAgICAvLyBubyB2YWxpZCBjb252ZXJzaW9ucyBmb3VuZFxuICAgICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGBUcnlpbmcgdG8gYXNzaWduIHZhbHVlIHdpdGggaW5jb3JyZWN0IHR5cGUgdG8gXCIke29wdGlvbn1cIiwgYWxsb3dlZCB0eXBlOiBcIiR7dmFsdWVUeXBlfVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29udmVydGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufTtcblxuY29uc3QgY3JlYXRlT3B0aW9uID0gKGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKSA9PiB7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgc2V0OiBuZXdWYWx1ZSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBnZXRWYWx1ZUJ5VHlwZShuZXdWYWx1ZSwgZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yaW4ob3B0aW9ucywgcHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmluaXRpb24gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICBvYmpbcHJvcF0gPSBjcmVhdGVPcHRpb24ob3B0aW9uRGVmaW5pdGlvblswXSwgb3B0aW9uRGVmaW5pdGlvblsxXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdChvYmopO1xufTtcblxuY29uc3QgY3JlYXRlSW5pdGlhbFN0YXRlID0gb3B0aW9ucyA9PiAoe1xuICAgIC8vIG1vZGVsXG4gICAgaXRlbXM6IFtdLFxuXG4gICAgLy8gdGltZW91dCB1c2VkIGZvciBjYWxsaW5nIHVwZGF0ZSBpdGVtc1xuICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgLy8gdGltZW91dCB1c2VkIGZvciBzdGFja2luZyBtZXRhZGF0YSB1cGRhdGVzXG4gICAgaXRlbVVwZGF0ZVRpbWVvdXQ6IG51bGwsXG5cbiAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgIHByb2Nlc3NpbmdRdWV1ZTogW10sXG5cbiAgICAvLyBvcHRpb25zXG4gICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKSxcbn0pO1xuXG5jb25zdCBmcm9tQ2FtZWxzID0gKHN0cmluZywgc2VwYXJhdG9yID0gJy0nKSA9PlxuICAgIHN0cmluZ1xuICAgICAgICAuc3BsaXQoLyg/PVtBLVpdKS8pXG4gICAgICAgIC5tYXAocGFydCA9PiBwYXJ0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG5cbmNvbnN0IGNyZWF0ZU9wdGlvbkFQSSA9IChzdG9yZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGtleSA9PiB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XSxcbiAgICAgICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGBTRVRfJHtmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBjcmVhdGVPcHRpb25BY3Rpb25zID0gb3B0aW9ucyA9PiAoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGtleSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIG9ialtgU0VUXyR7bmFtZX1gXSA9IGFjdGlvbiA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3BlLCBmYWlsZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHNldCB0aGUgdmFsdWUgb2YgdGhpcyBvcHRpb25cbiAgICAgICAgICAgIGRpc3BhdGNoKGBESURfU0VUXyR7bmFtZX1gLCB7IHZhbHVlOiBzdGF0ZS5vcHRpb25zW2tleV0gfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGNyZWF0ZU9wdGlvblF1ZXJpZXMgPSBvcHRpb25zID0+IHN0YXRlID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3JpbihvcHRpb25zLCBrZXkgPT4ge1xuICAgICAgICBvYmpbYEdFVF8ke2Zyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCl9YF0gPSBhY3Rpb24gPT4gc3RhdGUub3B0aW9uc1trZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICBBUEk6IDEsXG4gICAgRFJPUDogMixcbiAgICBCUk9XU0U6IDMsXG4gICAgUEFTVEU6IDQsXG4gICAgTk9ORTogNSxcbn07XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT5cbiAgICBNYXRoLnJhbmRvbSgpXG4gICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgLnN1YnN0cmluZygyLCAxMSk7XG5cbmNvbnN0IGFycmF5UmVtb3ZlID0gKGFyciwgaW5kZXgpID0+IGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuXG5jb25zdCBydW4gPSAoY2IsIHN5bmMpID0+IHtcbiAgICBpZiAoc3luYykge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICB9XG59O1xuXG5jb25zdCBvbiA9ICgpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBjb25zdCBvZmYgPSAoZXZlbnQsIGNiKSA9PiB7XG4gICAgICAgIGFycmF5UmVtb3ZlKFxuICAgICAgICAgICAgbGlzdGVuZXJzLFxuICAgICAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChsaXN0ZW5lciA9PiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpKVxuICAgICAgICApO1xuICAgIH07XG4gICAgY29uc3QgZmlyZSA9IChldmVudCwgYXJncywgc3luYykgPT4ge1xuICAgICAgICBsaXN0ZW5lcnNcbiAgICAgICAgICAgIC5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50KVxuICAgICAgICAgICAgLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYilcbiAgICAgICAgICAgIC5mb3JFYWNoKGNiID0+IHJ1bigoKSA9PiBjYiguLi5hcmdzKSwgc3luYykpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlyZVN5bmM6IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgZmlyZShldmVudCwgYXJncywgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmU6IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgZmlyZShldmVudCwgYXJncywgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbjogKGV2ZW50LCBjYikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudCwgY2IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT25jZTogKGV2ZW50LCBjYikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGNiOiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvZmYoZXZlbnQsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvZmYsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QgPSAoc3JjLCB0YXJnZXQsIGV4Y2x1ZGVkKSA9PiB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3JjKVxuICAgICAgICAuZmlsdGVyKHByb3BlcnR5ID0+ICFleGNsdWRlZC5pbmNsdWRlcyhwcm9wZXJ0eSkpXG4gICAgICAgIC5mb3JFYWNoKGtleSA9PlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywga2V5KSlcbiAgICAgICAgKTtcbn07XG5cbmNvbnN0IFBSSVZBVEUgPSBbXG4gICAgJ2ZpcmUnLFxuICAgICdwcm9jZXNzJyxcbiAgICAncmV2ZXJ0JyxcbiAgICAnbG9hZCcsXG4gICAgJ29uJyxcbiAgICAnb2ZmJyxcbiAgICAnb25PbmNlJyxcbiAgICAncmV0cnlMb2FkJyxcbiAgICAnZXh0ZW5kJyxcbiAgICAnYXJjaGl2ZScsXG4gICAgJ2FyY2hpdmVkJyxcbiAgICAncmVsZWFzZScsXG4gICAgJ3JlbGVhc2VkJyxcbiAgICAncmVxdWVzdFByb2Nlc3NpbmcnLFxuICAgICdmcmVlemUnLFxuXTtcblxuY29uc3QgY3JlYXRlSXRlbUFQSSA9IGl0ZW0gPT4ge1xuICAgIGNvbnN0IGFwaSA9IHt9O1xuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoaXRlbSwgYXBpLCBQUklWQVRFKTtcbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgcmVtb3ZlUmVsZWFzZWRJdGVtcyA9IGl0ZW1zID0+IHtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5yZWxlYXNlZCkge1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUoaXRlbXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgSXRlbVN0YXR1cyA9IHtcbiAgICBJTklUOiAxLFxuICAgIElETEU6IDIsXG4gICAgUFJPQ0VTU0lOR19RVUVVRUQ6IDksXG4gICAgUFJPQ0VTU0lORzogMyxcbiAgICBQUk9DRVNTSU5HX0NPTVBMRVRFOiA1LFxuICAgIFBST0NFU1NJTkdfRVJST1I6IDYsXG4gICAgUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IDEwLFxuICAgIExPQURJTkc6IDcsXG4gICAgTE9BRF9FUlJPUjogOCxcbn07XG5cbmNvbnN0IEZpbGVPcmlnaW4gPSB7XG4gICAgSU5QVVQ6IDEsXG4gICAgTElNQk86IDIsXG4gICAgTE9DQUw6IDMsXG59O1xuXG5jb25zdCBnZXROb25OdW1lcmljID0gc3RyID0+IC9bXjAtOV0rLy5leGVjKHN0cik7XG5cbmNvbnN0IGdldERlY2ltYWxTZXBhcmF0b3IgPSAoKSA9PiBnZXROb25OdW1lcmljKCgxLjEpLnRvTG9jYWxlU3RyaW5nKCkpWzBdO1xuXG5jb25zdCBnZXRUaG91c2FuZHNTZXBhcmF0b3IgPSAoKSA9PiB7XG4gICAgLy8gQWRkZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHJldHVybiB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciAoaGFwcGVuZCBvbiBuYXRpdmUgYnJvd3NlciBBbmRyb2lkIDQuNC40KVxuICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgdGhlIG5vcm1hbCB0b1N0cmluZyBvdXRwdXQgYW5kIGlmIHRoZXkncmUgdGhlIHNhbWUgcmV0dXJuIGEgY29tbWEgd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBpcyBhIGRvdFxuICAgIGNvbnN0IGRlY2ltYWxTZXBhcmF0b3IgPSBnZXREZWNpbWFsU2VwYXJhdG9yKCk7XG4gICAgY29uc3QgdGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciA9ICgxMDAwLjApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgY29uc3QgdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciA9ICgxMDAwLjApLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgIT09IHRob3VzYW5kc1N0cmluZ1dpdGhvdXRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWModGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvcilbMF07XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG59O1xuXG5jb25zdCBUeXBlID0ge1xuICAgIEJPT0xFQU46ICdib29sZWFuJyxcbiAgICBJTlQ6ICdpbnQnLFxuICAgIE5VTUJFUjogJ251bWJlcicsXG4gICAgU1RSSU5HOiAnc3RyaW5nJyxcbiAgICBBUlJBWTogJ2FycmF5JyxcbiAgICBPQkpFQ1Q6ICdvYmplY3QnLFxuICAgIEZVTkNUSU9OOiAnZnVuY3Rpb24nLFxuICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgU0VSVkVSX0FQSTogJ3NlcnZlcmFwaScsXG4gICAgUkVHRVg6ICdyZWdleCcsXG59O1xuXG4vLyBhbGwgcmVnaXN0ZXJlZCBmaWx0ZXJzXG5jb25zdCBmaWx0ZXJzID0gW107XG5cbi8vIGxvb3BzIG92ZXIgbWF0Y2hpbmcgZmlsdGVycyBhbmQgcGFzc2VzIG9wdGlvbnMgdG8gZWFjaCBmaWx0ZXIsIHJldHVybmluZyB0aGUgbWFwcGVkIHJlc3VsdHNcbmNvbnN0IGFwcGx5RmlsdGVyQ2hhaW4gPSAoa2V5LCB2YWx1ZSwgdXRpbHMpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIGZpbHRlcnMgZm9yIHRoaXMga2V5XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRmlsdGVycyA9IGZpbHRlcnMuZmlsdGVyKGYgPT4gZi5rZXkgPT09IGtleSkubWFwKGYgPT4gZi5jYik7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBub3dcbiAgICAgICAgaWYgKG1hdGNoaW5nRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyIHRvIGtpY2sgdGhpbmdzIG9mXG4gICAgICAgIGNvbnN0IGluaXRpYWxGaWx0ZXIgPSBtYXRjaGluZ0ZpbHRlcnMuc2hpZnQoKTtcblxuICAgICAgICAvLyBjaGFpbiBmaWx0ZXJzXG4gICAgICAgIG1hdGNoaW5nRmlsdGVyc1xuICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgcHJvbWlzZXMgcGFzc2luZyB2YWx1ZSB0byBuZXh0IHByb21pc2VcbiAgICAgICAgICAgICAgICAoY3VycmVudCwgbmV4dCkgPT4gY3VycmVudC50aGVuKHZhbHVlID0+IG5leHQodmFsdWUsIHV0aWxzKSksXG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICAgICAgICBpbml0aWFsRmlsdGVyKHZhbHVlLCB1dGlscylcblxuICAgICAgICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSkpXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgfSk7XG5cbmNvbnN0IGFwcGx5RmlsdGVycyA9IChrZXksIHZhbHVlLCB1dGlscykgPT5cbiAgICBmaWx0ZXJzLmZpbHRlcihmID0+IGYua2V5ID09PSBrZXkpLm1hcChmID0+IGYuY2IodmFsdWUsIHV0aWxzKSk7XG5cbi8vIGFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBsaXN0XG5jb25zdCBhZGRGaWx0ZXIgPSAoa2V5LCBjYikgPT4gZmlsdGVycy5wdXNoKHsga2V5LCBjYiB9KTtcblxuY29uc3QgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBhZGRpdGlvbmFsT3B0aW9ucyA9PiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG5cbmNvbnN0IGdldE9wdGlvbnMgPSAoKSA9PiAoeyAuLi5kZWZhdWx0T3B0aW9ucyB9KTtcblxuY29uc3Qgc2V0T3B0aW9ucyA9IG9wdHMgPT4ge1xuICAgIGZvcmluKG9wdHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIGtleSBkb2VzIG5vdCBleGlzdCwgc28gdGhpcyBvcHRpb24gY2Fubm90IGJlIHNldFxuICAgICAgICBpZiAoIWRlZmF1bHRPcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0sXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICAgICk7XG4gICAgfSk7XG59O1xuXG4vLyBkZWZhdWx0IG9wdGlvbnMgb24gYXBwXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyB0aGUgaWQgdG8gYWRkIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICBpZDogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGlucHV0IGZpZWxkIG5hbWUgdG8gdXNlXG4gICAgbmFtZTogWydmaWxlcG9uZCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGRpc2FibGUgdGhlIGZpZWxkXG4gICAgZGlzYWJsZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIGNsYXNzbmFtZSB0byBwdXQgb24gd3JhcHBlclxuICAgIGNsYXNzTmFtZTogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGlzIHRoZSBmaWVsZCByZXF1aXJlZFxuICAgIHJlcXVpcmVkOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBBbGxvdyBtZWRpYSBjYXB0dXJlIHdoZW4gdmFsdWUgaXMgc2V0XG4gICAgY2FwdHVyZU1ldGhvZDogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICAvLyAtIFwiY2FtZXJhXCIsIFwibWljcm9waG9uZVwiIG9yIFwiY2FtY29yZGVyXCIsXG4gICAgLy8gLSBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGlwbGUgb24gYXBwbGUgZGV2aWNlc1xuICAgIC8vIC0gSWYgc2V0LCBhY2NlcHRlZEZpbGVUeXBlcyBtdXN0IGJlIG1hZGUgdG8gbWF0Y2ggd2l0aCBtZWRpYSB3aWxkY2FyZCBcImltYWdlLypcIiwgXCJhdWRpby8qXCIgb3IgXCJ2aWRlby8qXCJcblxuICAgIC8vIHN5bmMgYGFjY2VwdGVkRmlsZVR5cGVzYCBwcm9wZXJ0eSB3aXRoIGBhY2NlcHRgIGF0dHJpYnV0ZVxuICAgIGFsbG93U3luY0FjY2VwdEF0dHJpYnV0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBGZWF0dXJlIHRvZ2dsZXNcbiAgICBhbGxvd0Ryb3A6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBvZiBmaWxlc1xuICAgIGFsbG93QnJvd3NlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgYnJvd3NpbmcgdGhlIGZpbGUgc3lzdGVtXG4gICAgYWxsb3dQYXN0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHBhc3RpbmcgZmlsZXNcbiAgICBhbGxvd011bHRpcGxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG11bHRpcGxlIGZpbGVzIChkaXNhYmxlZCBieSBkZWZhdWx0LCBhcyBtdWx0aXBsZSBhdHRyaWJ1dGUgaXMgYWxzbyByZXF1aXJlZCBvbiBpbnB1dCB0byBhbGxvdyBtdWx0aXBsZSlcbiAgICBhbGxvd1JlcGxhY2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBhIGZpbGUgb24gb3RoZXIgZmlsZSB0byByZXBsYWNlIGl0IChvbmx5IHdvcmtzIHdoZW4gbXVsdGlwbGUgaXMgc2V0IHRvIGZhbHNlKVxuICAgIGFsbG93UmV2ZXJ0OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3dzIHVzZXIgdG8gcmV2ZXJ0IGZpbGUgdXBsb2FkXG4gICAgYWxsb3dSZW1vdmU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyB1c2VyIHRvIHJlbW92ZSBhIGZpbGVcbiAgICBhbGxvd1Byb2Nlc3M6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byBwcm9jZXNzIGEgZmlsZSwgd2hlbiBzZXQgdG8gZmFsc2UsIHRoaXMgcmVtb3ZlcyB0aGUgZmlsZSB1cGxvYWQgYnV0dG9uXG4gICAgYWxsb3dSZW9yZGVyOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHJlb3JkZXJpbmcgb2YgZmlsZXNcbiAgICBhbGxvd0RpcmVjdG9yaWVzT25seTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBvbmx5IHNlbGVjdGluZyBkaXJlY3RvcmllcyB3aXRoIGJyb3dzZSAobm8gc3VwcG9ydCBmb3IgZmlsdGVyaW5nIGRuZCBhdCB0aGlzIHBvaW50KVxuXG4gICAgLy8gVHJ5IHN0b3JlIGZpbGUgaWYgYHNlcnZlcmAgbm90IHNldFxuICAgIHN0b3JlQXNGaWxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBSZXZlcnQgbW9kZVxuICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgIG1heEZpbGVzOiBbbnVsbCwgVHlwZS5JTlRdLCAvLyBNYXggbnVtYmVyIG9mIGZpbGVzXG4gICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvIGZhbHNlIHRvIGFsd2F5cyBhZGQgaXRlbXMgdG8gYmVnaW4gb3IgZW5kIG9mIGxpc3RcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAvLyBEcmFnICduIERyb3AgcmVsYXRlZFxuICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wVmFsaWRhdGlvbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgb3IgZGlzYWJsZSB2YWxpZGF0aW5nIGZpbGVzIG9uIGRyb3BcbiAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgIGluc3RhbnRVcGxvYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTaG91bGQgdXBsb2FkIGZpbGVzIGltbWVkaWF0ZWx5IG9uIGRyb3BcbiAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG4gICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBpZiB0cnVlIHVwbG9hZHMgdGFrZSBhdCBsZWFzdCA3NTAgbXMsIHRoaXMgZW5zdXJlcyB0aGUgdXNlciBzZWVzIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZ2l2aW5nIHRydXN0IHRoZSB1cGxvYWQgYWN0dWFsbHkgaGFwcGVuZWRcblxuICAgIC8vIENodW5rc1xuICAgIGNodW5rVXBsb2FkczogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgY2h1bmtlZCB1cGxvYWRzXG4gICAgY2h1bmtGb3JjZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBGb3JjZSB1c2Ugb2YgY2h1bmsgdXBsb2FkcyBldmVuIGZvciBmaWxlcyBzbWFsbGVyIHRoYW4gY2h1bmsgc2l6ZVxuICAgIGNodW5rU2l6ZTogWzUwMDAwMDAsIFR5cGUuSU5UXSwgLy8gU2l6ZSBvZiBjaHVua3MgKDVNQiBkZWZhdWx0KVxuICAgIGNodW5rUmV0cnlEZWxheXM6IFtbNTAwLCAxMDAwLCAzMDAwXSwgVHlwZS5BUlJBWV0sIC8vIEFtb3VudCBvZiB0aW1lcyB0byByZXRyeSB1cGxvYWQgb2YgYSBjaHVuayB3aGVuIGl0IGZhaWxzXG5cbiAgICAvLyBUaGUgc2VydmVyIGFwaSBlbmQgcG9pbnRzIHRvIHVzZSBmb3IgdXBsb2FkaW5nIChzZWUgZG9jcylcbiAgICBzZXJ2ZXI6IFtudWxsLCBUeXBlLlNFUlZFUl9BUEldLFxuXG4gICAgLy8gRmlsZSBzaXplIGNhbGN1bGF0aW9ucywgY2FuIHNldCB0byAxMDI0LCB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGlzcGxheSwgcHJvcGVydGllcyB1c2UgZmlsZSBzaXplIGJhc2UgMTAwMFxuICAgIGZpbGVTaXplQmFzZTogWzEwMDAsIFR5cGUuSU5UXSxcblxuICAgIC8vIExhYmVscyBhbmQgc3RhdHVzIG1lc3NhZ2VzXG4gICAgbGFiZWxGaWxlU2l6ZUJ5dGVzOiBbJ2J5dGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVNpemVLaWxvYnl0ZXM6IFsnS0InLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU1lZ2FieXRlczogWydNQicsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVTaXplR2lnYWJ5dGVzOiBbJ0dCJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxEZWNpbWFsU2VwYXJhdG9yOiBbZ2V0RGVjaW1hbFNlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuICAgIGxhYmVsVGhvdXNhbmRzU2VwYXJhdG9yOiBbZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCksIFR5cGUuU1RSSU5HXSwgLy8gRGVmYXVsdCBpcyBsb2NhbGUgc2VwYXJhdG9yXG5cbiAgICBsYWJlbElkbGU6IFtcbiAgICAgICAgJ0RyYWcgJiBEcm9wIHlvdXIgZmlsZXMgb3IgPHNwYW4gY2xhc3M9XCJmaWxlcG9uZC0tbGFiZWwtYWN0aW9uXCI+QnJvd3NlPC9zcGFuPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG4gICAgbGFiZWxJbnZhbGlkRmllbGQ6IFsnRmllbGQgY29udGFpbnMgaW52YWxpZCBmaWxlcycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVXYWl0aW5nRm9yU2l6ZTogWydXYWl0aW5nIGZvciBzaXplJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVNpemVOb3RBdmFpbGFibGU6IFsnU2l6ZSBub3QgYXZhaWxhYmxlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUNvdW50U2luZ3VsYXI6IFsnZmlsZSBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUNvdW50UGx1cmFsOiBbJ2ZpbGVzIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlTG9hZGluZzogWydMb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUFkZGVkOiBbJ0FkZGVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgIGxhYmVsRmlsZUxvYWRFcnJvcjogWydFcnJvciBkdXJpbmcgbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVSZW1vdmVkOiBbJ1JlbW92ZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlUmVtb3ZlRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nOiBbJ1VwbG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nQ29tcGxldGU6IFsnVXBsb2FkIGNvbXBsZXRlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdBYm9ydGVkOiBbJ1VwbG9hZCBjYW5jZWxsZWQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yOiBbJ0Vycm9yIGR1cmluZyB1cGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yOiBbJ0Vycm9yIGR1cmluZyByZXZlcnQnLCBUeXBlLlNUUklOR10sXG5cbiAgICBsYWJlbFRhcFRvQ2FuY2VsOiBbJ3RhcCB0byBjYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxUYXBUb1JldHJ5OiBbJ3RhcCB0byByZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvVW5kbzogWyd0YXAgdG8gdW5kbycsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsQnV0dG9uUmVtb3ZlSXRlbTogWydSZW1vdmUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkOiBbJ0Fib3J0JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uUmV0cnlJdGVtTG9hZDogWydSZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IFsnQ2FuY2VsJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nOiBbJ1VuZG8nLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uUHJvY2Vzc0l0ZW06IFsnVXBsb2FkJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gbWFrZSBzdXJlIHdpZHRoIGFuZCBoZWlnaHQgcGx1cyB2aWV3cG94IGFyZSBldmVuIG51bWJlcnMgc28gaWNvbnMgYXJlIG5pY2VseSBjZW50ZXJlZFxuICAgIGljb25SZW1vdmU6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBpY29uUHJvY2VzczogW1xuICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBpY29uUmV0cnk6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuICAgIGljb25VbmRvOiBbXG4gICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG4gICAgaWNvbkRvbmU6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbndhcm5pbmc6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmluaXRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVhYm9ydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb251cGRhdGVmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBob29rc1xuICAgIGJlZm9yZURyb3BGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBiZWZvcmVQcmVwYXJlRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuXG4gICAgLy8gc3R5bGVzXG4gICAgc3R5bGVQYW5lbExheW91dDogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCAnaW50ZWdyYXRlZCcsICdjb21wYWN0JywgJ2NpcmNsZSdcbiAgICBzdHlsZVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgb3IgJzM6Micgb3IgMVxuICAgIHN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb246IFsnbGVmdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblByb2Nlc3NJdGVtUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVQcm9ncmVzc0luZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbUFsaWduOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBjdXN0b20gaW5pdGlhbCBmaWxlcyBhcnJheVxuICAgIGZpbGVzOiBbW10sIFR5cGUuQVJSQVldLFxuXG4gICAgLy8gc2hvdyBzdXBwb3J0IGJ5IGRpc3BsYXlpbmcgY3JlZGl0c1xuICAgIGNyZWRpdHM6IFtbJ2h0dHBzOi8vcHFpbmEubmwvJywgJ1Bvd2VyZWQgYnkgUFFJTkEnXSwgVHlwZS5BUlJBWV0sXG59O1xuXG5jb25zdCBnZXRJdGVtQnlRdWVyeSA9IChpdGVtcywgcXVlcnkpID0+IHtcbiAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgICByZXR1cm4gaXRlbXNbMF0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyBxdWVyeSBpcyBpbmRleFxuICAgIGlmIChpc0ludChxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGlzIGl0ZW0sIGdldCB0aGUgaWRcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmlkO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSBxdWVyeSBpcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0ZW0gYnkgaWRcbiAgICByZXR1cm4gaXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IHF1ZXJ5KSB8fCBudWxsO1xufTtcblxuY29uc3QgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGFzcGVjdFJhdGlvID0+IHtcbiAgICBpZiAoaXNFbXB0eShhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAoLzovLnRlc3QoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzFdIC8gcGFydHNbMF07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KGFzcGVjdFJhdGlvKTtcbn07XG5cbmNvbnN0IGdldEFjdGl2ZUl0ZW1zID0gaXRlbXMgPT4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uYXJjaGl2ZWQpO1xuXG5jb25zdCBTdGF0dXMgPSB7XG4gICAgRU1QVFk6IDAsXG4gICAgSURMRTogMSwgLy8gd2FpdGluZ1xuICAgIEVSUk9SOiAyLCAvLyBhIGZpbGUgaXMgaW4gZXJyb3Igc3RhdGVcbiAgICBCVVNZOiAzLCAvLyBidXN5IHByb2Nlc3Npbmcgb3IgbG9hZGluZ1xuICAgIFJFQURZOiA0LCAvLyBhbGwgZmlsZXMgdXBsb2FkZWRcbn07XG5cbmxldCByZXMgPSBudWxsO1xuY29uc3QgY2FuVXBkYXRlRmlsZUlucHV0ID0gKCkgPT4ge1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQobmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnVGhpc19Xb3Jrcy50eHQnKSk7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgICAgZWwuZmlsZXMgPSBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICByZXMgPSBlbC5maWxlcy5sZW5ndGggPT09IDE7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0IElURU1fRVJST1IgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SLFxuXTtcbmNvbnN0IElURU1fQlVTWSA9IFtcbiAgICBJdGVtU3RhdHVzLkxPQURJTkcsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQsXG4gICAgSXRlbVN0YXR1cy5JTklULFxuXTtcbmNvbnN0IElURU1fUkVBRFkgPSBbSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFXTtcblxuY29uc3QgaXNJdGVtSW5FcnJvclN0YXRlID0gaXRlbSA9PiBJVEVNX0VSUk9SLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbmNvbnN0IGlzSXRlbUluQnVzeVN0YXRlID0gaXRlbSA9PiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuY29uc3QgaXNJdGVtSW5SZWFkeVN0YXRlID0gaXRlbSA9PiBJVEVNX1JFQURZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcblxuY29uc3QgaXNBc3luYyA9IHN0YXRlID0+XG4gICAgaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIpICYmXG4gICAgKGlzT2JqZWN0KHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpIHx8IGlzRnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIucHJvY2VzcykpO1xuXG5jb25zdCBxdWVyaWVzID0gc3RhdGUgPT4gKHtcbiAgICBHRVRfU1RBVFVTOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGNvbnN0IHsgRU1QVFksIEVSUk9SLCBCVVNZLCBJRExFLCBSRUFEWSB9ID0gU3RhdHVzO1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWTtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkVycm9yU3RhdGUpKSByZXR1cm4gRVJST1I7XG5cbiAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5CdXN5U3RhdGUpKSByZXR1cm4gQlVTWTtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JblJlYWR5U3RhdGUpKSByZXR1cm4gUkVBRFk7XG5cbiAgICAgICAgcmV0dXJuIElETEU7XG4gICAgfSxcblxuICAgIEdFVF9JVEVNOiBxdWVyeSA9PiBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpLFxuXG4gICAgR0VUX0FDVElWRV9JVEVNOiBxdWVyeSA9PiBnZXRJdGVtQnlRdWVyeShnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyksIHF1ZXJ5KSxcblxuICAgIEdFVF9BQ1RJVkVfSVRFTVM6ICgpID0+IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSxcblxuICAgIEdFVF9JVEVNUzogKCkgPT4gc3RhdGUuaXRlbXMsXG5cbiAgICBHRVRfSVRFTV9OQU1FOiBxdWVyeSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZW5hbWUgOiBudWxsO1xuICAgIH0sXG5cbiAgICBHRVRfSVRFTV9TSVpFOiBxdWVyeSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZVNpemUgOiBudWxsO1xuICAgIH0sXG5cbiAgICBHRVRfU1RZTEVTOiAoKSA9PlxuICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gL15zdHlsZS8udGVzdChrZXkpKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLm9wdGlvbnNbb3B0aW9uXSxcbiAgICAgICAgICAgIH0pKSxcblxuICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNTaGFwZUNpcmNsZSA9IC9jaXJjbGUvLnRlc3Qoc3RhdGUub3B0aW9ucy5zdHlsZVBhbmVsTGF5b3V0KTtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpc1NoYXBlQ2lyY2xlXG4gICAgICAgICAgICA/IDFcbiAgICAgICAgICAgIDogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpbyk7XG4gICAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9LFxuXG4gICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiAoKSA9PiBzdGF0ZS5vcHRpb25zLnN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW8sXG5cbiAgICBHRVRfSVRFTVNfQllfU1RBVFVTOiBzdGF0dXMgPT5cbiAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSBzdGF0dXMpLFxuXG4gICAgR0VUX1RPVEFMX0lURU1TOiAoKSA9PiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoLFxuXG4gICAgU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUOiAoKSA9PlxuICAgICAgICBzdGF0ZS5vcHRpb25zLnN0b3JlQXNGaWxlICYmIGNhblVwZGF0ZUZpbGVJbnB1dCgpICYmICFpc0FzeW5jKHN0YXRlKSxcblxuICAgIElTX0FTWU5DOiAoKSA9PiBpc0FzeW5jKHN0YXRlKSxcblxuICAgIEdFVF9GSUxFX1NJWkVfTEFCRUxTOiBxdWVyeSA9PiAoe1xuICAgICAgICBsYWJlbEJ5dGVzOiBxdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9CWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxLaWxvYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0tJTE9CWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxNZWdhYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX01FR0FCWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxHaWdhYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0dJR0FCWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICB9KSxcbn0pO1xuXG5jb25zdCBoYXNSb29tRm9ySXRlbSA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBjb3VudCA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG5cbiAgICAvLyBpZiBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBpdGVtcywgdG8gYWRkIG9uZSBpdGVtIGl0IHNob3VsZCBjdXJyZW50bHkgbm90IGNvbnRhaW4gaXRlbXNcbiAgICBpZiAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgY29uc3QgbWF4RmlsZUNvdW50ID0gc3RhdGUub3B0aW9ucy5tYXhGaWxlcztcbiAgICBpZiAobWF4RmlsZUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdlIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNvdW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4IGNvdW50LCBpZiBzbywgYW5vdGhlciBmaWxlIGNhbiBzdGlsbCBiZSBhZGRlZFxuICAgIGlmIChjb3VudCA8IG1heEZpbGVDb3VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20gZm9yIGFub3RoZXIgZmlsZVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGxpbWl0ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG5cbmNvbnN0IGFycmF5SW5zZXJ0ID0gKGFyciwgaW5kZXgsIGl0ZW0pID0+IGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuXG5jb25zdCBpbnNlcnRJdGVtID0gKGl0ZW1zLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgIGlmIChpc0VtcHR5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGluZGV4IGlzIHVuZGVmaW5lZCwgYXBwZW5kXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLy8gbGltaXQgdGhlIGluZGV4IHRvIHRoZSBzaXplIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgIGluZGV4ID0gbGltaXQoaW5kZXgsIDAsIGl0ZW1zLmxlbmd0aCk7XG5cbiAgICAvLyBhZGQgaXRlbSB0byBhcnJheVxuICAgIGFycmF5SW5zZXJ0KGl0ZW1zLCBpbmRleCwgaXRlbSk7XG5cbiAgICAvLyBleHBvc2VcbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbmNvbnN0IGlzQmFzZTY0RGF0YVVSSSA9IHN0ciA9PlxuICAgIC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2Etei1dKz1bYS16MC05LV0rKT8pPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHNdKilcXHMqJC9pLnRlc3QoXG4gICAgICAgIHN0clxuICAgICk7XG5cbmNvbnN0IGdldEZpbGVuYW1lRnJvbVVSTCA9IHVybCA9PlxuICAgIGAke3VybH1gXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5wb3AoKVxuICAgICAgICAuc3BsaXQoJz8nKVxuICAgICAgICAuc2hpZnQoKTtcblxuY29uc3QgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lID0gbmFtZSA9PiBuYW1lLnNwbGl0KCcuJykucG9wKCk7XG5cbmNvbnN0IGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gdHlwZSA9PiB7XG4gICAgLy8gaWYgbm8gZXh0ZW5zaW9uIHN1cHBsaWVkLCBleGl0IGhlcmVcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBnZXQgc3VidHlwZVxuICAgIGNvbnN0IHN1YnR5cGUgPSB0eXBlLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnc3ZnJztcbiAgICB9XG5cbiAgICBpZiAoL3ppcHxjb21wcmVzc2VkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnemlwJztcbiAgICB9XG5cbiAgICBpZiAoL3BsYWluLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAndHh0JztcbiAgICB9XG5cbiAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsaWQgc3VidHlwZVxuICAgIGlmICgvW2Etel0rLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIC8vIGFsd2F5cyB1c2UganBnIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2pwZyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gc3VidHlwZVxuICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59O1xuXG5jb25zdCBsZWZ0UGFkID0gKHZhbHVlLCBwYWRkaW5nID0gJycpID0+IChwYWRkaW5nICsgdmFsdWUpLnNsaWNlKC1wYWRkaW5nLmxlbmd0aCk7XG5cbmNvbnN0IGdldERhdGVTdHJpbmcgPSAoZGF0ZSA9IG5ldyBEYXRlKCkpID0+XG4gICAgYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0ke2xlZnRQYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgJzAwJyl9LSR7bGVmdFBhZChcbiAgICAgICAgZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICcwMCdcbiAgICApfV8ke2xlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKX0tJHtsZWZ0UGFkKGRhdGUuZ2V0TWludXRlcygpLCAnMDAnKX0tJHtsZWZ0UGFkKFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgJzAwJ1xuICAgICl9YDtcblxuY29uc3QgZ2V0RmlsZUZyb21CbG9iID0gKGJsb2IsIGZpbGVuYW1lLCB0eXBlID0gbnVsbCwgZXh0ZW5zaW9uID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPVxuICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIHR5cGUpXG4gICAgICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAvLyBpZiBibG9iIGhhcyBuYW1lIHByb3BlcnR5LCB1c2UgYXMgZmlsZW5hbWUgaWYgbm8gZmlsZW5hbWUgc3VwcGxpZWRcbiAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgICBmaWxlbmFtZSA9IGdldERhdGVTdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBmaWxlbmFtZSBzdXBwbGllZCBidXQgbm8gZXh0ZW5zaW9uIGFuZCBmaWxlbmFtZSBoYXMgZXh0ZW5zaW9uXG4gICAgaWYgKGZpbGVuYW1lICYmIGV4dGVuc2lvbiA9PT0gbnVsbCAmJiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZW5hbWUpKSB7XG4gICAgICAgIGZpbGUubmFtZSA9IGZpbGVuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZSArIChleHRlbnNpb24gPyAnLicgKyBleHRlbnNpb24gOiAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG59O1xuXG5jb25zdCBnZXRCbG9iQnVpbGRlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKHdpbmRvdy5CbG9iQnVpbGRlciA9XG4gICAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUJsb2IgPSAoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSA9PiB7XG4gICAgY29uc3QgQkIgPSBnZXRCbG9iQnVpbGRlcigpO1xuXG4gICAgaWYgKEJCKSB7XG4gICAgICAgIGNvbnN0IGJiID0gbmV3IEJCKCk7XG4gICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwge1xuICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZSA9IChieXRlU3RyaW5nLCBtaW1lVHlwZSkgPT4ge1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgICBjb25zdCBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQmxvYihhYiwgbWltZVR5cGUpO1xufTtcblxuY29uc3QgZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSSA9IGRhdGFVUkkgPT4ge1xuICAgIHJldHVybiAoL15kYXRhOiguKyk7Ly5leGVjKGRhdGFVUkkpIHx8IFtdKVsxXSB8fCBudWxsO1xufTtcblxuY29uc3QgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZGF0YVVSSSA9PiB7XG4gICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhVVJJLnNwbGl0KCcsJylbMV07XG5cbiAgICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgYXMgdGhhdCBjYXVzZXMgSW52YWxpZENoYXJhY3RlckVycm9yIGluIElFXG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmNvbnN0IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGRhdGFVUkkgPT4ge1xuICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG59O1xuXG5jb25zdCBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkgPSBkYXRhVVJJID0+IHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSk7XG4gICAgY29uc3QgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgIHJldHVybiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoYnl0ZVN0cmluZywgbWltZVR5cGUpO1xufTtcblxuY29uc3QgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJID0gKGRhdGFVUkksIGZpbGVuYW1lLCBleHRlbnNpb24pID0+IHtcbiAgICByZXR1cm4gZ2V0RmlsZUZyb21CbG9iKGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSwgZmlsZW5hbWUsIG51bGwsIGV4dGVuc2lvbik7XG59O1xuXG5jb25zdCBnZXRGaWxlTmFtZUZyb21IZWFkZXIgPSBoZWFkZXIgPT4ge1xuICAgIC8vIHRlc3QgaWYgaXMgY29udGVudCBkaXNwb3NpdGlvbiBoZWFkZXIsIGlmIG5vdCBleGl0XG4gICAgaWYgKCEvXmNvbnRlbnQtZGlzcG9zaXRpb246L2kudGVzdChoZWFkZXIpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGdldCBmaWxlbmFtZSBwYXJ0c1xuICAgIGNvbnN0IG1hdGNoZXMgPSBoZWFkZXJcbiAgICAgICAgLnNwbGl0KC9maWxlbmFtZT18ZmlsZW5hbWVcXCo9LisnJy8pXG4gICAgICAgIC5zcGxpY2UoMSlcbiAgICAgICAgLm1hcChuYW1lID0+IG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZS5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID8gZGVjb2RlVVJJKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSkgOiBudWxsO1xufTtcblxuY29uc3QgZ2V0RmlsZVNpemVGcm9tSGVhZGVyID0gaGVhZGVyID0+IHtcbiAgICBpZiAoL2NvbnRlbnQtbGVuZ3RoOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICBjb25zdCBzaXplID0gaGVhZGVyLm1hdGNoKC9bMC05XSsvKVswXTtcbiAgICAgICAgcmV0dXJuIHNpemUgPyBwYXJzZUludChzaXplLCAxMCkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyID0gaGVhZGVyID0+IHtcbiAgICBpZiAoL3gtY29udGVudC10cmFuc2Zlci1pZDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgY29uc3QgaWQgPSAoaGVhZGVyLnNwbGl0KCc6JylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGlkIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgc2l6ZTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3Qgcm93cyA9IGhlYWRlcnMuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGhlYWRlciBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRGaWxlTmFtZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIGluZm8uc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGluZm8uc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbn07XG5cbmNvbnN0IGNyZWF0ZUZpbGVMb2FkZXIgPSBmZXRjaEZuID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICBzaXplOiBudWxsLFxuICAgICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCBnZXRQcm9ncmVzcyA9ICgpID0+IHN0YXRlLnByb2dyZXNzO1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVxdWVzdCAmJiBzdGF0ZS5yZXF1ZXN0LmFib3J0KSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzb3VyY2VcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcblxuICAgICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgICAgLy8gTG9hZCBGaWxlc1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIC8vIExvYWQgYmxvYnMsIHNldCBkZWZhdWx0IG5hbWUgdG8gY3VycmVudCBkYXRlXG4gICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVhbCBhcyBpZiBpcyBleHRlcm5hbCBVUkwsIGxldCdzIGxvYWQgaXQhXG4gICAgICAgICAgICBsb2FkVVJMKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZHMgYSB1cmxcbiAgICBjb25zdCBsb2FkVVJMID0gdXJsID0+IHtcbiAgICAgICAgLy8gaXMgcmVtb3RlIHVybCBhbmQgbm8gZmV0Y2ggbWV0aG9kIHN1cHBsaWVkXG4gICAgICAgIGlmICghZmV0Y2hGbikge1xuICAgICAgICAgICAgYXBpLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYm9keTogXCJDYW4ndCBsb2FkIFVSTFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IDQwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBsb2FkIGZpbGVcbiAgICAgICAgc3RhdGUucmVxdWVzdCA9IGZldGNoRm4oXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyB0dXJuIGJsb2IgcmVzcG9uc2UgaW50byBhIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZ2V0RmlsZUZyb21CbG9iKHJlc3BvbnNlLCByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgYmxvYiwgd2UgZ28gd2l0aCBibG9iLCBpZiBubyByZXNwb25zZSwgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iID8gcmVzcG9uc2UgOiByZXNwb25zZSA/IHJlc3BvbnNlLmJvZHkgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdGVkIHNvbWUgbWV0YSBkYXRhIGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgcHJvZ3Jlc3MsIHdlJ3JlIG5vdCBnb2luZyB0byBmaXJlIHByb2dyZXNzIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gY3VycmVudCAvIHRvdGFsO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgc3RhdGUucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZWluZm8gPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbWV0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBmaWxlaW5mby5zaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZWluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmaWxlaW5mby5zb3VyY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgLi4ub24oKSxcbiAgICAgICAgc2V0U291cmNlOiBzb3VyY2UgPT4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSksXG4gICAgICAgIGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgICAgYWJvcnQsIC8vIGFib3J0IGZpbGUgbG9hZFxuICAgICAgICBsb2FkLCAvLyBzdGFydCBsb2FkXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBpc0dldCA9IG1ldGhvZCA9PiAvR0VUfEhFQUQvLnRlc3QobWV0aG9kKTtcblxuY29uc3Qgc2VuZFJlcXVlc3QgPSAoZGF0YSwgdXJsLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICBvbmhlYWRlcnM6ICgpID0+IHt9LFxuICAgICAgICBvbnByb2dyZXNzOiAoKSA9PiB7fSxcbiAgICAgICAgb25sb2FkOiAoKSA9PiB7fSxcbiAgICAgICAgb250aW1lb3V0OiAoKSA9PiB7fSxcbiAgICAgICAgb25lcnJvcjogKCkgPT4ge30sXG4gICAgICAgIG9uYWJvcnQ6ICgpID0+IHt9LFxuICAgICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGxldCBoZWFkZXJzUmVjZWl2ZWQgPSBmYWxzZTtcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIGVuY29kZSB1cmxcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcblxuICAgIC8vIGlmIG1ldGhvZCBpcyBHRVQsIGFkZCBhbnkgcmVjZWl2ZWQgZGF0YSB0byB1cmxcblxuICAgIGlmIChpc0dldChvcHRpb25zLm1ldGhvZCkgJiYgZGF0YSkge1xuICAgICAgICB1cmwgPSBgJHt1cmx9JHtlbmNvZGVVUklDb21wb25lbnQodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEpTT04uc3RyaW5naWZ5KGRhdGEpKX1gO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSByZXF1ZXN0XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBwcm9ncmVzcyBvZiBsb2FkXG4gICAgY29uc3QgcHJvY2VzcyA9IGlzR2V0KG9wdGlvbnMubWV0aG9kKSA/IHhociA6IHhoci51cGxvYWQ7XG4gICAgcHJvY2Vzcy5vbnByb2dyZXNzID0gZSA9PiB7XG4gICAgICAgIC8vIG5vIHByb2dyZXNzIGV2ZW50IHdoZW4gYWJvcnRlZCAoIG9ucHJvZ3Jlc3MgaXMgY2FsbGVkIG9uY2UgYWZ0ZXIgYWJvcnQoKSApXG4gICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcGkub25wcm9ncmVzcyhlLmxlbmd0aENvbXB1dGFibGUsIGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIG5vdCBpbnRlcmVzdGluZyBpbiB0aGVzZSBzdGF0ZXMgKCd1bnNlbnQnIGFuZCAnb3BlbmVuZCcgYXMgdGhleSBkb24ndCBnaXZlIHVzIGFueSBhZGRpdGlvbmFsIGluZm8pXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHNlcnZlciByZXNwb25zZVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyc1JlY2VpdmVkID0gdHJ1ZTtcblxuICAgICAgICAvLyB3ZSd2ZSBwcm9iYWJseSByZWNlaXZlZCBzb21lIHVzZWZ1bCBkYXRhIGluIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgYXBpLm9uaGVhZGVycyh4aHIpO1xuICAgIH07XG5cbiAgICAvLyBsb2FkIHN1Y2Nlc3NmdWxcbiAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBpcyBjbGFzc2lmaWVkIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICBhcGkub25sb2FkKHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcGkub25lcnJvcih4aHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGVycm9yIGR1cmluZyBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiBhcGkub25lcnJvcih4aHIpO1xuXG4gICAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBhcGkub25hYm9ydCgpO1xuICAgIH07XG5cbiAgICAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICB4aHIub250aW1lb3V0ID0gKCkgPT4gYXBpLm9udGltZW91dCh4aHIpO1xuXG4gICAgLy8gb3BlbiB1cCBvcGVuIHVwIVxuICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgLy8gc2V0IHRpbWVvdXQgaWYgZGVmaW5lZCAoZG8gaXQgYWZ0ZXIgb3BlbiBzbyBJRTExIHBsYXlzIGJhbGwpXG4gICAgaWYgKGlzSW50KG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuXG4gICAgLy8gYWRkIGhlYWRlcnNcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5oZWFkZXJzW2tleV0pKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gc2V0IGNyZWRlbnRpYWxzXG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxldCdzIHNlbmQgb3VyIGRhdGFcbiAgICB4aHIuc2VuZChkYXRhKTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBjcmVhdGVSZXNwb25zZSA9ICh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSA9PiAoe1xuICAgIHR5cGUsXG4gICAgY29kZSxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG59KTtcblxuY29uc3QgY3JlYXRlVGltZW91dFJlc3BvbnNlID0gY2IgPT4geGhyID0+IHtcbiAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xufTtcblxuY29uc3QgaGFzUVMgPSBzdHIgPT4gL1xcPy8udGVzdChzdHIpO1xuY29uc3QgYnVpbGRVUkwgPSAoLi4ucGFydHMpID0+IHtcbiAgICBsZXQgdXJsID0gJyc7XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgdXJsICs9IGhhc1FTKHVybCkgJiYgaGFzUVMocGFydCkgPyBwYXJ0LnJlcGxhY2UoL1xcPy8sICcmJykgOiBwYXJ0O1xuICAgIH0pO1xuICAgIHJldHVybiB1cmw7XG59O1xuXG5jb25zdCBjcmVhdGVGZXRjaEZ1bmN0aW9uID0gKGFwaVVybCA9ICcnLCBhY3Rpb24pID0+IHtcbiAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5sZGVyXG4gICAgY29uc3Qgb25sb2FkID0gYWN0aW9uLm9ubG9hZCB8fCAocmVzID0+IHJlcyk7XG4gICAgY29uc3Qgb25lcnJvciA9IGFjdGlvbi5vbmVycm9yIHx8IChyZXMgPT4gbnVsbCk7XG5cbiAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgcmV0dXJuICh1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgLy8gZG8gbG9jYWwgb3IgcmVtb3RlIHJlcXVlc3QgYmFzZWQgb24gaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QodXJsLCBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLCB7XG4gICAgICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSByZXNwb25zZVxuICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24ubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRGaWxlRnJvbUJsb2Iob25sb2FkKHhoci5yZXNwb25zZSksIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSB4aHIgPT4ge1xuICAgICAgICAgICAgaGVhZGVycyhjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xufTtcblxuY29uc3QgQ2h1bmtTdGF0dXMgPSB7XG4gICAgUVVFVUVEOiAwLFxuICAgIENPTVBMRVRFOiAxLFxuICAgIFBST0NFU1NJTkc6IDIsXG4gICAgRVJST1I6IDMsXG4gICAgV0FJVElORzogNCxcbn07XG5cbi8qXG5mdW5jdGlvbiBzaWduYXR1cmU6XG4gIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgIGFib3J0OigpID0+IHt9XG4gIH1cbn1cbiovXG5cbi8vIGFwaVVybCwgYWN0aW9uLCBuYW1lLCBmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnNcbmNvbnN0IHByb2Nlc3NGaWxlQ2h1bmtlZCA9IChcbiAgICBhcGlVcmwsXG4gICAgYWN0aW9uLFxuICAgIG5hbWUsXG4gICAgZmlsZSxcbiAgICBtZXRhZGF0YSxcbiAgICBsb2FkLFxuICAgIGVycm9yLFxuICAgIHByb2dyZXNzLFxuICAgIGFib3J0LFxuICAgIHRyYW5zZmVyLFxuICAgIG9wdGlvbnNcbikgPT4ge1xuICAgIC8vIGFsbCBjaHVua3NcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBjb25zdCB7IGNodW5rVHJhbnNmZXJJZCwgY2h1bmtTZXJ2ZXIsIGNodW5rU2l6ZSwgY2h1bmtSZXRyeURlbGF5cyB9ID0gb3B0aW9ucztcblxuICAgIC8vIGRlZmF1bHQgc3RhdGVcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc2VydmVySWQ6IGNodW5rVHJhbnNmZXJJZCxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIHNldCBvbmxvYWQgaGFuZGxlcnNcbiAgICBjb25zdCBvbmRhdGEgPSBhY3Rpb24ub25kYXRhIHx8IChmZCA9PiBmZCk7XG4gICAgY29uc3Qgb25sb2FkID1cbiAgICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgICAoKHhociwgbWV0aG9kKSA9PlxuICAgICAgICAgICAgbWV0aG9kID09PSAnSEVBRCcgPyB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1VwbG9hZC1PZmZzZXQnKSA6IHhoci5yZXNwb25zZSk7XG4gICAgY29uc3Qgb25lcnJvciA9IGFjdGlvbi5vbmVycm9yIHx8IChyZXMgPT4gbnVsbCk7XG5cbiAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICBjb25zdCByZXF1ZXN0VHJhbnNmZXJJZCA9IGNiID0+IHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhmaWxlLCBtZXRhZGF0YSlcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3Qob25kYXRhKGZvcm1EYXRhKSwgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT5cbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0VHJhbnNmZXJPZmZzZXQgPSBjYiA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhzdGF0ZS5zZXJ2ZXJJZClcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgcmVxdWVzdFVybCwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT5cbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGUgY2h1bmtzXG4gICAgY29uc3QgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdENodW5rSW5kZXg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICBjb25zdCBkYXRhID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSwgJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKTtcbiAgICAgICAgY2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgcmV0cmllczogWy4uLmNodW5rUmV0cnlEZWxheXNdLFxuICAgICAgICAgICAgc3RhdHVzOiBDaHVua1N0YXR1cy5RVUVVRUQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICB0aW1lb3V0OiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyA9ICgpID0+IGxvYWQoc3RhdGUuc2VydmVySWQpO1xuXG4gICAgY29uc3QgY2FuUHJvY2Vzc0NodW5rID0gY2h1bmsgPT5cbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5RVUVVRUQgfHwgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5FUlJPUjtcblxuICAgIGNvbnN0IHByb2Nlc3NDaHVuayA9IGNodW5rID0+IHtcbiAgICAgICAgLy8gcHJvY2Vzc2luZyBpcyBwYXVzZWQsIHdhaXQgaGVyZVxuICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBuZXh0IGNodW5rIHRvIHByb2Nlc3NcbiAgICAgICAgY2h1bmsgPSBjaHVuayB8fCBjaHVua3MuZmluZChjYW5Qcm9jZXNzQ2h1bmspO1xuXG4gICAgICAgIC8vIG5vIG1vcmUgY2h1bmtzIHRvIHByb2Nlc3NcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgLy8gYWxsIGRvbmU/XG4gICAgICAgICAgICBpZiAoY2h1bmtzLmV2ZXJ5KGNodW5rID0+IGNodW5rLnN0YXR1cyA9PT0gQ2h1bmtTdGF0dXMuQ09NUExFVEUpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIGNodW5rIHRvIGhhbmRsZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHByb2Nlc3NpbmcgdGhpcyBjaHVua1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICBjaHVuay5wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgICAgLy8gYWxsb3cgcGFyc2luZyBvZiBmb3JtZGF0YVxuICAgICAgICBjb25zdCBvbmRhdGEgPSBjaHVua1NlcnZlci5vbmRhdGEgfHwgKGZkID0+IGZkKTtcbiAgICAgICAgY29uc3Qgb25lcnJvciA9IGNodW5rU2VydmVyLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcbiAgICAgICAgY29uc3Qgb25sb2FkID0gY2h1bmtTZXJ2ZXIub25sb2FkIHx8ICgoKSA9PiB7fSk7XG5cbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICBjb25zdCByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICBjb25zdCBoZWFkZXJzID1cbiAgICAgICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBjaHVua1NlcnZlci5oZWFkZXJzKGNodW5rKVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmNodW5rU2VydmVyLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IGNodW5rLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLU5hbWUnOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoY2h1bmsucmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG9uZGF0YShjaHVuay5kYXRhKSwgcmVxdWVzdFVybCwge1xuICAgICAgICAgICAgLi4uY2h1bmtTZXJ2ZXIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgLy8gYWxsb3cgaG9va2luZyBpbnRvIHJlcXVlc3QgcmVzdWx0XG4gICAgICAgICAgICBvbmxvYWQoeGhyLCBjaHVuay5pbmRleCwgY2h1bmtzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBtb3JlIGNodW5rc1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IChsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHhociA9PiB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgY2h1bmsuZXJyb3IgPSBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0geGhyID0+IHtcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcikoeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5UHJvY2Vzc0NodW5rID0gY2h1bmsgPT4ge1xuICAgICAgICAvLyBubyBtb3JlIHJldHJpZXMgbGVmdFxuICAgICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBuZXcgcmV0cnlcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuV0FJVElORztcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICBjaHVuay50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9LCBjaHVuay5yZXRyaWVzLnNoaWZ0KCkpO1xuXG4gICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJldHJ5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVUb3RhbFByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MgZnJhY3Rpb25cbiAgICAgICAgY29uc3QgdG90YWxCeXRlc1RyYW5zZmVyZWQgPSBjaHVua3MucmVkdWNlKChwLCBjaHVuaykgPT4ge1xuICAgICAgICAgICAgaWYgKHAgPT09IG51bGwgfHwgY2h1bmsucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBjaHVuay5wcm9ncmVzcztcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgLy8gY2FuJ3QgY29tcHV0ZSBwcm9ncmVzc1xuICAgICAgICBpZiAodG90YWxCeXRlc1RyYW5zZmVyZWQgPT09IG51bGwpIHJldHVybiBwcm9ncmVzcyhmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBjaHVua3MucmVkdWNlKCh0b3RhbCwgY2h1bmspID0+IHRvdGFsICsgY2h1bmsuc2l6ZSwgMCk7XG5cbiAgICAgICAgLy8gY2FuIHVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgcHJvZ3Jlc3ModHJ1ZSwgdG90YWxCeXRlc1RyYW5zZmVyZWQsIHRvdGFsU2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgIGNvbnN0IHByb2Nlc3NDaHVua3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJvY2Vzc2luZyA9IGNodW5rcy5maWx0ZXIoY2h1bmsgPT4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HKVxuICAgICAgICAgICAgLmxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsUHJvY2Vzc2luZyA+PSAxKSByZXR1cm47XG4gICAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgIH07XG5cbiAgICBjb25zdCBhYm9ydENodW5rcyA9ICgpID0+IHtcbiAgICAgICAgY2h1bmtzLmZvckVhY2goY2h1bmsgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBsZXQncyBnbyFcbiAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICAgIHJlcXVlc3RUcmFuc2ZlcklkKHNlcnZlcklkID0+IHtcbiAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHBhc3MgYmFjayB0byBpdGVtIHNvIHdlIGNhbiB1c2UgaXQgaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgICAgICAgIHRyYW5zZmVyKHNlcnZlcklkKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgaW50ZXJuYWxseVxuICAgICAgICAgICAgc3RhdGUuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KG9mZnNldCA9PiB7XG4gICAgICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBtYXJrIGNodW5rcyB3aXRoIGxvd2VyIG9mZnNldCBhcyBjb21wbGV0ZVxuICAgICAgICAgICAgY2h1bmtzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjaHVuayA9PiBjaHVuay5vZmZzZXQgPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBjaHVuay5zaXplO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGFib3J0Q2h1bmtzKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbi8qXG5mdW5jdGlvbiBzaWduYXR1cmU6XG4gIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgYWJvcnQ6KCkgPT4ge31cbiAgfVxufVxuKi9cbmNvbnN0IGNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbiA9IChhcGlVcmwsIGFjdGlvbiwgbmFtZSwgb3B0aW9ucykgPT4gKFxuICAgIGZpbGUsXG4gICAgbWV0YWRhdGEsXG4gICAgbG9hZCxcbiAgICBlcnJvcixcbiAgICBwcm9ncmVzcyxcbiAgICBhYm9ydCxcbiAgICB0cmFuc2ZlclxuKSA9PiB7XG4gICAgLy8gbm8gZmlsZSByZWNlaXZlZFxuICAgIGlmICghZmlsZSkgcmV0dXJuO1xuXG4gICAgLy8gaWYgd2FzIHBhc3NlZCBhIGZpbGUsIGFuZCB3ZSBjYW4gY2h1bmsgaXQsIGV4aXQgaGVyZVxuICAgIGNvbnN0IGNhbkNodW5rVXBsb2FkID0gb3B0aW9ucy5jaHVua1VwbG9hZHM7XG4gICAgY29uc3Qgc2hvdWxkQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiBmaWxlLnNpemUgPiBvcHRpb25zLmNodW5rU2l6ZTtcbiAgICBjb25zdCB3aWxsQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiAoc2hvdWxkQ2h1bmtVcGxvYWQgfHwgb3B0aW9ucy5jaHVua0ZvcmNlKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgJiYgd2lsbENodW5rVXBsb2FkKVxuICAgICAgICByZXR1cm4gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIGxvYWQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICB0cmFuc2ZlcixcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgIC8vIHNldCBoYW5kbGVyc1xuICAgIGNvbnN0IG9uZGF0YSA9IGFjdGlvbi5vbmRhdGEgfHwgKGZkID0+IGZkKTtcbiAgICBjb25zdCBvbmxvYWQgPSBhY3Rpb24ub25sb2FkIHx8IChyZXMgPT4gcmVzKTtcbiAgICBjb25zdCBvbmVycm9yID0gYWN0aW9uLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpIHx8IHt9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbi5oZWFkZXJzLFxuICAgICAgICAgICAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICBoZWFkZXJzLFxuICAgIH07XG5cbiAgICAvLyBjcmVhdGUgZm9ybWRhdGEgb2JqZWN0XG4gICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBUdXJuIGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyBzbyBubyBtYXR0ZXIgd2hhdCB0aGUgaW5wdXQsIHdlIGNhbiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5XG4gICAgKGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gW3sgbmFtZTogbnVsbCwgZmlsZSB9XSA6IGZpbGUpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBpdGVtLmZpbGUsXG4gICAgICAgICAgICBpdGVtLm5hbWUgPT09IG51bGwgPyBpdGVtLmZpbGUubmFtZSA6IGAke2l0ZW0ubmFtZX0ke2l0ZW0uZmlsZS5uYW1lfWBcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3Qob25kYXRhKGZvcm1EYXRhKSwgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSwgcmVxdWVzdFBhcmFtcyk7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICBsb2FkKGNyZWF0ZVJlc3BvbnNlKCdsb2FkJywgeGhyLnN0YXR1cywgb25sb2FkKHhoci5yZXNwb25zZSksIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT4ge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgIHJldHVybiByZXF1ZXN0O1xufTtcblxuY29uc3QgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24gPSAoYXBpVXJsID0gJycsIGFjdGlvbiwgbmFtZSwgb3B0aW9ucykgPT4ge1xuICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICguLi5wYXJhbXMpID0+IGFjdGlvbihuYW1lLCAuLi5wYXJhbXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gZnVuY3Rpb24gc2lnbmF0dXJlOlxuICh1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSA9PiB7IH1cbiAqL1xuY29uc3QgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24gPSAoYXBpVXJsID0gJycsIGFjdGlvbikgPT4ge1xuICAgIC8vIGlzIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkLCByZXR1cm4gc3R1YiBmdW5jdGlvbiwgaW50ZXJmYWNlIHdpbGwgd29yaywgYnV0IGZpbGUgd29uJ3QgYmUgcmVtb3ZlZFxuICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICByZXR1cm4gKHVuaXF1ZUZpbGVJZCwgbG9hZCkgPT4gbG9hZCgpO1xuICAgIH1cblxuICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgIGNvbnN0IG9ubG9hZCA9IGFjdGlvbi5vbmxvYWQgfHwgKHJlcyA9PiByZXMpO1xuICAgIGNvbnN0IG9uZXJyb3IgPSBhY3Rpb24ub25lcnJvciB8fCAocmVzID0+IG51bGwpO1xuXG4gICAgLy8gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm4gKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgdW5pcXVlRmlsZUlkLFxuICAgICAgICAgICAgYXBpVXJsICsgYWN0aW9uLnVybCxcbiAgICAgICAgICAgIGFjdGlvbiAvLyBjb250YWlucyBtZXRob2QsIGhlYWRlcnMgYW5kIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0aWVzXG4gICAgICAgICk7XG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0geGhyID0+IHtcbiAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG59O1xuXG5jb25zdCBnZXRSYW5kb21OdW1iZXIgPSAobWluID0gMCwgbWF4ID0gMSkgPT4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xuXG5jb25zdCBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSAoXG4gICAgY2IsXG4gICAgZHVyYXRpb24gPSAxMDAwLFxuICAgIG9mZnNldCA9IDAsXG4gICAgdGlja01pbiA9IDI1LFxuICAgIHRpY2tNYXggPSAyNTBcbikgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgICBsZXQgcnVudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgbGV0IGRlbGF5ID0gZ2V0UmFuZG9tTnVtYmVyKHRpY2tNaW4sIHRpY2tNYXgpO1xuXG4gICAgICAgIGlmIChydW50aW1lICsgZGVsYXkgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgZGVsYXkgPSBydW50aW1lICsgZGVsYXkgLSBkdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHByb2dyZXNzID49IDEgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICBjYigxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKHByb2dyZXNzKTtcblxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh0aWNrLCBkZWxheSk7XG4gICAgfTtcblxuICAgIGlmIChkdXJhdGlvbiA+IDApIHRpY2soKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUZpbGVQcm9jZXNzb3IgPSAocHJvY2Vzc0ZuLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgcGVyY2VpdmVkUHJvZ3Jlc3M6IDAsXG4gICAgICAgIHBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcjogbnVsbCxcbiAgICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgcGVyY2VpdmVkRHVyYXRpb246IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICByZXNwb25zZTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IHByb2Nlc3MgPSAoZmlsZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NGbiA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIG5vdCB5ZXQgc3RhcnRlZCB0aGUgcmVhbCBkb3dubG9hZCwgc3RvcCBoZXJlXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgICAgICAvLyBpZiBzdGF0ZS5wcm9ncmVzcyBpcyBudWxsLCB0aGUgc2VydmVyIGRvZXMgbm90IGFsbG93IGNvbXB1dGluZyBwcm9ncmVzcyBhbmQgd2Ugc2hvdyB0aGUgc3Bpbm5lciBpbnN0ZWFkXG4gICAgICAgICAgICBpZiAoc3RhdGUuZHVyYXRpb24gPT09IDAgfHwgc3RhdGUucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBhcGkuZ2V0UHJvZ3Jlc3MoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY29tcGxldGVGbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkLXBlcmNlaXZlZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgICAgYXBpLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBjcmVhdGUgcGVyY2VpdmVkIHBlcmZvcm1hbmNlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIoXG4gICAgICAgICAgICBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBmYWtlIHByb2dyZXNzIGlzIGRvbmUsIGFuZCBhIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSd2ZSBub3QgeWV0IGNhbGxlZCB0aGUgY29tcGxldGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlc3BvbnNlICYmIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxICYmICFzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgICAgICAvLyBmaWxlcyB1cGxvYWRpbmcgYXQgdGhlIGV4YWN0IHNhbWUgc3BlZWRcbiAgICAgICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uID8gZ2V0UmFuZG9tTnVtYmVyKDc1MCwgMTUwMCkgOiAwXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgcmVxdWVzdCBzbyB3ZSBjYW4gYWJvcnQgaXQgbGF0ZXJcbiAgICAgICAgc3RhdGUucmVxdWVzdCA9IHByb2Nlc3NGbihcbiAgICAgICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGZpbGUsXG5cbiAgICAgICAgICAgIC8vIHRoZSBtZXRhZGF0YSB0byBzZW5kIGFsb25nXG4gICAgICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAgICAgLy8gY2FsbGJhY2tzIChsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2ZlcilcbiAgICAgICAgICAgIC8vIGxvYWQgZXhwZWN0cyB0aGUgYm9keSB0byBiZSBhIHNlcnZlciBpZCBpZlxuICAgICAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgICAgICAgLy8gaXQgb3V0c2lkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gaXNPYmplY3QocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgJHtyZXNwb25zZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvZ3Jlc3MgdG8gMSBhcyB3ZSdyZSBub3cgZG9uZVxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBsb2FkIGlzIGRvbmUgbGV0J3Mgc2hhcmUgcmVzdWx0c1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcmVhbGx5IGRvbmVcbiAgICAgICAgICAgICAgICAvLyBpZiBwZXJjZWl2ZWQgcHJvZ3Jlc3MgaXMgMSAoIHdhaXQgZm9yIHBlcmNlaXZlZCBwcm9ncmVzcyB0byBjb21wbGV0ZSApXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvZ3Jlc3MgKCBudWxsIClcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAoYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBlcnJvciBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0eXBlLCBjb2RlLCBib2R5XG4gICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIHVwZGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvdGhlcnMgYWJvdXQgdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgJHtlcnJvcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGFjdHVhbCBwcm9jZXNzaW5nIHByb2dyZXNzXG4gICAgICAgICAgICAoY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGFjdHVhbCBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gY29tcHV0YWJsZSA/IGN1cnJlbnQgLyB0b3RhbCA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBhYm9ydCBkb2VzIG5vdCBleHBlY3QgYSB2YWx1ZVxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyZSB0aGUgYWJvcnQgZXZlbnQgc28gd2UgY2FuIHN3aXRjaCB2aXN1YWxzXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jywgc3RhdGUucmVzcG9uc2UgPyBzdGF0ZS5yZXNwb25zZS5ib2R5IDogbnVsbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaWQgZm9yIHRoaXMgdHJhbnNmZXJcbiAgICAgICAgICAgIHRyYW5zZmVySWQgPT4ge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCd0cmFuc2ZlcicsIHRyYW5zZmVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgICAgLy8gbm8gcmVxdWVzdCBydW5uaW5nLCBjYW4ndCBhYm9ydFxuICAgICAgICBpZiAoIXN0YXRlLnJlcXVlc3QpIHJldHVybjtcblxuICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gYWJvcnQgYWN0dWFsIHJlcXVlc3RcbiAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QuYWJvcnQpIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcblxuICAgICAgICAvLyBpZiBoYXMgcmVzcG9uc2Ugb2JqZWN0LCB3ZSd2ZSBjb21wbGV0ZWQgdGhlIHJlcXVlc3RcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSAwO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gMDtcbiAgICAgICAgc3RhdGUuZHVyYXRpb24gPSAwO1xuICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRQcm9ncmVzcyA9IGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uXG4gICAgICAgID8gKCkgPT4gKHN0YXRlLnByb2dyZXNzID8gTWF0aC5taW4oc3RhdGUucHJvZ3Jlc3MsIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzKSA6IG51bGwpXG4gICAgICAgIDogKCkgPT4gc3RhdGUucHJvZ3Jlc3MgfHwgbnVsbDtcblxuICAgIGNvbnN0IGdldER1cmF0aW9uID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgPyAoKSA9PiBNYXRoLm1pbihzdGF0ZS5kdXJhdGlvbiwgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24pXG4gICAgICAgIDogKCkgPT4gc3RhdGUuZHVyYXRpb247XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIC4uLm9uKCksXG4gICAgICAgIHByb2Nlc3MsIC8vIHN0YXJ0IHByb2Nlc3NpbmcgZmlsZVxuICAgICAgICBhYm9ydCwgLy8gYWJvcnQgYWN0aXZlIHByb2Nlc3MgcmVxdWVzdFxuICAgICAgICBnZXRQcm9ncmVzcyxcbiAgICAgICAgZ2V0RHVyYXRpb24sXG4gICAgICAgIHJlc2V0LFxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gbmFtZSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG5cbmNvbnN0IGNyZWF0ZUZpbGVTdHViID0gc291cmNlID0+IHtcbiAgICBsZXQgZGF0YSA9IFtzb3VyY2UubmFtZSwgc291cmNlLnNpemUsIHNvdXJjZS50eXBlXTtcblxuICAgIC8vIGlzIGJsb2Igb3IgYmFzZTY0LCB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoZSBuYW1lXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IgfHwgaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgZGF0YVswXSA9IHNvdXJjZS5uYW1lIHx8IGdldERhdGVTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgIC8vIGlmIGlzIGJhc2U2NCBkYXRhIHVyaSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIGFuZCB0eXBlXG4gICAgICAgIGRhdGFbMV0gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBkYXRhWzJdID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoc291cmNlKSkge1xuICAgICAgICAvLyB1cmxcbiAgICAgICAgZGF0YVswXSA9IGdldEZpbGVuYW1lRnJvbVVSTChzb3VyY2UpO1xuICAgICAgICBkYXRhWzFdID0gMDtcbiAgICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICAgIHNpemU6IGRhdGFbMV0sXG4gICAgICAgIHR5cGU6IGRhdGFbMl0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGlzRmlsZSA9IHZhbHVlID0+ICEhKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCAodmFsdWUgaW5zdGFuY2VvZiBCbG9iICYmIHZhbHVlLm5hbWUpKTtcblxuY29uc3QgZGVlcENsb25lT2JqZWN0ID0gc3JjID0+IHtcbiAgICBpZiAoIWlzT2JqZWN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzcmMpID8gW10gOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHYgPSBzcmNba2V5XTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2ICYmIGlzT2JqZWN0KHYpID8gZGVlcENsb25lT2JqZWN0KHYpIDogdjtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmNvbnN0IGNyZWF0ZUl0ZW0gPSAob3JpZ2luID0gbnVsbCwgc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGwsIGZpbGUgPSBudWxsKSA9PiB7XG4gICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgY29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaXRlbSBzdGF0ZVxuICAgICAqL1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAvLyBpcyBhcmNoaXZlZFxuICAgICAgICBhcmNoaXZlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gaWYgaXMgZnJvemVuLCBubyBsb25nZXIgZmlyZXMgZXZlbnRzXG4gICAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHZpZXdcbiAgICAgICAgcmVsZWFzZWQ6IGZhbHNlLFxuXG4gICAgICAgIC8vIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICBzb3VyY2U6IG51bGwsXG5cbiAgICAgICAgLy8gZmlsZSBtb2RlbCByZWZlcmVuY2VcbiAgICAgICAgZmlsZSxcblxuICAgICAgICAvLyBpZCBvZiBmaWxlIG9uIHNlcnZlclxuICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuXG4gICAgICAgIC8vIGlkIG9mIGZpbGUgdHJhbnNmZXIgb24gc2VydmVyXG4gICAgICAgIHRyYW5zZmVySWQ6IG51bGwsXG5cbiAgICAgICAgLy8gaXMgYWJvcnRlZFxuICAgICAgICBwcm9jZXNzaW5nQWJvcnRlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gY3VycmVudCBpdGVtIHN0YXR1c1xuICAgICAgICBzdGF0dXM6IHNlcnZlckZpbGVSZWZlcmVuY2UgPyBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgOiBJdGVtU3RhdHVzLklOSVQsXG5cbiAgICAgICAgLy8gYWN0aXZlIHByb2Nlc3Nlc1xuICAgICAgICBhY3RpdmVMb2FkZXI6IG51bGwsXG4gICAgICAgIGFjdGl2ZVByb2Nlc3NvcjogbnVsbCxcbiAgICB9O1xuXG4gICAgLy8gY2FsbGJhY2sgdXNlZCB3aGVuIGFib3J0IHByb2Nlc3NpbmcgaXMgY2FsbGVkIHRvIGxpbmsgYmFjayB0byB0aGUgcmVzb2x2ZSBtZXRob2RcbiAgICBsZXQgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVybmFsbHkgYWRkZWQgaXRlbSBtZXRhZGF0YVxuICAgICAqL1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge307XG5cbiAgICAvLyBpdGVtIGRhdGFcbiAgICBjb25zdCBzZXRTdGF0dXMgPSBzdGF0dXMgPT4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG5cbiAgICAvLyBmaXJlIGV2ZW50IHVubGVzcyB0aGUgaXRlbSBoYXMgYmVlbiBhcmNoaXZlZFxuICAgIGNvbnN0IGZpcmUgPSAoZXZlbnQsIC4uLnBhcmFtcykgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICAgIGFwaS5maXJlKGV2ZW50LCAuLi5wYXJhbXMpO1xuICAgIH07XG5cbiAgICAvLyBmaWxlIGRhdGFcbiAgICBjb25zdCBnZXRGaWxlRXh0ZW5zaW9uID0gKCkgPT4gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgY29uc3QgZ2V0RmlsZVR5cGUgPSAoKSA9PiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgY29uc3QgZ2V0RmlsZVNpemUgPSAoKSA9PiBzdGF0ZS5maWxlLnNpemU7XG4gICAgY29uc3QgZ2V0RmlsZSA9ICgpID0+IHN0YXRlLmZpbGU7XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIGxvYWQgYSBmaWxlXG4gICAgLy9cbiAgICBjb25zdCBsb2FkID0gKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpID0+IHtcbiAgICAgICAgLy8gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIGl0ZW0gc291cmNlXG4gICAgICAgIHN0YXRlLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgICAgYXBpLmZpcmVTeW5jKCdpbml0Jyk7XG5cbiAgICAgICAgLy8gZmlsZSBzdHViIGlzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgICAgIGFwaS5maXJlU3luYygnbG9hZC1za2lwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgYSBzdHViIGZpbGUgb2JqZWN0IHdoaWxlIGxvYWRpbmcgdGhlIGFjdHVhbCBkYXRhXG4gICAgICAgIHN0YXRlLmZpbGUgPSBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpO1xuXG4gICAgICAgIC8vIHN0YXJ0cyBsb2FkaW5nXG4gICAgICAgIGxvYWRlci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtaW5pdCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgICBsb2FkZXIub24oJ21ldGEnLCBtZXRhID0+IHtcbiAgICAgICAgICAgIC8vIHNldCBzaXplIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgc3RhdGUuZmlsZS5zaXplID0gbWV0YS5zaXplO1xuXG4gICAgICAgICAgICAvLyBzZXQgbmFtZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgICAgIHN0YXRlLmZpbGUuZmlsZW5hbWUgPSBtZXRhLmZpbGVuYW1lO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgc291cmNlLCB3ZSBkb25lXG4gICAgICAgICAgICBpZiAobWV0YS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBtZXRhLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgPSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoZSBmaWxlIGlzIG5vdyBsb2FkaW5nIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgICAgIGxvYWRlci5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FESU5HKTtcblxuICAgICAgICAgICAgZmlyZSgnbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYW4gZXJyb3Igd2FzIHRocm93biB3aGlsZSBsb2FkaW5nIHRoZSBmaWxlLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBlcnJvciBzdGF0ZVxuICAgICAgICBsb2FkZXIub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRF9FUlJPUik7XG5cbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXNlciBvciBhbm90aGVyIHByb2Nlc3MgYWJvcnRlZCB0aGUgZmlsZSBsb2FkIChjYW5ub3QgcmV0cnkpXG4gICAgICAgIGxvYWRlci5vbignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZG9uZSBsb2FkaW5nXG4gICAgICAgIGxvYWRlci5vbignbG9hZCcsIGZpbGUgPT4ge1xuICAgICAgICAgICAgLy8gYXMgd2UndmUgbm93IGxvYWRlZCB0aGUgZmlsZSB0aGUgbG9hZGVyIGlzIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc2Z1bGx5XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgKHBvc3NpYmx5KSB0cmFuc2Zvcm1lZCBmaWxlXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGlzRmlsZShyZXN1bHQpID8gcmVzdWx0IDogc3RhdGUuZmlsZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPICYmIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNldCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlLCB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9ubG9hZCBtZXRob2RcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHNlcnZlciBpZCwgbGV0J3MgZ2l2ZSB0aGlzIGZpbGUgdGhlIGZ1bGwgdHJlYXRtZW50XG4gICAgICAgICAgICBvbmxvYWQoZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgbG9hZGVyIHNvdXJjZSBkYXRhXG4gICAgICAgIGxvYWRlci5zZXRTb3VyY2Uoc291cmNlKTtcblxuICAgICAgICAvLyBzZXQgYXMgYWN0aXZlIGxvYWRlclxuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBsb2FkZXI7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc291cmNlIGRhdGFcbiAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmV0cnlMb2FkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5sb2FkKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFib3J0TG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byBwcm9jZXNzIGEgZmlsZVxuICAgIC8vXG4gICAgY29uc3QgcHJvY2VzcyA9IChwcm9jZXNzb3IsIG9ucHJvY2VzcykgPT4ge1xuICAgICAgICAvLyBwcm9jZXNzaW5nIHdhcyBhYm9ydGVkXG4gICAgICAgIGlmIChzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCkge1xuICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBwcm9jZXNzaW5nXG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAgIC8vIHJlc2V0IGFib3J0IGNhbGxiYWNrXG4gICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgaWYgKCEoc3RhdGUuZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICBhcGkub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIHByb2Nlc3NvclxuICAgICAgICBwcm9jZXNzb3Iub24oJ2xvYWQnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWdpc3RlciB0cmFuc2ZlciBpZFxuICAgICAgICBwcm9jZXNzb3Iub24oJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCA9PiB7XG4gICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdGhlIHVwbG9hZFxuICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IHRyYW5zZmVySWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignbG9hZC1wZXJjZWl2ZWQnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIC8vIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXIgdGhlIHVwbG9hZFxuICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWNvbXBsZXRlJywgc2VydmVyRmlsZVJlZmVyZW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXN0YXJ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUik7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWVycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9jZXNzb3Iub24oJ2Fib3J0Jywgc2VydmVyRmlsZVJlZmVyZW5jZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiBmaWxlIHdhcyB1cGxvYWRlZCBidXQgcHJvY2Vzc2luZyB3YXMgY2FuY2VsbGVkIGR1cmluZyBwZXJjZWl2ZWQgcHJvY2Vzc29yIHRpbWUgc3RvcmUgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgLy8gaGFzIHRpbWVvdXQgc28gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCByZW1vdmUgYWN0aW9uXG4gICAgICAgICAgICBpZiAoYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aGVuIHN1Y2Nlc3NmdWxseSB0cmFuc2Zvcm1lZFxuICAgICAgICBjb25zdCBzdWNjZXNzID0gZmlsZSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB3YXMgYXJjaGl2ZWQgaW4gdGhlIG1lYW4gdGltZSwgZG9uJ3QgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFyY2hpdmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZmlsZSFcbiAgICAgICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIHsgLi4ubWV0YWRhdGEgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxuICAgICAgICBjb25zdCBlcnJvciA9IGNvbnNvbGUuZXJyb3I7XG5cbiAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZmlsZVxuICAgICAgICBvbnByb2Nlc3Moc3RhdGUuZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgICAgIC8vIHNldCBhcyBhY3RpdmUgcHJvY2Vzc29yXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdFByb2Nlc3NpbmcgPSAoKSA9PiB7XG4gICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWJvcnRQcm9jZXNzaW5nID0gKCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IuYWJvcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIHJldmVydCBhIHByb2Nlc3NlZCBmaWxlXG4gICAgLy9cbiAgICBjb25zdCByZXZlcnQgPSAocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIGEgY29tcGxldGVkIHVwbG9hZCB3aWxsIGhhdmUgYSBzZXJ2ZXJGaWxlUmVmZXJlbmNlLCBhIGZhaWxlZCBjaHVua2VkIHVwbG9hZCB3aGVyZVxuICAgICAgICAgICAgLy8gZ2V0dGluZyBhIHNlcnZlcklkIHN1Y2NlZWRlZCBidXQgPj0wIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgd2lsbCBoYXZlIHRyYW5zZmVySWQgc2V0XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJUcmFuc2ZlcklkID1cbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlICE9PSBudWxsID8gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA6IHN0YXRlLnRyYW5zZmVySWQ7XG5cbiAgICAgICAgICAgIC8vIGNhbm5vdCByZXZlcnQgd2l0aG91dCBhIHNlcnZlciBpZCBmb3IgdGhpcyBwcm9jZXNzXG4gICAgICAgICAgICBpZiAoc2VydmVyVHJhbnNmZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldmVydCB0aGUgdXBsb2FkIChmaXJlIGFuZCBmb3JnZXQpXG4gICAgICAgICAgICByZXZlcnRGaWxlVXBsb2FkKFxuICAgICAgICAgICAgICAgIHNlcnZlclRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBmaWxlIHNlcnZlciBpZCBhbmQgdHJhbnNmZXIgaWQgYXMgbm93IGl0J3Mgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgZXJyb3Igc3RhdGUgd2hlbiByZXZlcnRpbmcgaXMgb3B0aW9uYWwsIGl0IHdpbGwgYWx3YXlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb2ggbm8gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQtZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBmaXJlIGV2ZW50XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlZCBtZXRob2RzXG4gICAgY29uc3Qgc2V0TWV0YWRhdGEgPSAoa2V5LCB2YWx1ZSwgc2lsZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGtleXNbMF07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgICBsZXQgZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IChkYXRhID0gZGF0YVtrZXldKSk7XG5cbiAgICAgICAgLy8gY29tcGFyZSBvbGQgdmFsdWUgYWdhaW5zdCBuZXcgdmFsdWUsIGlmIHRoZXkncmUgdGhlIHNhbWUsIHdlJ3JlIG5vdCB1cGRhdGluZ1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZVxuICAgICAgICBkYXRhW2xhc3RdID0gdmFsdWU7XG5cbiAgICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgICAgZmlyZSgnbWV0YWRhdGEtdXBkYXRlJywge1xuICAgICAgICAgICAga2V5OiByb290LFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhW3Jvb3RdLFxuICAgICAgICAgICAgc2lsZW50LFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0TWV0YWRhdGEgPSBrZXkgPT4gZGVlcENsb25lT2JqZWN0KGtleSA/IG1ldGFkYXRhW2tleV0gOiBtZXRhZGF0YSk7XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIGlkOiB7IGdldDogKCkgPT4gaWQgfSxcbiAgICAgICAgb3JpZ2luOiB7IGdldDogKCkgPT4gb3JpZ2luLCBzZXQ6IHZhbHVlID0+IChvcmlnaW4gPSB2YWx1ZSkgfSxcbiAgICAgICAgc2VydmVySWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlIH0sXG4gICAgICAgIHRyYW5zZmVySWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS50cmFuc2ZlcklkIH0sXG4gICAgICAgIHN0YXR1czogeyBnZXQ6ICgpID0+IHN0YXRlLnN0YXR1cyB9LFxuICAgICAgICBmaWxlbmFtZTogeyBnZXQ6ICgpID0+IHN0YXRlLmZpbGUubmFtZSB9LFxuICAgICAgICBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb246IHsgZ2V0OiAoKSA9PiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oc3RhdGUuZmlsZS5uYW1lKSB9LFxuICAgICAgICBmaWxlRXh0ZW5zaW9uOiB7IGdldDogZ2V0RmlsZUV4dGVuc2lvbiB9LFxuICAgICAgICBmaWxlVHlwZTogeyBnZXQ6IGdldEZpbGVUeXBlIH0sXG4gICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgZmlsZTogeyBnZXQ6IGdldEZpbGUgfSxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB7IGdldDogKCkgPT4gc3RhdGUuZmlsZS5fcmVsYXRpdmVQYXRoIH0sXG5cbiAgICAgICAgc291cmNlOiB7IGdldDogKCkgPT4gc3RhdGUuc291cmNlIH0sXG5cbiAgICAgICAgZ2V0TWV0YWRhdGEsXG4gICAgICAgIHNldE1ldGFkYXRhOiAoa2V5LCB2YWx1ZSwgc2lsZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBrZXk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4dGVuZDogKG5hbWUsIGhhbmRsZXIpID0+IChpdGVtQVBJW25hbWVdID0gaGFuZGxlciksXG5cbiAgICAgICAgYWJvcnRMb2FkLFxuICAgICAgICByZXRyeUxvYWQsXG4gICAgICAgIHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICBhYm9ydFByb2Nlc3NpbmcsXG5cbiAgICAgICAgbG9hZCxcbiAgICAgICAgcHJvY2VzcyxcbiAgICAgICAgcmV2ZXJ0LFxuXG4gICAgICAgIC4uLm9uKCksXG5cbiAgICAgICAgZnJlZXplOiAoKSA9PiAoc3RhdGUuZnJvemVuID0gdHJ1ZSksXG5cbiAgICAgICAgcmVsZWFzZTogKCkgPT4gKHN0YXRlLnJlbGVhc2VkID0gdHJ1ZSksXG4gICAgICAgIHJlbGVhc2VkOiB7IGdldDogKCkgPT4gc3RhdGUucmVsZWFzZWQgfSxcblxuICAgICAgICBhcmNoaXZlOiAoKSA9PiAoc3RhdGUuYXJjaGl2ZWQgPSB0cnVlKSxcbiAgICAgICAgYXJjaGl2ZWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5hcmNoaXZlZCB9LFxuXG4gICAgICAgIC8vIHJlcGxhY2Ugc291cmNlIGFuZCBmaWxlIG9iamVjdFxuICAgICAgICBzZXRGaWxlOiBmaWxlID0+IChzdGF0ZS5maWxlID0gZmlsZSksXG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgY29uc3QgaXRlbUFQSSA9IGNyZWF0ZU9iamVjdChhcGkpO1xuXG4gICAgcmV0dXJuIGl0ZW1BUEk7XG59O1xuXG5jb25zdCBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gKGl0ZW1zLCBxdWVyeSkgPT4ge1xuICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIGludmFsaWQgcXVlcmllc1xuICAgIGlmICghaXNTdHJpbmcocXVlcnkpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaXRlbSBieSBpZCAob3IgLTEgaWYgbm90IGZvdW5kKVxuICAgIHJldHVybiBpdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlkID09PSBxdWVyeSk7XG59O1xuXG5jb25zdCBnZXRJdGVtQnlJZCA9IChpdGVtcywgaXRlbUlkKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBpdGVtSWQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXNbaW5kZXhdIHx8IG51bGw7XG59O1xuXG5jb25zdCBmZXRjaEJsb2IgPSAodXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICB9KTtcblxuICAgIHJlcXVlc3Qub25sb2FkID0geGhyID0+IHtcbiAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgIGxvYWQoY3JlYXRlUmVzcG9uc2UoJ2xvYWQnLCB4aHIuc3RhdHVzLCBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksIGhlYWRlcnMpKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgZXJyb3IoY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IHhociA9PiB7XG4gICAgICAgIGhlYWRlcnMoY3JlYXRlUmVzcG9uc2UoJ2hlYWRlcnMnLCB4aHIuc3RhdHVzLCBudWxsLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5jb25zdCBnZXREb21haW5Gcm9tVVJMID0gdXJsID0+IHtcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgdXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmxcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2I6JywgJycpXG4gICAgICAgIC5yZXBsYWNlKC8oW2Etel0pPzpcXC9cXC8vLCAnJDEnKVxuICAgICAgICAuc3BsaXQoJy8nKVswXTtcbn07XG5cbmNvbnN0IGlzRXh0ZXJuYWxVUkwgPSB1cmwgPT5cbiAgICAodXJsLmluZGV4T2YoJzonKSA+IC0xIHx8IHVybC5pbmRleE9mKCcvLycpID4gLTEpICYmXG4gICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpO1xuXG5jb25zdCBkeW5hbWljTGFiZWwgPSBsYWJlbCA9PiAoLi4ucGFyYW1zKSA9PiAoaXNGdW5jdGlvbihsYWJlbCkgPyBsYWJlbCguLi5wYXJhbXMpIDogbGFiZWwpO1xuXG5jb25zdCBpc01vY2tJdGVtID0gaXRlbSA9PiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG5cbmNvbnN0IGxpc3RVcGRhdGVkID0gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGNsZWFyVGltZW91dChzdGF0ZS5saXN0VXBkYXRlVGltZW91dCk7XG4gICAgc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTVMnLCB7IGl0ZW1zOiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykgfSk7XG4gICAgfSwgMCk7XG59O1xuXG5jb25zdCBvcHRpb25hbFByb21pc2UgPSAoZm4sIC4uLnBhcmFtcykgPT5cbiAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5wYXJhbXMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuY29uc3Qgc29ydEl0ZW1zID0gKHN0YXRlLCBjb21wYXJlKSA9PiB7XG4gICAgc3RhdGUuaXRlbXMuc29ydCgoYSwgYikgPT4gY29tcGFyZShjcmVhdGVJdGVtQVBJKGEpLCBjcmVhdGVJdGVtQVBJKGIpKSk7XG59O1xuXG4vLyByZXR1cm5zIGl0ZW0gYmFzZWQgb24gc3RhdGVcbmNvbnN0IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlID0gKHN0YXRlLCBpdGVtSGFuZGxlcikgPT4gKHtcbiAgICBxdWVyeSxcbiAgICBzdWNjZXNzID0gKCkgPT4ge30sXG4gICAgZmFpbHVyZSA9ICgpID0+IHt9LFxuICAgIC4uLm9wdGlvbnNcbn0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgICBmYWlsdXJlKHtcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW1IYW5kbGVyKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMgfHwge30pO1xufTtcblxuY29uc3QgYWN0aW9ucyA9IChkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSA9PiAoe1xuICAgIC8qKlxuICAgICAqIEFib3J0cyBhbGwgb25nb2luZyBwcm9jZXNzZXNcbiAgICAgKi9cbiAgICBBQk9SVF9BTEw6ICgpID0+IHtcbiAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmZyZWV6ZSgpO1xuICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGluaXRpYWwgZmlsZXNcbiAgICAgKi9cbiAgICBESURfU0VUX0ZJTEVTOiAoeyB2YWx1ZSA9IFtdIH0pID0+IHtcbiAgICAgICAgLy8gbWFwIHZhbHVlcyB0byBmaWxlIG9iamVjdHNcbiAgICAgICAgY29uc3QgZmlsZXMgPSB2YWx1ZS5tYXAoZmlsZSA9PiAoe1xuICAgICAgICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSA/IGZpbGUuc291cmNlIDogZmlsZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGZpbGUub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBmaWxlcywgaWYgZmlsZSBpcyBpbiBsaXN0LCBsZWF2ZSBpdCBiZSwgaWYgbm90LCByZW1vdmVcbiAgICAgICAgLy8gdGVzdCBpZiBpdGVtcyBzaG91bGQgYmUgbW92ZWRcbiAgICAgICAgbGV0IGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGFjdGl2ZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBpdGVtIG5vdCBpcyBpbiBuZXcgdmFsdWUsIHJlbW92ZVxuICAgICAgICAgICAgaWYgKCFmaWxlcy5maW5kKGZpbGUgPT4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGUpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbSwgcmVtb3ZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBmaWxlc1xuICAgICAgICBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGZpbGUgaXMgYWxyZWFkeSBpbiBsaXN0XG4gICAgICAgICAgICBpZiAoYWN0aXZlSXRlbXMuZmluZChpdGVtID0+IGl0ZW0uc291cmNlID09PSBmaWxlLnNvdXJjZSB8fCBpdGVtLmZpbGUgPT09IGZpbGUuc291cmNlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG5vdCBpbiBsaXN0LCBhZGRcbiAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5OT05FLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6ICh7IGlkLCBhY3Rpb24sIGNoYW5nZSB9KSA9PiB7XG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChjaGFuZ2Uuc2lsZW50KSByZXR1cm47XG5cbiAgICAgICAgLy8gaWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGNsb3NlIHN1Y2Nlc3Npb24gd2UgY29tYmluZWQgYWxsIGNhbGxzIHRvZ2V0aGVyIHRvIHNhdmUgcmVzb3VyY2VzXG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5pdGVtVXBkYXRlVGltZW91dCk7XG4gICAgICAgIHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgLy8gb25seSByZXZlcnQgYW5kIGF0dGVtcHQgdG8gdXBsb2FkIHdoZW4gd2UncmUgdXBsb2FkaW5nIHRvIGEgc2VydmVyXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KCdJU19BU1lOQycpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIHVwZGF0ZSB0aGUgb3V0cHV0IGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgfSkudGhlbihzaG91bGRQcmVwYXJlT3V0cHV0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlUHJlcGFyZUZpbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRQcmVwYXJlT3V0cHV0KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkLCBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpcyBsb2NhbCBpdGVtIHdlIG5lZWQgdG8gZW5hYmxlIHVwbG9hZCBidXR0b24gc28gY2hhbmdlIGNhbiBiZSBwcm9wYWdhdGVkIHRvIHNlcnZlclxuICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBzY2VuYXJpb3NcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBwdXNoIHRoaXMgZm9yd2FyZCBhIGJpdCBzbyB0aGUgaW50ZXJmYWNlIGlzIHVwZGF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0sIDMyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJldmVydCA9IGRvVXBsb2FkID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6ICgpID0+IHt9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgYWJvcnQgPSBkb1VwbG9hZCA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogKCkgPT4ge30pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIHJlLXVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJ0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRseSB1cGxvYWRpbmcsIGNhbmNlbCB1cGxvYWRcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfSxcblxuICAgIE1PVkVfSVRFTTogKHsgcXVlcnksIGluZGV4IH0pID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBzdGF0ZS5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgc3RhdGUuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5zcGxpY2UoY3VycmVudEluZGV4LCAxKVswXSk7XG4gICAgfSxcblxuICAgIFNPUlQ6ICh7IGNvbXBhcmUgfSkgPT4ge1xuICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpO1xuICAgICAgICBkaXNwYXRjaCgnRElEX1NPUlRfSVRFTVMnLCB7XG4gICAgICAgICAgICBpdGVtczogcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIEFERF9JVEVNUzogKHsgaXRlbXMsIGluZGV4LCBpbnRlcmFjdGlvbk1ldGhvZCwgc3VjY2VzcyA9ICgpID0+IHt9LCBmYWlsdXJlID0gKCkgPT4ge30gfSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCB0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSBxdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAwIDogdG90YWxJdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlnbm9yZWRGaWxlcyA9IHF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkRmlsZSA9IHNvdXJjZSA9PlxuICAgICAgICAgICAgaXNGaWxlKHNvdXJjZSkgPyAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpIDogIWlzRW1wdHkoc291cmNlKTtcbiAgICAgICAgY29uc3QgdmFsaWRJdGVtcyA9IGl0ZW1zLmZpbHRlcihpc1ZhbGlkRmlsZSk7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB2YWxpZEl0ZW1zLm1hcChcbiAgICAgICAgICAgIHNvdXJjZSA9PlxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5zb3VyY2UgfHwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNvdXJjZS5vcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgIC5jYXRjaChmYWlsdXJlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAqL1xuICAgIEFERF9JVEVNOiAoe1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICBzdWNjZXNzID0gKCkgPT4ge30sXG4gICAgICAgIGZhaWx1cmUgPSAoKSA9PiB7fSxcbiAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgIH0pID0+IHtcbiAgICAgICAgLy8gaWYgbm8gc291cmNlIHN1cHBsaWVkXG4gICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnTm8gc291cmNlJyksXG4gICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIGZpbGUgaXRlbXMsIHVzZWQgdG8gZmlsdGVyIGRyb3BwZWQgZGlyZWN0b3J5IGNvbnRlbnRzXG4gICAgICAgIGlmIChpc0ZpbGUoc291cmNlKSAmJiBzdGF0ZS5vcHRpb25zLmlnbm9yZWRGaWxlcy5pbmNsdWRlcyhzb3VyY2UubmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVzdCBpZiB0aGVyZSdzIHN0aWxsIHJvb20gaW4gdGhlIGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgaWYgKCFoYXNSb29tRm9ySXRlbShzdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlIGFsbG93ZWQsIHdlIGNhbid0IHJlcGxhY2VcbiAgICAgICAgICAgIC8vIG9yIGlmIG9ubHkgYSBzaW5nbGUgaXRlbSBpcyBhbGxvd2VkIGJ1dCB3ZSdyZSBub3QgYWxsb3dlZCB0byByZXBsYWNlIGl0IHdlIGV4aXRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgfHxcbiAgICAgICAgICAgICAgICAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSAmJiAhc3RhdGUub3B0aW9ucy5hbGxvd1JlcGxhY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3IsIGZpbGU6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldCdzIHJlcGxhY2UgdGhlIGl0ZW1cbiAgICAgICAgICAgIC8vIGlkIG9mIGZpcnN0IGl0ZW0gd2UncmUgYWJvdXQgdG8gcmVtb3ZlXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpWzBdO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgYmVlbiBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNlcnZlciBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JjZVJldmVydCA9IHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZXZlcnRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGFkZCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHt9KTsgLy8gbm8gbmVlZCB0byBoYW5kbGUgdGhpcyBjYXRjaCBzdGF0ZSBmb3Igbm93XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZpcnN0IGl0ZW0gYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzIGl0ZW1cbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVyZSBkaWQgdGhlIGZpbGUgb3JpZ2luYXRlXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09ICdsb2NhbCdcbiAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMudHlwZSA9PT0gJ2xpbWJvJ1xuICAgICAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MSU1CT1xuICAgICAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYmxhbmsgaXRlbVxuICAgICAgICBjb25zdCBpdGVtID0gY3JlYXRlSXRlbShcbiAgICAgICAgICAgIC8vIHdoZXJlIGRpZCB0aGlzIGZpbGUgY29tZSBmcm9tXG4gICAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAgIC8vIGFuIGlucHV0IGZpbGUgbmV2ZXIgaGFzIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuXG4gICAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgb3B0aW9ucy5maWxlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbWV0YSBkYXRhXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMubWV0YWRhdGEgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoa2V5LCBvcHRpb25zLm1ldGFkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0RJRF9DUkVBVEVfSVRFTScsIGl0ZW0sIHsgcXVlcnksIGRpc3BhdGNoIH0pO1xuXG4gICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgY29uc3QgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuXG4gICAgICAgIC8vIGFkanVzdCBpbmRleCBpZiBpcyBub3QgYWxsb3dlZCB0byBwaWNrIGxvY2F0aW9uXG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tKSB7XG4gICAgICAgICAgICBpbmRleCA9IGl0ZW1JbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAtMSA6IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBpdGVtIHRvIGxpc3RcbiAgICAgICAgaW5zZXJ0SXRlbShzdGF0ZS5pdGVtcywgaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICBpZiAoaXNGdW5jdGlvbihpdGVtSW5zZXJ0TG9jYXRpb24pICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGEgcXVpY2sgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIGlkXG4gICAgICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcblxuICAgICAgICAvLyBvYnNlcnZlIGl0ZW0gZXZlbnRzXG4gICAgICAgIGl0ZW0ub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0lOSVRfSVRFTScsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtaW5pdCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9MT0FEJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1tZXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUycsIHsgaWQsIHByb2dyZXNzIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShlcnJvcik7XG5cbiAgICAgICAgICAgIC8vIGlzIGNsaWVudCBlcnJvciwgbm8gd2F5IHRvIHJlY292ZXJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID49IDQwMCAmJiBlcnJvci5jb2RlIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBgJHtlcnJvci5jb2RlfSAoJHtlcnJvci5ib2R5fSlgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0IHRoZSBmaWxlIHNvIGNhbiBiZSBkZWFsdCB3aXRoIHRocm91Z2ggQVBJXG4gICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaXMgcG9zc2libGUgc2VydmVyIGVycm9yLCBzbyBtaWdodCBiZSBwb3NzaWJsZSB0byByZXRyeVxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0xPQURfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLWZpbGUtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLnN0YXR1cywgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1hYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXNraXAnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNGaWxlKGl0ZW0uZmlsZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEFEQVRBJywgeyBpZCwgY2hhbmdlIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoKCdDT01QTEVURV9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQWRkID0gc2hvdWxkQWRkID0+IHtcbiAgICAgICAgICAgICAgICAvLyBubyBzaG91bGQgbm90IGFkZCB0aGlzIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ21ldGFkYXRhLXVwZGF0ZScsIGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkLCBjaGFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBkZWNpZGUgaWYgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gbWVhbnMgd2UnbGwgZG8gdGhpcyBhbmQgd2FpdCBmb3IgaWRsZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7IGl0ZW0sIHF1ZXJ5IH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlUHJlcGFyZUZpbGUgPSBxdWVyeSgnR0VUX0JFRk9SRV9QUkVQQVJFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZGxlIHN0YXRlIGFuZCB0aGVuIHJ1biBQUkVQQVJFX09VVFBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZCwgZmlsZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpdGVtIGxvYWRlZCwgYWxsb3cgcGx1Z2lucyB0b1xuICAgICAgICAgICAgLy8gLSByZWFkIGRhdGEgKHF1aWNrbHkpXG4gICAgICAgICAgICAvLyAtIGFkZCBtZXRhZGF0YVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignRElEX0xPQURfSVRFTScsIGl0ZW0sIHsgcXVlcnksIGRpc3BhdGNoIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfQUREX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFkZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgIWUuZXJyb3IgfHwgIWUuc3RhdHVzKSByZXR1cm4gaGFuZGxlQWRkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3Mtc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MnLCB7IGlkLCBwcm9ncmVzcyB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1lcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZCwgdmFsdWU6IHNlcnZlckZpbGVSZWZlcmVuY2UgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZCB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZCwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9BRERfSVRFTScsIHsgaWQsIGluZGV4LCBpbnRlcmFjdGlvbk1ldGhvZCB9KTtcblxuICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICBjb25zdCB7IHVybCwgbG9hZCwgcmVzdG9yZSwgZmV0Y2ggfSA9IHN0YXRlLm9wdGlvbnMuc2VydmVyIHx8IHt9O1xuXG4gICAgICAgIGl0ZW0ubG9hZChcbiAgICAgICAgICAgIHNvdXJjZSxcblxuICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgICAgY3JlYXRlRmlsZUxvYWRlcihcbiAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVRcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyByZW1vdGUgdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyB0cnkgdG8gZmV0Y2ggdXJsXG4gICAgICAgICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIHJlc3RvcmUpIC8vIGxpbWJvXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBsb2FkZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIGZpbHRlcnNcbiAgICAgICAgICAgIChmaWxlLCBzdWNjZXNzLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGxldCdzIHByb2Nlc3MgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQ6ICh7IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgPSAoKSA9PiB7fSB9KSA9PiB7XG4gICAgICAgIC8vIGVycm9yIHJlc3BvbnNlIGlmIGl0ZW0gYXJjaGl2ZWRcbiAgICAgICAgY29uc3QgZXJyID0ge1xuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIHdhaXRpbmcgdG8gYmUgcHJlcGFyZWRcbiAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgLy8gYWxsb3cgcGx1Z2lucyB0byBhbHRlciB0aGUgZmlsZSBkYXRhXG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgaXRlbS5maWxlLCB7IHF1ZXJ5LCBpdGVtIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7IHF1ZXJ5LCBpdGVtIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgQ09NUExFVEVfTE9BRF9JVEVNOiAoeyBpdGVtLCBkYXRhIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWNjZXNzLCBzb3VyY2UgfSA9IGRhdGE7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIGNvbnN0IGl0ZW1JbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCBpbnRlcmZhY2Uga25vdyB0aGUgaXRlbSBoYXMgbG9hZGVkXG4gICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaXRlbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkIGFuZCBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gbGlzdCBvZiBpdGVtcyBzbyBjYW4gbm93IGJlIHNhZmVseSByZXR1cm5lZCBmb3IgdXNlXG4gICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIHNlcnZlciBmaWxlIHdlIG5lZWQgdG8gc2hvdyBhIGRpZmZlcmVudCBzdGF0ZVxuICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9MT0NBTF9JVEVNJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGEgdGVtcCBzZXJ2ZXIgZmlsZSB3ZSBwcmV2ZW50IGFzeW5jIHVwbG9hZCBjYWxsIGhlcmUgKGFzIHRoZSBmaWxlIGlzIGFscmVhZHkgb24gdGhlIHNlcnZlcilcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzb3VyY2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0uc2VydmVySWQgfHwgc291cmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZCB3ZSBhcmUgYWxsb3dlZCB0byB1cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHksIGxldHMgZG8gaXRcbiAgICAgICAgaWYgKHF1ZXJ5KCdJU19BU1lOQycpICYmIHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgLy8gdHJ5IGxvYWRpbmcgdGhlIHNvdXJjZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIGl0ZW0ucmV0cnlMb2FkKCk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX0lURU1fUFJFUEFSRTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIChpdGVtLCBzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIChpdGVtLCBzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIC8vIGNhbm5vdCBiZSBxdWV1ZWQgKG9yIGlzIGFscmVhZHkgcXVldWVkKVxuICAgICAgICBjb25zdCBpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nID1cbiAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSB8fFxuICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyB3ZW50IHdyb25nIGVhcmxpZXJcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1I7XG5cbiAgICAgICAgLy8gbm90IHJlYWR5IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICBpZiAoIWl0ZW1DYW5CZVF1ZXVlZEZvclByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NOb3cgPSAoKSA9PlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiAoZG9jdW1lbnQuaGlkZGVuID8gcHJvY2Vzc05vdygpIDogc2V0VGltZW91dChwcm9jZXNzTm93LCAzMikpO1xuXG4gICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRvbmUgcHJvY2Vzc2luZyBvciB0cmllZCB0byByZXZlcnQgYnV0IGRpZG4ndCB3b3JrLCB0cnkgYWdhaW5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7IC8vIGRvbid0IGNvbnRpbnVlIHdpdGggcHJvY2Vzc2luZyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHJlYWR5IHF1ZXVlZCBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpIHJldHVybjtcblxuICAgICAgICBpdGVtLnJlcXVlc3RQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG5cbiAgICAgICAgZGlzcGF0Y2goJ1BST0NFU1NfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgfSwgdHJ1ZSk7XG4gICAgfSksXG5cbiAgICBQUk9DRVNTX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCAoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXhQYXJhbGxlbFVwbG9hZHMgPSBxdWVyeSgnR0VUX01BWF9QQVJBTExFTF9VUExPQURTJyk7XG4gICAgICAgIGNvbnN0IHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykubGVuZ3RoO1xuXG4gICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgICAgLy8gcXVldWUgZm9yIGxhdGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc3RvcCBpdCFcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdhcyBub3QgcXVldWVkIG9yIGlzIGFscmVhZHkgcHJvY2Vzc2luZyBleGl0IGhlcmVcbiAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcm9jZXNzTmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWV1ZCBpdGVtc1xuICAgICAgICAgICAgY29uc3QgcXVldWVFbnRyeSA9IHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBubyBpdGVtcyBsZWZ0XG4gICAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gZ2V0IGl0ZW0gcmVmZXJlbmNlXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdWNjZXNzLCBmYWlsdXJlIH0gPSBxdWV1ZUVudHJ5O1xuICAgICAgICAgICAgY29uc3QgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gd2FzIGFyY2hpdmVkIHdoaWxlIGluIHF1ZXVlLCBqdW1wIHRvIG5leHRcbiAgICAgICAgICAgIGlmICghaXRlbVJlZmVyZW5jZSB8fCBpdGVtUmVmZXJlbmNlLmFyY2hpdmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWVkIGl0ZW1cbiAgICAgICAgICAgIGRpc3BhdGNoKCdQUk9DRVNTX0lURU0nLCB7IHF1ZXJ5OiBpZCwgc3VjY2VzcywgZmFpbHVyZSB9LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3ZSBkb25lIGZ1bmN0aW9uXG4gICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWNvbXBsZXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBsb2NhbCwgYW5kIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nLCB0cmlnZ2VyIHJlbW92ZSBvZiBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gYXMgcmV2ZXJ0IHdpbGwgcmVtb3ZlIGZpbGUgZnJvbSBsaXN0XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSBzdGF0ZS5vcHRpb25zLnNlcnZlcjtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbnRVcGxvYWQgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgICBpZiAoaW5zdGFudFVwbG9hZCAmJiBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJiBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZW1vdmUoaXRlbS5zb3VyY2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgaXRlbXMgcHJvY2Vzc2VkPyBObyBlcnJvcnM/XG4gICAgICAgICAgICBjb25zdCBhbGxJdGVtc1Byb2Nlc3NlZCA9XG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpLmxlbmd0aCA9PT1cbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2UgZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCBmaWxlIHByb2Nlc3NpbmdcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICAgIGl0ZW0ucHJvY2VzcyhcbiAgICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24ob3B0aW9ucy5zZXJ2ZXIudXJsLCBvcHRpb25zLnNlcnZlci5wcm9jZXNzLCBvcHRpb25zLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtUcmFuc2ZlcklkOiBpdGVtLnRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rU2VydmVyOiBvcHRpb25zLnNlcnZlci5wYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtVcGxvYWRzOiBvcHRpb25zLmNodW5rVXBsb2FkcyxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtGb3JjZTogb3B0aW9ucy5jaHVua0ZvcmNlLFxuICAgICAgICAgICAgICAgICAgICBjaHVua1NpemU6IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBjaHVua1JldHJ5RGVsYXlzOiBvcHRpb25zLmNodW5rUmV0cnlEZWxheXMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjogcXVlcnkoJ0dFVF9BTExPV19NSU5JTVVNX1VQTE9BRF9EVVJBVElPTicpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgICAoZmlsZSwgc3VjY2VzcywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdQUkVQQVJFX09VVFBVVCcsIGZpbGUsIHsgcXVlcnksIGl0ZW0gfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaXRlbS5pZCwgZmlsZSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KSxcblxuICAgIFJFVFJZX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgIH0pLFxuXG4gICAgUkVRVUVTVF9SRU1PVkVfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihzaG91bGRSZW1vdmUgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSxcblxuICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBpdGVtLnJlbGVhc2UoKTtcbiAgICB9KSxcblxuICAgIFJFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRnJvbVZpZXcgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgaWQgcmVmZXJlbmNlXG4gICAgICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgIC8vIGFyY2hpdmUgdGhlIGl0ZW0sIHRoaXMgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgIGdldEl0ZW1CeUlkKHN0YXRlLml0ZW1zLCBpZCkuYXJjaGl2ZSgpO1xuXG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSB2aWV3IHRoZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVNT1ZFX0lURU0nLCB7IGVycm9yOiBudWxsLCBpZCwgaXRlbSB9KTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSBsaXN0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgZmlsZSBhbmQgdGhlIGBzZXJ2ZXIucmVtb3ZlYCBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkLFxuICAgICAgICAvLyBzZW5kIHNvdXJjZSB0aGVyZSBzbyBkZXYgY2FuIHJlbW92ZSBmaWxlIGZyb20gc2VydmVyXG4gICAgICAgIGNvbnN0IHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgc2VydmVyICYmXG4gICAgICAgICAgICBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpICYmXG4gICAgICAgICAgICBvcHRpb25zLnJlbW92ZSAhPT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUkVNT1ZFJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgICAgICBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAoKSA9PiByZW1vdmVGcm9tVmlldygpLFxuICAgICAgICAgICAgICAgIHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUmVtb3ZlRXJyb3IpKHN0YXR1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBpcyByZXF1ZXN0aW5nIHJldmVydCBhbmQgY2FuIHJldmVydCBuZWVkIHRvIGNhbGwgcmV2ZXJ0IGhhbmRsZXIgKG5vdCBjYWxsaW5nIHJlcXVlc3RfIGJlY2F1c2UgdGhhdCB3b3VsZCBhbHNvIHRyaWdnZXIgYmVmb3JlUmVtb3ZlSG9vaylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5yZXZlcnQgJiYgaXRlbS5vcmlnaW4gIT09IEZpbGVPcmlnaW4uTE9DQUwgJiYgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBpZiBjaHVua2VkIHVwbG9hZHMgYXJlIGVuYWJsZWQgYW5kIHdlJ3JlIHVwbG9hZGluZyBpbiBjaHVua3MgZm9yIHRoaXMgc3BlY2lmaWMgZmlsZVxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBmaWxlIGlzbid0IGJpZyBlbm91Z2ggZm9yIGNodW5rZWQgdXBsb2FkcyBidXQgY2h1bmtGb3JjZSBpcyBzZXQgdGhlbiBjYWxsXG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IGJlZm9yZSByZW1vdmluZyBmcm9tIHRoZSB2aWV3Li4uXG4gICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIGl0ZW0uZmlsZS5zaXplID4gc3RhdGUub3B0aW9ucy5jaHVua1NpemUpIHx8XG4gICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIHN0YXRlLm9wdGlvbnMuY2h1bmtGb3JjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgICByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBBQk9SVF9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICB9KSxcblxuICAgIEFCT1JUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICAvLyB0ZXN0IGlmIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgIGlmIChpdGVtLnNlcnZlcklkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhYm9ydFxuICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIC8vIG5vdCBpbnN0YW50IHVwbG9hZGluZywgcmV2ZXJ0IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSdyZSBpbnN0YW50IHVwbG9hZGluZyB0aGUgZmlsZSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBpZiB3ZSByZXZlcnQsXG4gICAgICAgIC8vIHNvIGlmIGEgYmVmb3JlIHJlbW92ZSBmaWxlIGhvb2sgaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIHJ1biBpdCBub3dcbiAgICAgICAgY29uc3QgaGFuZGxlUmV2ZXJ0ID0gc2hvdWxkUmV2ZXJ0ID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZm4gPSBxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFJlbW92ZVJlc3VsdCA9IGZuKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHJlcXVlc3RSZW1vdmVSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcXVlc3RSZW1vdmVSZXN1bHQudGhlbihoYW5kbGVSZXZlcnQpO1xuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBSRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkIHx8IGlzTW9ja0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xuICAgIH0pLFxuXG4gICAgU0VUX09QVElPTlM6ICh7IG9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAvLyBnZXQgYWxsIGtleXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcblxuICAgICAgICAvLyBnZXQgcHJpb3JpdGl6ZWQga2V5ZWQgdG8gaW5jbHVkZSAocmVtb3ZlIG9uY2Ugbm90IGluIG9wdGlvbnMgb2JqZWN0KVxuICAgICAgICBjb25zdCBwcmlvcml0aXplZE9wdGlvbktleXMgPSBQcmlvcml0aXplZE9wdGlvbnMuZmlsdGVyKGtleSA9PiBvcHRpb25LZXlzLmluY2x1ZGVzKGtleSkpO1xuXG4gICAgICAgIC8vIG9yZGVyIHRoZSBrZXlzLCBwcmlvcml0aXplZCBmaXJzdCwgdGhlbiByZXN0XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPcHRpb25LZXlzID0gW1xuICAgICAgICAgICAgLy8gYWRkIHByaW9yaXRpemVkIGZpcnN0IGlmIHBhc3NlZCB0byBvcHRpb25zLCBlbHNlIHJlbW92ZVxuICAgICAgICAgICAgLi4ucHJpb3JpdGl6ZWRPcHRpb25LZXlzLFxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBrZXlzXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoa2V5ID0+ICFwcmlvcml0aXplZE9wdGlvbktleXMuaW5jbHVkZXMoa2V5KSksXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gZGlzcGF0Y2ggc2V0IGV2ZW50IGZvciBlYWNoIG9wdGlvblxuICAgICAgICBvcmRlcmVkT3B0aW9uS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaChgU0VUXyR7ZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKX1gLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNba2V5XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IFByaW9yaXRpemVkT3B0aW9ucyA9IFtcbiAgICAnc2VydmVyJywgLy8gbXVzdCBiZSBwcm9jZXNzZWQgYmVmb3JlIFwiZmlsZXNcIlxuXTtcblxuY29uc3QgZm9ybWF0RmlsZW5hbWUgPSBuYW1lID0+IG5hbWU7XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnQkMSA9IHRhZ05hbWUgPT4ge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufTtcblxuY29uc3QgdGV4dCA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGxldCB0ZXh0Tm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgfVxufTtcblxuY29uc3QgcG9sYXJUb0NhcnRlc2lhbiA9IChjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSA9PiB7XG4gICAgY29uc3QgYW5nbGVJblJhZGlhbnMgPSAoKChhbmdsZUluRGVncmVlcyAlIDM2MCkgLSA5MCkgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyksXG4gICAgICAgIHk6IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyksXG4gICAgfTtcbn07XG5cbmNvbnN0IGRlc2NyaWJlQXJjID0gKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFyY1N3ZWVwKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBwb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gWydNJywgc3RhcnQueCwgc3RhcnQueSwgJ0EnLCByYWRpdXMsIHJhZGl1cywgMCwgYXJjU3dlZXAsIDAsIGVuZC54LCBlbmQueV0uam9pbignICcpO1xufTtcblxuY29uc3QgcGVyY2VudGFnZUFyYyA9ICh4LCB5LCByYWRpdXMsIGZyb20sIHRvKSA9PiB7XG4gICAgbGV0IGFyY1N3ZWVwID0gMTtcbiAgICBpZiAodG8gPiBmcm9tICYmIHRvIC0gZnJvbSA8PSAwLjUpIHtcbiAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICBpZiAoZnJvbSA+IHRvICYmIGZyb20gLSB0byA+PSAwLjUpIHtcbiAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpYmVBcmMoXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgTWF0aC5taW4oMC45OTk5LCBmcm9tKSAqIDM2MCxcbiAgICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICAgIGFyY1N3ZWVwXG4gICAgKTtcbn07XG5cbmNvbnN0IGNyZWF0ZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBzdGFydCBhdCAwXG4gICAgcHJvcHMuc3BpbiA9IGZhbHNlO1xuICAgIHByb3BzLnByb2dyZXNzID0gMDtcbiAgICBwcm9wcy5vcGFjaXR5ID0gMDtcblxuICAgIC8vIHN2Z1xuICAgIGNvbnN0IHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICB9KTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICByb290LnJlZi5zdmcgPSBzdmc7XG5cbiAgICByb290LmFwcGVuZENoaWxkKHN2Zyk7XG59O1xuXG5jb25zdCB3cml0ZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICBpZiAocHJvcHMub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmFsaWduKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgfVxuXG4gICAgLy8gZ2V0IHdpZHRoIG9mIHN0cm9rZVxuICAgIGNvbnN0IHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2l6ZSBvZiByaW5nXG4gICAgY29uc3Qgc2l6ZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuXG4gICAgLy8gcmluZyBzdGF0ZVxuICAgIGxldCByaW5nRnJvbSA9IDA7XG4gICAgbGV0IHJpbmdUbyA9IDA7XG5cbiAgICAvLyBub3cgaW4gYnVzeSBtb2RlXG4gICAgaWYgKHByb3BzLnNwaW4pIHtcbiAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICByaW5nVG8gPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICByaW5nVG8gPSBwcm9wcy5wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHBlcmNlbnRhZ2VBcmMoc2l6ZSwgc2l6ZSwgc2l6ZSAtIHJpbmdTdHJva2VXaWR0aCwgcmluZ0Zyb20sIHJpbmdUbyk7XG5cbiAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgYXR0cihyb290LnJlZi5wYXRoLCAnZCcsIGNvb3JkaW5hdGVzKTtcblxuICAgIC8vIGhpZGUgd2hpbGUgY29udGFpbnMgMCB2YWx1ZVxuICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS1vcGFjaXR5JywgcHJvcHMuc3BpbiB8fCBwcm9wcy5wcm9ncmVzcyA+IDAgPyAxIDogMCk7XG59O1xuXG5jb25zdCBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2RpdicsXG4gICAgbmFtZTogJ3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZSxcbiAgICB3cml0ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydwcm9ncmVzcycsICdzcGluJywgJ2FsaWduJ10sXG4gICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDUwMCB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3M6IDAuOTUsXG4gICAgICAgICAgICAgICAgZGFtcGluZzogMC42NSxcbiAgICAgICAgICAgICAgICBtYXNzOiAxMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBjcmVhdGUkMSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gKHByb3BzLmljb24gfHwgJycpICsgYDxzcGFuPiR7cHJvcHMubGFiZWx9PC9zcGFuPmA7XG5cbiAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG5jb25zdCB3cml0ZSQxID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgaXNEaXNhYmxlZCB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc2hvdWxkRGlzYWJsZSA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpIHx8IHByb3BzLm9wYWNpdHkgPT09IDA7XG5cbiAgICBpZiAoc2hvdWxkRGlzYWJsZSAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXNob3VsZERpc2FibGUgJiYgaXNEaXNhYmxlZCkge1xuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsZUFjdGlvbkJ1dHRvbiA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2J1dHRvbicsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICB9LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZmlsZS1hY3Rpb24tYnV0dG9uJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydsYWJlbCddLFxuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJzOiB0cnVlLFxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICB3cml0ZTogd3JpdGUkMSxcbn0pO1xuXG5jb25zdCB0b05hdHVyYWxGaWxlU2l6ZSA9IChieXRlcywgZGVjaW1hbFNlcGFyYXRvciA9ICcuJywgYmFzZSA9IDEwMDAsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbGFiZWxCeXRlcyA9ICdieXRlcycsXG4gICAgICAgIGxhYmVsS2lsb2J5dGVzID0gJ0tCJyxcbiAgICAgICAgbGFiZWxNZWdhYnl0ZXMgPSAnTUInLFxuICAgICAgICBsYWJlbEdpZ2FieXRlcyA9ICdHQicsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBubyBuZWdhdGl2ZSBieXRlIHNpemVzXG4gICAgYnl0ZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGJ5dGVzKSk7XG5cbiAgICBjb25zdCBLQiA9IGJhc2U7XG4gICAgY29uc3QgTUIgPSBiYXNlICogYmFzZTtcbiAgICBjb25zdCBHQiA9IGJhc2UgKiBiYXNlICogYmFzZTtcblxuICAgIC8vIGp1c3QgYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBLQikge1xuICAgICAgICByZXR1cm4gYCR7Ynl0ZXN9ICR7bGFiZWxCeXRlc31gO1xuICAgIH1cblxuICAgIC8vIGtpbG9ieXRlc1xuICAgIGlmIChieXRlcyA8IE1CKSB7XG4gICAgICAgIHJldHVybiBgJHtNYXRoLmZsb29yKGJ5dGVzIC8gS0IpfSAke2xhYmVsS2lsb2J5dGVzfWA7XG4gICAgfVxuXG4gICAgLy8gbWVnYWJ5dGVzXG4gICAgaWYgKGJ5dGVzIDwgR0IpIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBNQiwgMSwgZGVjaW1hbFNlcGFyYXRvcil9ICR7bGFiZWxNZWdhYnl0ZXN9YDtcbiAgICB9XG5cbiAgICAvLyBnaWdhYnl0ZXNcbiAgICByZXR1cm4gYCR7cmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIEdCLCAyLCBkZWNpbWFsU2VwYXJhdG9yKX0gJHtsYWJlbEdpZ2FieXRlc31gO1xufTtcblxuY29uc3QgcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyA9ICh2YWx1ZSwgZGVjaW1hbENvdW50LCBzZXBhcmF0b3IpID0+IHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgLnRvRml4ZWQoZGVjaW1hbENvdW50KVxuICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydCAhPT0gJzAnKVxuICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xufTtcblxuY29uc3QgY3JlYXRlJDIgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gZmlsZW5hbWVcbiAgICBjb25zdCBmaWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVOYW1lLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLW1haW4nO1xuICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAvLyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gYSBmaWVsZHNldCB3aXRoIGxlZ2VuZCB0aGF0IGNvbnRhaW5zIHRoZSBmaWxlbmFtZVxuICAgIC8vIG5vIG5lZWQgdG8gcmVhZCBpdCB0d2ljZVxuICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlTmFtZSk7XG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuICAgIC8vIGZpbGVzaXplXG4gICAgY29uc3QgZmlsZVNpemUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBmaWxlU2l6ZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1zdWInO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZVNpemUpO1xuICAgIHJvb3QucmVmLmZpbGVTaXplID0gZmlsZVNpemU7XG5cbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICB0ZXh0KGZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9XQUlUSU5HX0ZPUl9TSVpFJykpO1xuICAgIHRleHQoZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbn07XG5cbmNvbnN0IHVwZGF0ZUZpbGUgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgdGV4dChcbiAgICAgICAgcm9vdC5yZWYuZmlsZVNpemUsXG4gICAgICAgIHRvTmF0dXJhbEZpbGVTaXplKFxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9GSUxFX1NJWkVfQkFTRScpLFxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9MQUJFTFMnLCByb290LnF1ZXJ5KVxuICAgICAgICApXG4gICAgKTtcbiAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG59O1xuXG5jb25zdCB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gaWYgc2l6ZSBpcyBhdmFpbGFibGUgZG9uJ3QgZmFsbGJhY2sgdG8gdW5rbm93biBzaXplIG1lc3NhZ2VcbiAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgICAgdXBkYXRlRmlsZSh7IHJvb3QsIHByb3BzIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGV4dChyb290LnJlZi5maWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9OT1RfQVZBSUxBQkxFJykpO1xufTtcblxuY29uc3QgZmlsZUluZm8gPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZmlsZS1pbmZvJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlRmlsZSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEE6IHVwZGF0ZUZpbGUsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogdXBkYXRlRmlsZVNpemVPbkVycm9yLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuY29uc3QgdG9QZXJjZW50YWdlID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG5cbmNvbnN0IGNyZWF0ZSQzID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgLy8gbWFpbiBzdGF0dXNcbiAgICBjb25zdCBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgbWFpbi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLW1haW4nO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQobWFpbik7XG4gICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAvLyBzdWIgc3RhdHVzXG4gICAgY29uc3Qgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgc3ViLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKHN1Yik7XG4gICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyh7IHJvb3QsIGFjdGlvbjogeyBwcm9ncmVzczogbnVsbCB9IH0pO1xufTtcblxuY29uc3QgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgdGl0bGUgPVxuICAgICAgICBhY3Rpb24ucHJvZ3Jlc3MgPT09IG51bGxcbiAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgICAgICA6IGAke3Jvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0xPQURJTkcnKX0gJHt0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKX0lYDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG59O1xuXG5jb25zdCBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCB0aXRsZSA9XG4gICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgICAgIDogYCR7cm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpfSAke3RvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpfSVgO1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbn07XG5cbmNvbnN0IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG59O1xuXG5jb25zdCBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fUkVUUlknKSk7XG59O1xuXG5jb25zdCBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG59O1xuXG5jb25zdCBjbGVhciA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgJycpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCAnJyk7XG59O1xuXG5jb25zdCBlcnJvciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCBhY3Rpb24uc3RhdHVzLm1haW4pO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCBhY3Rpb24uc3RhdHVzLnN1Yik7XG59O1xuXG5jb25zdCBmaWxlU3RhdHVzID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtc3RhdHVzJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogY2xlYXIsXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjbGVhcixcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogZXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBlcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IGVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGVycm9yLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbi8qKlxuICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gKi9cblxuY29uc3QgQnV0dG9ucyA9IHtcbiAgICBBYm9ydEl0ZW1Mb2FkOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tbG9hZCcsXG4gICAgICAgIGFsaWduOiAnTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtTG9hZDoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLWxvYWQnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmVtb3ZlSXRlbToge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nLFxuICAgICAgICBhY3Rpb246ICdSRVFVRVNUX1JFTU9WRV9JVEVNJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFTU9WRScsXG4gICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmVtb3ZlLWl0ZW0nLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicsIC8vIGxlZnRcbiAgICB9LFxuICAgIFByb2Nlc3NJdGVtOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9QUk9DRVNTX0lURU0nLFxuICAgICAgICBhY3Rpb246ICdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgIGljb246ICdHRVRfSUNPTl9QUk9DRVNTJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1wcm9jZXNzLWl0ZW0nLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgQWJvcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1VORE9fSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1VORE8nLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG59O1xuXG4vLyBtYWtlIGEgbGlzdCBvZiBidXR0b25zLCB3ZSBjYW4gdGhlbiByZW1vdmUgYnV0dG9ucyBmcm9tIHRoaXMgbGlzdCBpZiB0aGV5J3JlIGRpc2FibGVkXG5jb25zdCBCdXR0b25LZXlzID0gW107XG5mb3JpbihCdXR0b25zLCBrZXkgPT4ge1xuICAgIEJ1dHRvbktleXMucHVzaChrZXkpO1xufSk7XG5cbmNvbnN0IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gcm9vdCA9PiB7XG4gICAgaWYgKGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50KHJvb3QpID09PSAncmlnaHQnKSByZXR1cm4gMDtcbiAgICBjb25zdCBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3QuaGlkZGVuID8gbnVsbCA6IGJ1dHRvblJlY3Qud2lkdGggKyBidXR0b25SZWN0LmxlZnQ7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVCdXR0b25XaWR0aCA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGJ1dHRvblJlY3QgPSByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Mb2FkLnJlY3QuZWxlbWVudDtcbiAgICByZXR1cm4gYnV0dG9uUmVjdC53aWR0aDtcbn07XG5cbi8vIEZvcmNlIG9uIGZ1bGwgcGl4ZWxzIHNvIHRleHQgc3RheXMgY3JpcHNcbmNvbnN0IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldCA9IHJvb3QgPT5cbiAgICBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmhlaWdodCAvIDQpO1xuY29uc3QgY2FsY3VsYXRlRmlsZUhvcml6b250YWxDZW50ZXJPZmZzZXQgPSByb290ID0+XG4gICAgTWF0aC5mbG9vcihyb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudC5sZWZ0IC8gMik7XG5cbmNvbnN0IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgPSByb290ID0+IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpO1xuY29uc3QgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IHJvb3QgPT4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuY29uc3QgZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgPSByb290ID0+IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nKTtcblxuY29uc3QgRGVmYXVsdFN0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIHNjYWxlWDogMC43NSwgc2NhbGVZOiAwLjc1IH0sXG4gICAgaW5mbzogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH0sXG4gICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbn07XG5cbmNvbnN0IElkbGVTdHlsZSA9IHtcbiAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxufTtcblxuY29uc3QgUHJvY2Vzc2luZ1N0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbn07XG5cbmNvbnN0IFN0eWxlTWFwID0ge1xuICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0LCBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjoge1xuICAgICAgICBidXR0b25SZXRyeUl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSwgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfSxcbiAgICB9LFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjoge1xuICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IH0sXG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIH0sXG4gICAgRElEX0xPQURfSVRFTTogSWRsZVN0eWxlLFxuICAgIERJRF9MT0FEX0xPQ0FMX0lURU06IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIH0sXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IHtcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IElkbGVTdHlsZSxcbn07XG5cbi8vIGNvbXBsZXRlIGluZGljYXRvciB2aWV3XG5jb25zdCBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IHJvb3QucXVlcnkoJ0dFVF9JQ09OX0RPTkUnKTtcbiAgICB9LFxuICAgIG5hbWU6ICdwcm9jZXNzaW5nLWNvbXBsZXRlLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAqL1xuY29uc3QgY3JlYXRlJDQgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gY29weSBCdXR0b25zIG9iamVjdFxuICAgIGNvbnN0IExvY2FsQnV0dG9ucyA9IE9iamVjdC5rZXlzKEJ1dHRvbnMpLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICBwcmV2W2N1cnJdID0geyAuLi5CdXR0b25zW2N1cnJdIH07XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcblxuICAgIGNvbnN0IHsgaWQgfSA9IHByb3BzO1xuXG4gICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgIGNvbnN0IGFsbG93UmV2ZXJ0ID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFVkVSVCcpO1xuXG4gICAgLy8gYWxsb3cgcmVtb3ZlIGZpbGVcbiAgICBjb25zdCBhbGxvd1JlbW92ZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU1PVkUnKTtcblxuICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgY29uc3QgYWxsb3dQcm9jZXNzID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BST0NFU1MnKTtcblxuICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgIGNvbnN0IGluc3RhbnRVcGxvYWQgPSByb290LnF1ZXJ5KCdHRVRfSU5TVEFOVF9VUExPQUQnKTtcblxuICAgIC8vIGlzIGFzeW5jIHNldCB1cFxuICAgIGNvbnN0IGlzQXN5bmMgPSByb290LnF1ZXJ5KCdJU19BU1lOQycpO1xuXG4gICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICBjb25zdCBhbGlnblJlbW92ZUl0ZW1CdXR0b24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfQlVUVE9OX1JFTU9WRV9JVEVNX0FMSUdOJyk7XG5cbiAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICBsZXQgYnV0dG9uRmlsdGVyO1xuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbW92ZSByZXZlcnQgYnV0dG9uXG4gICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBrZXkgPT4gIS9SZXZlcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHByb2Nlc3MgYnV0dG9uXG4gICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBrZXkgPT4gIS9Qcm9jZXNzSXRlbXxSZXRyeUl0ZW1Qcm9jZXNzaW5nfEFib3J0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm9jZXNzIGJ1dHRvbnNcbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHByb2Nlc3MgY29udHJvbHMgYXZhaWxhYmxlXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmFibGVkQnV0dG9ucyA9IGJ1dHRvbkZpbHRlciA/IEJ1dHRvbktleXMuZmlsdGVyKGJ1dHRvbkZpbHRlcikgOiBCdXR0b25LZXlzLmNvbmNhdCgpO1xuXG4gICAgLy8gdXBkYXRlIGljb24gYW5kIGxhYmVsIGZvciByZXZlcnQgYnV0dG9uIHdoZW4gaW5zdGFudCB1cGxvYWRpbmdcbiAgICBpZiAoaW5zdGFudFVwbG9hZCAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10ubGFiZWwgPSAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTSc7XG4gICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGxhc3QgYnV0dG9uIChyZXZlcnQpIGlmIG5vdCBhbGxvd2VkXG4gICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgbWFwLmluZm8udHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgICAgbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIC8vIHNob3VsZCBhbGlnbiBjZW50ZXJcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICAgIFtcbiAgICAgICAgICAgICdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgICdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJyxcbiAgICAgICAgICAgICdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJyxcbiAgICAgICAgXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBTdHlsZU1hcFtrZXldLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgU3R5bGVNYXBbJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InXS5zdGF0dXMudHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUJ1dHRvbldpZHRoO1xuICAgIH1cblxuICAgIC8vIG1vdmUgcmVtb3ZlIGJ1dHRvbiB0byByaWdodFxuICAgIGlmIChhbGlnblJlbW92ZUl0ZW1CdXR0b24gJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgTG9jYWxCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmFsaWduID0gJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTic7XG4gICAgICAgIGNvbnN0IG1hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSW5mb09mZnNldDtcbiAgICAgICAgbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIC8vIHNob3cvaGlkZSBSZW1vdmVJdGVtIGJ1dHRvblxuICAgIGlmICghYWxsb3dSZW1vdmUpIHtcbiAgICAgICAgTG9jYWxCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgYnV0dG9uIHZpZXdzXG4gICAgZm9yaW4oTG9jYWxCdXR0b25zLCAoa2V5LCBkZWZpbml0aW9uKSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgICAgY29uc3QgYnV0dG9uVmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgICAgIGxhYmVsOiByb290LnF1ZXJ5KGRlZmluaXRpb24ubGFiZWwpLFxuICAgICAgICAgICAgaWNvbjogcm9vdC5xdWVyeShkZWZpbml0aW9uLmljb24pLFxuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIGFwcGVuZGVkP1xuICAgICAgICBpZiAoZW5hYmxlZEJ1dHRvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2dnbGVcbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcG9zaXRpb24gYXR0cmlidXRlXG4gICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcm9vdC5xdWVyeShgR0VUX1NUWUxFXyR7ZGVmaW5pdGlvbi5hbGlnbn1gKTtcblxuICAgICAgICAvLyBhZGQgY2xhc3NcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmaW5pdGlvbi5jbGFzc05hbWUpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbnRlcmFjdGlvbnNcbiAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaChkZWZpbml0aW9uLmFjdGlvbiwgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgICAgcm9vdC5yZWZbYGJ1dHRvbiR7a2V5fWBdID0gYnV0dG9uVmlldztcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrbWFya1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3KVxuICAgICk7XG4gICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yLmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgIGBHRVRfU1RZTEVfQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTmBcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgcm9vdC5yZWYuaW5mbyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVJbmZvLCB7IGlkIH0pKTtcblxuICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgcm9vdC5yZWYuc3RhdHVzID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVN0YXR1cywgeyBpZCB9KSk7XG5cbiAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgIGNvbnN0IGxvYWRJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoYEdFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTmApLFxuICAgICAgICB9KVxuICAgICk7XG4gICAgbG9hZEluZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tbG9hZC1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IgPSBsb2FkSW5kaWNhdG9yVmlldztcblxuICAgIGNvbnN0IHByb2dyZXNzSW5kaWNhdG9yVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIGFsaWduOiByb290LnF1ZXJ5KGBHRVRfU1RZTEVfUFJPR1JFU1NfSU5ESUNBVE9SX1BPU0lUSU9OYCksXG4gICAgICAgIH0pXG4gICAgKTtcbiAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IgPSBwcm9ncmVzc0luZGljYXRvclZpZXc7XG5cbiAgICAvLyBjdXJyZW50IGFjdGl2ZSBzdHlsZXNcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbn07XG5cbmNvbnN0IHdyaXRlJDIgPSAoeyByb290LCBhY3Rpb25zLCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlKHsgcm9vdCwgYWN0aW9ucywgcHJvcHMgfSk7XG5cbiAgICAvLyBzZWxlY3QgbGFzdCBzdGF0ZSBjaGFuZ2UgYWN0aW9uXG4gICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgIC5maWx0ZXIoYWN0aW9uID0+IC9eRElEXy8udGVzdChhY3Rpb24udHlwZSkpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmQoYWN0aW9uID0+IFN0eWxlTWFwW2FjdGlvbi50eXBlXSk7XG5cbiAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgICAvLyBkZWZpbmUgbmV3IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgICAgY29uc3Qgc3R5bGVzVG9BcHBseSA9IFN0eWxlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCAobmFtZSwgZGVmYXVsdFN0eWxlcykgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgICAgICBjb25zdCBjb250cm9sID0gcm9vdC5yZWZbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgICAgIGZvcmluKGRlZmF1bHRTdHlsZXMsIChrZXksIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJiB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsZXNUb0FwcGx5W25hbWVdW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5wdXNoKHsgY29udHJvbCwga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhY3RpdmUgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMuZm9yRWFjaCgoeyBjb250cm9sLCBrZXksIHZhbHVlIH0pID0+IHtcbiAgICAgICAgY29udHJvbFtrZXldID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocm9vdCkgOiB2YWx1ZTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IHJvdXRlID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZy5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRDogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTDogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtUmVtb3ZhbC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gYWN0aW9uLnByb2dyZXNzO1xuICAgIH0sXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICB9LFxufSk7XG5cbmNvbnN0IGZpbGUgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ0LFxuICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgbmFtZTogJ2ZpbGUnLFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSQ1ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIGZpbGVuYW1lXG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ2xlZ2VuZCcpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgLy8gZmlsZSBhcHBlbmRlZFxuICAgIHJvb3QucmVmLmZpbGUgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlLCB7IGlkOiBwcm9wcy5pZCB9KSk7XG5cbiAgICAvLyBkYXRhIGhhcyBtb3ZlZCB0byBkYXRhLmpzXG4gICAgcm9vdC5yZWYuZGF0YSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEYXRhIHN0b3JhZ2VcbiAqL1xuY29uc3QgZGlkTG9hZEl0ZW0gPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbn07XG5cbmNvbnN0IGZpbGVXcmFwcGVyID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgdGFnOiAnZmllbGRzZXQnLFxuICAgIG5hbWU6ICdmaWxlLXdyYXBwZXInLFxufSk7XG5cbmNvbnN0IFBBTkVMX1NQUklOR19QUk9QUyA9IHsgdHlwZTogJ3NwcmluZycsIGRhbXBpbmc6IDAuNiwgbWFzczogNyB9O1xuXG5jb25zdCBjcmVhdGUkNiA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgICAgICBzY2FsZVk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ2JvdHRvbScsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBQQU5FTF9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdLmZvckVhY2goc2VjdGlvbiA9PiB7XG4gICAgICAgIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgcHJvcHMubmFtZSk7XG4gICAgfSk7XG5cbiAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChgZmlsZXBvbmQtLSR7cHJvcHMubmFtZX1gKTtcblxuICAgIHJvb3QucmVmLnNjYWxhYmxlID0gbnVsbDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNlY3Rpb24gPSAocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSA9PiB7XG4gICAgY29uc3Qgdmlld0NvbnN0cnVjdG9yID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6IGBwYW5lbC0ke3NlY3Rpb24ubmFtZX0gZmlsZXBvbmQtLSR7Y2xhc3NOYW1lfWAsXG4gICAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCB2aWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcodmlld0NvbnN0cnVjdG9yLCBzZWN0aW9uLnByb3BzKTtcblxuICAgIHJvb3QucmVmW3NlY3Rpb24ubmFtZV0gPSByb290LmFwcGVuZENoaWxkVmlldyh2aWV3KTtcbn07XG5cbmNvbnN0IHdyaXRlJDMgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gdXBkYXRlIHNjYWxhYmxlIHN0YXRlXG4gICAgaWYgKHJvb3QucmVmLnNjYWxhYmxlID09PSBudWxsIHx8IHByb3BzLnNjYWxhYmxlICE9PSByb290LnJlZi5zY2FsYWJsZSkge1xuICAgICAgICByb290LnJlZi5zY2FsYWJsZSA9IGlzQm9vbGVhbihwcm9wcy5zY2FsYWJsZSkgPyBwcm9wcy5zY2FsYWJsZSA6IHRydWU7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgfVxuXG4gICAgLy8gbm8gaGVpZ2h0LCBjYW4ndCBzZXRcbiAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGNoaWxkIHJlY3RzXG4gICAgY29uc3QgdG9wUmVjdCA9IHJvb3QucmVmLnRvcC5yZWN0LmVsZW1lbnQ7XG4gICAgY29uc3QgYm90dG9tUmVjdCA9IHJvb3QucmVmLmJvdHRvbS5yZWN0LmVsZW1lbnQ7XG5cbiAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHRvcFJlY3QuaGVpZ2h0ICsgYm90dG9tUmVjdC5oZWlnaHQsIHByb3BzLmhlaWdodCk7XG5cbiAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICByb290LnJlZi5jZW50ZXIudHJhbnNsYXRlWSA9IHRvcFJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gc2NhbGUgY2VudGVyIHBhcnRcbiAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICByb290LnJlZi5jZW50ZXIuc2NhbGVZID0gKGhlaWdodCAtIHRvcFJlY3QuaGVpZ2h0IC0gYm90dG9tUmVjdC5oZWlnaHQpIC8gMTAwO1xuXG4gICAgLy8gb2Zmc2V0IGJvdHRvbSBwYXJ0XG4gICAgcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkgPSBoZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodDtcbn07XG5cbmNvbnN0IHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ3BhbmVsJyxcbiAgICByZWFkOiAoeyByb290LCBwcm9wcyB9KSA9PiAocHJvcHMuaGVpZ2h0Q3VycmVudCA9IHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZKSxcbiAgICB3cml0ZTogd3JpdGUkMyxcbiAgICBjcmVhdGU6IGNyZWF0ZSQ2LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnaGVpZ2h0JywgJ2hlaWdodEN1cnJlbnQnLCAnc2NhbGFibGUnXSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGNyZWF0ZURyYWdIZWxwZXIgPSBpdGVtcyA9PiB7XG4gICAgY29uc3QgaXRlbUlkcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uaWQpO1xuICAgIGxldCBwcmV2SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbmRleDogKCkgPT4gcHJldkluZGV4LFxuICAgICAgICBnZXRJdGVtSW5kZXg6IGl0ZW0gPT4gaXRlbUlkcy5pbmRleE9mKGl0ZW0uaWQpLFxuICAgIH07XG59O1xuXG5jb25zdCBJVEVNX1RSQU5TTEFURV9TUFJJTkcgPSB7XG4gICAgdHlwZTogJ3NwcmluZycsXG4gICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgIGRhbXBpbmc6IDAuNDUsXG4gICAgbWFzczogMTAsXG59O1xuXG5jb25zdCBJVEVNX1NDQUxFX1NQUklORyA9ICdzcHJpbmcnO1xuXG5jb25zdCBTdGF0ZU1hcCA9IHtcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiAnYnVzeScsXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiAnbG9hZC1pbnZhbGlkJyxcbiAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiAnbG9hZC1lcnJvcicsXG4gICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogJ3JlbW92ZS1lcnJvcicsXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiAnYnVzeScsXG4gICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiAnYnVzeSBwcm9jZXNzaW5nJyxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogJ3Byb2Nlc3NpbmcnLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiAncHJvY2Vzc2luZy1lcnJvcicsXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6ICdwcm9jZXNzaW5nLXJldmVydC1lcnJvcicsXG4gICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6ICdpZGxlJyxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSQ3ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIHNlbGVjdFxuICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZSA9PiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuXG4gICAgLy8gc2V0IGlkXG4gICAgcm9vdC5lbGVtZW50LmlkID0gYGZpbGVwb25kLS1pdGVtLSR7cHJvcHMuaWR9YDtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyBmaWxlIHZpZXdcbiAgICByb290LnJlZi5jb250YWluZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlV3JhcHBlciwgeyBpZDogcHJvcHMuaWQgfSkpO1xuXG4gICAgLy8gZmlsZSBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ2l0ZW0tcGFuZWwnIH0pKTtcblxuICAgIC8vIGRlZmF1bHQgc3RhcnQgaGVpZ2h0XG4gICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgIC8vIGJ5IGRlZmF1bHQgbm90IG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgIHByb3BzLm1hcmtlZEZvclJlbW92YWwgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpKSByZXR1cm47XG5cbiAgICAvLyBzZXQgdG8gaWRsZSBzbyBzaG93cyBncmFiIGN1cnNvclxuICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgIGNvbnN0IGdyYWIgPSBlID0+IHtcbiAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgICAgICAgIHg6IGUucGFnZVgsXG4gICAgICAgICAgICB5OiBlLnBhZ2VZLFxuICAgICAgICB9O1xuXG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVksXG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvcHMuZHJhZ0NlbnRlciA9IHtcbiAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IGUub2Zmc2V0WSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkcmFnU3RhdGUgPSBjcmVhdGVEcmFnSGVscGVyKHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSk7XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0dSQUJfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgY29uc3QgZHJhZyA9IGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGUucGFnZVggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiBkcmFnZ2VkIHN0b3AgbGlzdGVuaW5nIHRvIGNsaWNrcywgd2lsbCByZS1hZGQgd2hlbiBkb25lIGRyYWdnaW5nXG4gICAgICAgICAgICBjb25zdCBkaXN0ID1cbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnggKiBwcm9wcy5kcmFnT2Zmc2V0LnggKyBwcm9wcy5kcmFnT2Zmc2V0LnkgKiBwcm9wcy5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICBpZiAoZGlzdCA+IDE2ICYmICFyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRyb3AgPSBlID0+IHtcbiAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlIH0pO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgICAgICBpZiAocmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZHJhZyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBncmFiKTtcbn07XG5cbmNvbnN0IHJvdXRlJDEgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1VQREFURV9QQU5FTF9IRUlHSFQ6ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gYWN0aW9uLmhlaWdodDtcbiAgICB9LFxufSk7XG5cbmNvbnN0IHdyaXRlJDQgPSBjcmVhdGVSb3V0ZShcbiAgICB7XG4gICAgICAgIERJRF9HUkFCX0lURU06ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9EUkFHX0lURU06ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2RyYWcnO1xuICAgICAgICB9LFxuICAgICAgICBESURfRFJPUF9JVEVNOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2Ryb3AnO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgKHsgcm9vdCwgYWN0aW9ucywgcHJvcHMsIHNob3VsZE9wdGltaXplIH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICBpZiAocm9vdC5zY2FsZVggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKSlcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKGFjdGlvbiA9PiBTdGF0ZU1hcFthY3Rpb24udHlwZV0pO1xuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IHNhbWUgc3RhdGUgdHdpY2VcbiAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSAhPT0gcHJvcHMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgcHJvcHMuY3VycmVudFN0YXRlID0gYWN0aW9uLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIHNldCBzdGF0ZVxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZmlsZXBvbmRJdGVtU3RhdGUgPSBTdGF0ZU1hcFtwcm9wcy5jdXJyZW50U3RhdGVdIHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9XG4gICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fCByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIGlmICghYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHJvdXRlJDEoeyByb290LCBhY3Rpb25zLCBwcm9wcyB9KTtcbiAgICAgICAgICAgIGlmICghcm9vdC5oZWlnaHQgJiYgcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN5bmMgcGFuZWwgaGVpZ2h0IHdpdGggaXRlbSBoZWlnaHRcbiAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgfVxuKTtcblxuY29uc3QgaXRlbSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDcsXG4gICAgd3JpdGU6IHdyaXRlJDQsXG4gICAgZGVzdHJveTogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ1JFTEVBU0VfSVRFTScsIHsgcXVlcnk6IHByb3BzLmlkIH0pO1xuICAgIH0sXG4gICAgdGFnOiAnbGknLFxuICAgIG5hbWU6ICdpdGVtJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogW1xuICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICdpbnRlcmFjdGlvbk1ldGhvZCcsXG4gICAgICAgICAgICAnbWFya2VkRm9yUmVtb3ZhbCcsXG4gICAgICAgICAgICAnc3Bhd25EYXRlJyxcbiAgICAgICAgICAgICdkcmFnQ2VudGVyJyxcbiAgICAgICAgICAgICdkcmFnT3JpZ2luJyxcbiAgICAgICAgICAgICdkcmFnT2Zmc2V0JyxcbiAgICAgICAgXSxcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknLCAnaGVpZ2h0J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHNjYWxlWDogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICBzY2FsZVk6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG52YXIgZ2V0SXRlbXNQZXJSb3cgPSAoaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpID0+IHtcbiAgICAvLyBhZGQgb25lIHBpeGVsIGxlZXdheSwgd2hlbiB1c2luZyBwZXJjZW50YWdlcyBmb3IgaXRlbSB3aWR0aCB0b3RhbCBpdGVtcyBjYW4gYmUgMS45OSBwZXIgcm93XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigoaG9yaXpvbnRhbFNwYWNlICsgMSkgLyBpdGVtV2lkdGgpKTtcbn07XG5cbmNvbnN0IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24gPSAodmlldywgY2hpbGRyZW4sIHBvc2l0aW9uSW5WaWV3KSA9PiB7XG4gICAgaWYgKCFwb3NpdGlvbkluVmlldykgcmV0dXJuO1xuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gdmlldy5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgLy8gY29uc3QgY2hpbGRyZW4gPSB2aWV3LmNoaWxkVmlld3M7XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG5cbiAgICAvLyAtMSwgZG9uJ3QgbW92ZSBpdGVtcyB0byBhY2NvbW9kYXRlIChlaXRoZXIgYWRkIHRvIHRvcCBvciBib3R0b20pXG4gICAgaWYgKGwgPT09IDAgfHwgcG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50LnRvcCkgcmV0dXJuIC0xO1xuXG4gICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgY29uc3QgaXRlbSA9IGNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGl0ZW1SZWN0ID0gaXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgY29uc3QgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gaXRlbVJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICBjb25zdCBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgIC8vIHN0YWNrXG4gICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTWlkID0gY2hpbGQucmVjdC5vdXRlci50b3AgKyBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkTWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8vIGdyaWRcbiAgICBjb25zdCBpdGVtVmVydGljYWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5Ub3AgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGl0ZW1SZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBpbmRleFggPSBpbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICBjb25zdCBpbmRleFkgPSBNYXRoLmZsb29yKGluZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBpbmRleFggKiBpdGVtV2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGl0ZW1Ub3AgPSBvZmZzZXRZIC0gaXRlbVJlY3QubWFyZ2luVG9wO1xuICAgICAgICBjb25zdCBpdGVtUmlnaHQgPSBvZmZzZXRYICsgaXRlbVdpZHRoO1xuICAgICAgICBjb25zdCBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGl0ZW1Cb3R0b20gJiYgcG9zaXRpb25JblZpZXcudG9wID4gaXRlbVRvcCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LmxlZnQgPCBpdGVtUmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbDtcbn07XG5cbmNvbnN0IGRyb3BBcmVhRGltZW5zaW9ucyA9IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgZ2V0IGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0IHNldEhlaWdodCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgfSxcbiAgICBnZXQgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG4gICAgc2V0IHNldFdpZHRoKHZhbCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMud2lkdGggPSB2YWw7XG4gICAgfSxcbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbihoZWlnaHQsIHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH0sXG59O1xuXG5jb25zdCBjcmVhdGUkOCA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIC8vIG5lZWQgdG8gc2V0IHJvbGUgdG8gbGlzdCBhcyBvdGhlcndpc2UgaXQgd29uJ3QgYmUgcmVhZCBhcyBhIGxpc3QgYnkgVm9pY2VPdmVyXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBpdGVtXG4gKiBAcGFyYW0gcm9vdFxuICogQHBhcmFtIGFjdGlvblxuICovXG5jb25zdCBhZGRJdGVtVmlldyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgeyBpZCwgaW5kZXgsIGludGVyYWN0aW9uTWV0aG9kIH0gPSBhY3Rpb247XG5cbiAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3Bhd25EYXRlID0gbm93O1xuICAgIGxldCBvcGFjaXR5ID0gMTtcblxuICAgIGlmIChpbnRlcmFjdGlvbk1ldGhvZCAhPT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgY29uc3QgY29vbGRvd24gPSByb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfSU5URVJWQUwnKTtcbiAgICAgICAgY29uc3QgZGlzdCA9IG5vdyAtIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlO1xuICAgICAgICBzcGF3bkRhdGUgPSBkaXN0IDwgY29vbGRvd24gPyBub3cgKyAoY29vbGRvd24gLSBkaXN0KSA6IG5vdztcbiAgICB9XG5cbiAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IHNwYXduRGF0ZTtcblxuICAgIHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgIC8vIHZpZXcgdHlwZVxuICAgICAgICAgICAgaXRlbSxcblxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzcGF3bkRhdGUsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgaW5kZXhcbiAgICApO1xufTtcblxuY29uc3QgbW92ZUl0ZW0gPSAoaXRlbSwgeCwgeSwgdnggPSAwLCB2eSA9IDEpID0+IHtcbiAgICAvLyBzZXQgdG8gbnVsbCB0byByZW1vdmUgYW5pbWF0aW9uIHdoaWxlIGRyYWdnaW5nXG4gICAgaWYgKGl0ZW0uZHJhZ09mZnNldCkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBpdGVtLmRyYWdPcmlnaW4ueCArIGl0ZW0uZHJhZ09mZnNldC54O1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBpdGVtLmRyYWdPcmlnaW4ueSArIGl0ZW0uZHJhZ09mZnNldC55O1xuICAgICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgICBpdGVtLnNjYWxlWSA9IDEuMDI1O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG5cbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBpdGVtLnNwYXduRGF0ZSkge1xuICAgICAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpdGVtLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpcyBkZWZhdWx0IHNjYWxlIGV2ZXJ5IGZyYW1lXG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDE7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgaW50cm9JdGVtVmlldyA9IChpdGVtLCB4LCB5LCB2eCwgdnkpID0+IHtcbiAgICBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuRFJPUCkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gdnggKiAyMDtcblxuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gdnkgKiAxMDtcblxuICAgICAgICBpdGVtLnNjYWxlWCA9IDAuODtcbiAgICAgICAgaXRlbS5zY2FsZVkgPSAwLjg7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geSAtIDMwO1xuICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQVBJKSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSAzMDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgaXRlbVxuICogQHBhcmFtIHJvb3RcbiAqIEBwYXJhbSBhY3Rpb25cbiAqL1xuY29uc3QgcmVtb3ZlSXRlbVZpZXcgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQgfSA9IGFjdGlvbjtcblxuICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICBjb25zdCB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGlkKTtcblxuICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFuaW1hdGUgdmlldyBvdXQgb2Ygdmlld1xuICAgIHZpZXcuc2NhbGVYID0gMC45O1xuICAgIHZpZXcuc2NhbGVZID0gMC45O1xuICAgIHZpZXcub3BhY2l0eSA9IDA7XG5cbiAgICAvLyBtYXJrIGZvciByZW1vdmFsXG4gICAgdmlldy5tYXJrZWRGb3JSZW1vdmFsID0gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEl0ZW1IZWlnaHQgPSBjaGlsZCA9PlxuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20gKiAwLjUgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKiAwLjU7XG5jb25zdCBnZXRJdGVtV2lkdGggPSBjaGlsZCA9PlxuICAgIGNoaWxkLnJlY3QuZWxlbWVudC53aWR0aCArXG4gICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkxlZnQgKiAwLjUgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5SaWdodCAqIDAuNTtcblxuY29uc3QgZHJhZ0l0ZW0gPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQsIGRyYWdTdGF0ZSB9ID0gYWN0aW9uO1xuXG4gICAgLy8gcmVmZXJlbmNlIHRvIGl0ZW1cbiAgICBjb25zdCBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkIH0pO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIGNvbnN0IHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChjaGlsZCA9PiBjaGlsZC5pZCA9PT0gaWQpO1xuXG4gICAgY29uc3QgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgIGNvbnN0IG9sZEluZGV4ID0gZHJhZ1N0YXRlLmdldEl0ZW1JbmRleChpdGVtKTtcblxuICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgIGNvbnN0IGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdmlldy5kcmFnT3JpZ2luLnggKyB2aWV3LmRyYWdPZmZzZXQueCArIHZpZXcuZHJhZ0NlbnRlci54LFxuICAgICAgICB5OiB2aWV3LmRyYWdPcmlnaW4ueSArIHZpZXcuZHJhZ09mZnNldC55ICsgdmlldy5kcmFnQ2VudGVyLnksXG4gICAgfTtcblxuICAgIC8vIGdldCBkcmFnIGFyZWEgZGltZW5zaW9uc1xuICAgIGNvbnN0IGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgIGNvbnN0IGRyYWdXaWR0aCA9IGdldEl0ZW1XaWR0aCh2aWV3KTtcblxuICAgIC8vIGdldCByb3dzIGFuZCBjb2x1bW5zIChUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgcm93IGFuZCBvbmUgY29sdW1uIGlmIGEgZmlsZSBpcyBwcmVzZW50KVxuICAgIGxldCBjb2xzID0gTWF0aC5mbG9vcihyb290LnJlY3Qub3V0ZXIud2lkdGggLyBkcmFnV2lkdGgpO1xuICAgIGlmIChjb2xzID4gbnVtSXRlbXMpIGNvbHMgPSBudW1JdGVtcztcblxuICAgIC8vIHJvd3MgYXJlIHVzZWQgdG8gZmluZCB3aGVuIHdlIGhhdmUgbGVmdCB0aGUgcHJldmlldyBhcmVhIGJvdW5kaW5nIGJveFxuICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKG51bUl0ZW1zIC8gY29scyArIDEpO1xuXG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldEhlaWdodCA9IGRyYWdIZWlnaHQgKiByb3dzO1xuICAgIGRyb3BBcmVhRGltZW5zaW9ucy5zZXRXaWR0aCA9IGRyYWdXaWR0aCAqIGNvbHM7XG5cbiAgICAvLyBnZXQgbmV3IGluZGV4IG9mIGRyYWdnZWQgaXRlbVxuICAgIHZhciBsb2NhdGlvbiA9IHtcbiAgICAgICAgeTogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueSAvIGRyYWdIZWlnaHQpLFxuICAgICAgICB4OiBNYXRoLmZsb29yKGRyYWdQb3NpdGlvbi54IC8gZHJhZ1dpZHRoKSxcbiAgICAgICAgZ2V0R3JpZEluZGV4OiBmdW5jdGlvbiBnZXRHcmlkSW5kZXgoKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPCAwIHx8XG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueCA8IDBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICogY29scyArIHRoaXMueDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29sSW5kZXg6IGZ1bmN0aW9uIGdldENvbEluZGV4KCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtcy5tYXAoaXRlbSA9PlxuICAgICAgICAgICAgICAgIHZpc2libGVDaGlsZHJlbi5maW5kKGNoaWxkVmlldyA9PiBjaGlsZFZpZXcuaWQgPT09IGl0ZW0uaWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KGNoaWxkID0+IGNoaWxkID09PSB2aWV3KTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgICAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpZHggPSBsO1xuICAgICAgICAgICAgbGV0IGNoaWxkSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBjaGlsZEJvdHRvbSA9IDA7XG4gICAgICAgICAgICBsZXQgY2hpbGRUb3AgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZEhlaWdodCA9IGdldEl0ZW1IZWlnaHQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9wID0gY2hpbGRCb3R0b207XG4gICAgICAgICAgICAgICAgY2hpbGRCb3R0b20gPSBjaGlsZFRvcCArIGNoaWxkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZFRvcCArIGRyYWdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gZ2V0IG5ldyBpbmRleFxuICAgIGNvbnN0IGluZGV4ID0gY29scyA+IDEgPyBsb2NhdGlvbi5nZXRHcmlkSW5kZXgoKSA6IGxvY2F0aW9uLmdldENvbEluZGV4KCk7XG4gICAgcm9vdC5kaXNwYXRjaCgnTU9WRV9JVEVNJywgeyBxdWVyeTogdmlldywgaW5kZXggfSk7XG5cbiAgICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gY2hhbmdlZCwgZGlzcGF0Y2ggcmVvcmRlciBhY3Rpb25cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBkcmFnU3RhdGUuZ2V0SW5kZXgoKTtcblxuICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIGRyYWdTdGF0ZS5zZXRJbmRleChpbmRleCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgICAgICBpdGVtczogcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICAgICAgb3JpZ2luOiBvbGRJbmRleCxcbiAgICAgICAgICAgIHRhcmdldDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYWN0aW9uIHJvdXRlc1xuICovXG5jb25zdCByb3V0ZSQyID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9BRERfSVRFTTogYWRkSXRlbVZpZXcsXG4gICAgRElEX1JFTU9WRV9JVEVNOiByZW1vdmVJdGVtVmlldyxcbiAgICBESURfRFJBR19JVEVNOiBkcmFnSXRlbSxcbn0pO1xuXG4vKipcbiAqIFdyaXRlIHRvIHZpZXdcbiAqIEBwYXJhbSByb290XG4gKiBAcGFyYW0gYWN0aW9uc1xuICogQHBhcmFtIHByb3BzXG4gKi9cbmNvbnN0IHdyaXRlJDUgPSAoeyByb290LCBwcm9wcywgYWN0aW9ucywgc2hvdWxkT3B0aW1pemUgfSkgPT4ge1xuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQyKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSk7XG5cbiAgICBjb25zdCB7IGRyYWdDb29yZGluYXRlcyB9ID0gcHJvcHM7XG5cbiAgICAvLyBhdmFpbGFibGUgc3BhY2Ugb24gaG9yaXpvbnRhbCBheGlzXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG5cbiAgICAvLyBvbmx5IGRyYXcgY2hpbGRyZW4gdGhhdCBoYXZlIGRpbWVuc2lvbnNcbiAgICBjb25zdCB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuXG4gICAgLy8gc29ydCBiYXNlZCBvbiBjdXJyZW50IGFjdGl2ZSBpdGVtc1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAubWFwKGl0ZW0gPT4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGl0ZW0uaWQpKVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAvLyBnZXQgaW5kZXhcbiAgICBjb25zdCBkcmFnSW5kZXggPSBkcmFnQ29vcmRpbmF0ZXNcbiAgICAgICAgPyBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKHJvb3QsIGNoaWxkcmVuLCBkcmFnQ29vcmRpbmF0ZXMpXG4gICAgICAgIDogbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgIGNvbnN0IGFkZEluZGV4ID0gcm9vdC5yZWYuYWRkSW5kZXggfHwgbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBubyBsb25nZXIgbmVlZGVkIHRpbGwgcG9zc2libHkgbmV4dCBkcmF3XG4gICAgcm9vdC5yZWYuYWRkSW5kZXggPSBudWxsO1xuXG4gICAgbGV0IGRyYWdJbmRleE9mZnNldCA9IDA7XG4gICAgbGV0IHJlbW92ZUluZGV4T2Zmc2V0ID0gMDtcbiAgICBsZXQgYWRkSW5kZXhPZmZzZXQgPSAwO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuICAgIGNvbnN0IGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIGNvbnN0IGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpbkxlZnQgKyBjaGlsZFJlY3QubWFyZ2luUmlnaHQ7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgY29uc3QgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgICAgIGxldCBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IGluZGV4IC0gZHJhZ0luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgMCwgb2Zmc2V0WSArIGRyYWdPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXRlbUhlaWdodCA9IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICAgICAgICAgIGxldCB2aXN1YWxIZWlnaHQgPSBpdGVtSGVpZ2h0ICogKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgPyBjaGlsZC5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgICAgIG9mZnNldFkgKz0gdmlzdWFsSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcHJldlggPSAwO1xuICAgICAgICBsZXQgcHJldlkgPSAwO1xuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkcmFnSW5kZXhPZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGFkZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgYWRkSW5kZXhPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUluZGV4T2Zmc2V0IC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbEluZGV4ID0gaW5kZXggKyBhZGRJbmRleE9mZnNldCArIGRyYWdJbmRleE9mZnNldCArIHJlbW92ZUluZGV4T2Zmc2V0O1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleFggPSB2aXN1YWxJbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICAgICAgY29uc3QgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JZID0gTWF0aC5zaWduKG9mZnNldFkgLSBwcmV2WSk7XG5cbiAgICAgICAgICAgIHByZXZYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgIHByZXZZID0gb2Zmc2V0WTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZLCB2ZWN0b3JYLCB2ZWN0b3JZKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIGFjdGlvbnMgdGhhdCBhcmUgbWVhbnQgc3BlY2lmaWNhbGx5IGZvciBhIGNlcnRhaW4gY2hpbGQgb2YgdGhlIGxpc3RcbiAqIEBwYXJhbSBjaGlsZFxuICogQHBhcmFtIGFjdGlvbnNcbiAqL1xuY29uc3QgZmlsdGVyU2V0SXRlbUFjdGlvbnMgPSAoY2hpbGQsIGFjdGlvbnMpID0+XG4gICAgYWN0aW9ucy5maWx0ZXIoYWN0aW9uID0+IHtcbiAgICAgICAgLy8gaWYgYWN0aW9uIGhhcyBhbiBpZCwgZmlsdGVyIG91dCBhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIGNoaWxkIGlkXG4gICAgICAgIGlmIChhY3Rpb24uZGF0YSAmJiBhY3Rpb24uZGF0YS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBhY3Rpb24uZGF0YS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsbG93IGFsbCBvdGhlciBhY3Rpb25zXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG5jb25zdCBsaXN0ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkOCxcbiAgICB3cml0ZTogd3JpdGUkNSxcbiAgICB0YWc6ICd1bCcsXG4gICAgbmFtZTogJ2xpc3QnLFxuICAgIGRpZFdyaXRlVmlldzogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QuY2hpbGRWaWV3c1xuICAgICAgICAgICAgLmZpbHRlcih2aWV3ID0+IHZpZXcubWFya2VkRm9yUmVtb3ZhbCAmJiB2aWV3Lm9wYWNpdHkgPT09IDAgJiYgdmlldy5yZXN0aW5nKVxuICAgICAgICAgICAgLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZDogZmlsdGVyU2V0SXRlbUFjdGlvbnMsXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBjcmVhdGUkOSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdCkpO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbn07XG5cbmNvbnN0IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbiB9KSA9PiB7XG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0ge1xuICAgICAgICBsZWZ0OiBhY3Rpb24ucG9zaXRpb24uc2NvcGVMZWZ0IC0gcm9vdC5yZWYubGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgdG9wOlxuICAgICAgICAgICAgYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wIC1cbiAgICAgICAgICAgIChyb290LnJlY3Qub3V0ZXIudG9wICsgcm9vdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICsgcm9vdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKSxcbiAgICB9O1xufTtcblxuY29uc3QgY2xlYXJEcmFnQ29vcmRpbmF0ZXMgPSAoeyBwcm9wcyB9KSA9PiB7XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbn07XG5cbmNvbnN0IHJvdXRlJDMgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0RSQUc6IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzLFxuICAgIERJRF9FTkRfRFJBRzogY2xlYXJEcmFnQ29vcmRpbmF0ZXMsXG59KTtcblxuY29uc3Qgd3JpdGUkNiA9ICh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pID0+IHtcbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkMyh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pO1xuXG4gICAgLy8gY3VycmVudCBkcmFnIHBvc2l0aW9uXG4gICAgcm9vdC5yZWYubGlzdC5kcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAvLyBpZiBjdXJyZW50bHkgb3ZlcmZsb3dpbmcgYnV0IG5vIGxvbmdlciByZWNlaXZlZCBvdmVyZmxvd1xuICAgIGlmIChwcm9wcy5vdmVyZmxvd2luZyAmJiAhcHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXNldCBvdmVyZmxvdyBzdGF0ZVxuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICcnO1xuICAgICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgbm90IG92ZXJmbG93aW5nIGN1cnJlbnRseSBidXQgZG9lcyByZWNlaXZlIG92ZXJmbG93IHZhbHVlXG4gICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgucm91bmQocHJvcHMub3ZlcmZsb3cpO1xuICAgICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuc3RhdGUgPSAnb3ZlcmZsb3cnO1xuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBsaXN0U2Nyb2xsZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgIHdyaXRlOiB3cml0ZSQ2LFxuICAgIG5hbWU6ICdsaXN0LXNjcm9sbGVyJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydvdmVyZmxvdycsICdkcmFnQ29vcmRpbmF0ZXMnXSxcbiAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuY29uc3QgYXR0clRvZ2dsZSA9IChlbGVtZW50LCBuYW1lLCBzdGF0ZSwgZW5hYmxlZFZhbHVlID0gJycpID0+IHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCBlbmFibGVkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbn07XG5cbmNvbnN0IHJlc2V0RmlsZUlucHV0ID0gaW5wdXQgPT4ge1xuICAgIC8vIG5vIHZhbHVlLCBubyBuZWVkIHRvIHJlc2V0XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAvLyBmb3IgSUUxMFxuICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgICAgY29uc3QgZm9ybSA9IGNyZWF0ZUVsZW1lbnQkMSgnZm9ybScpO1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gaW5wdXQucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBmb3JtLnJlc2V0KCk7XG5cbiAgICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCByZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGUkYSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBzZXQgaWQgc28gY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSBvdXRzaWRlIGxhYmVsc1xuICAgIHJvb3QuZWxlbWVudC5pZCA9IGBmaWxlcG9uZC0tYnJvd3Nlci0ke3Byb3BzLmlkfWA7XG5cbiAgICAvLyBzZXQgbmFtZSBvZiBlbGVtZW50IChpcyByZW1vdmVkIHdoZW4gYSB2YWx1ZSBpcyBzZXQpXG4gICAgYXR0cihyb290LmVsZW1lbnQsICduYW1lJywgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1jb250cm9scycsIGBmaWxlcG9uZC0tYXNzaXN0YW50LSR7cHJvcHMuaWR9YCk7XG5cbiAgICAvLyBzZXQgbGFiZWwsIHdlIHVzZSBsYWJlbGxlZCBieSBhcyBvdGhlcndpc2UgdGhlIHNjcmVlbnJlYWRlciBkb2VzIG5vdCByZWFkIHRoZSBcImJyb3dzZVwiIHRleHQgaW4gdGhlIGxhYmVsIChhcyBpdCBoYXMgdGFiaW5kZXg6IDApXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCBgZmlsZXBvbmQtLWRyb3AtbGFiZWwtJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIHNldCBjb25maWd1cmFibGUgcHJvcHNcbiAgICBzZXRBY2NlcHRlZEZpbGVUeXBlcyh7IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSB9IH0pO1xuICAgIHRvZ2dsZUFsbG93TXVsdGlwbGUoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH0gfSk7XG4gICAgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKHsgcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWScpIH0gfSk7XG4gICAgdG9nZ2xlRGlzYWJsZWQoeyByb290IH0pO1xuICAgIHRvZ2dsZVJlcXVpcmVkKHsgcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSB9IH0pO1xuICAgIHNldENhcHR1cmVNZXRob2QoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9DQVBUVVJFX01FVEhPRCcpIH0gfSk7XG5cbiAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICByb290LnJlZi5oYW5kbGVDaGFuZ2UgPSBlID0+IHtcbiAgICAgICAgaWYgKCFyb290LmVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dHJhY3QgZmlsZXMgYW5kIG1vdmUgdmFsdWUgb2Ygd2Via2l0UmVsYXRpdmVQYXRoIHBhdGggdG8gX3JlbGF0aXZlUGF0aFxuICAgICAgICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb20ocm9vdC5lbGVtZW50LmZpbGVzKS5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBhZGQgYSBsaXR0bGUgZGVsYXkgc28gdGhlIE9TIGZpbGUgc2VsZWN0IHdpbmRvdyBjYW4gbW92ZSBvdXQgb2YgdGhlIHdheSBiZWZvcmUgd2UgYWRkIG91ciBmaWxlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gbG9hZCBmaWxlc1xuICAgICAgICAgICAgcHJvcHMub25sb2FkKGZpbGVzKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgaW5wdXQsIGl0J3MganVzdCBmb3IgZXhwb3NpbmcgYSBtZXRob2QgdG8gZHJvcCBmaWxlcywgc2hvdWxkIG5vdCByZXRhaW4gYW55IHN0YXRlXG4gICAgICAgICAgICByZXNldEZpbGVJbnB1dChyb290LmVsZW1lbnQpO1xuICAgICAgICB9LCAyNTApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbn07XG5cbmNvbnN0IHNldEFjY2VwdGVkRmlsZVR5cGVzID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19TWU5DX0FDQ0VQVF9BVFRSSUJVVEUnKSkgcmV0dXJuO1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnYWNjZXB0JywgISFhY3Rpb24udmFsdWUsIGFjdGlvbi52YWx1ZSA/IGFjdGlvbi52YWx1ZS5qb2luKCcsJykgOiAnJyk7XG59O1xuXG5jb25zdCB0b2dnbGVBbGxvd011bHRpcGxlID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ211bHRpcGxlJywgYWN0aW9uLnZhbHVlKTtcbn07XG5cbmNvbnN0IHRvZ2dsZURpcmVjdG9yeUZpbHRlciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICd3ZWJraXRkaXJlY3RvcnknLCBhY3Rpb24udmFsdWUpO1xufTtcblxuY29uc3QgdG9nZ2xlRGlzYWJsZWQgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgY29uc3QgZG9lc0FsbG93QnJvd3NlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIGNvbnN0IGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZUZpZWxkKTtcbn07XG5cbmNvbnN0IHRvZ2dsZVJlcXVpcmVkID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAvLyB3YW50IHRvIHJlbW92ZSByZXF1aXJlZCwgYWx3YXlzIHBvc3NpYmxlXG4gICAgaWYgKCFhY3Rpb24udmFsdWUpIHtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gaWYgd2FudCB0byBtYWtlIHJlcXVpcmVkLCBvbmx5IHBvc3NpYmxlIHdoZW4gemVybyBpdGVtc1xuICAgIGVsc2UgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID09PSAwKSB7XG4gICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICB9XG59O1xuXG5jb25zdCBzZXRDYXB0dXJlTWV0aG9kID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2NhcHR1cmUnLCAhIWFjdGlvbi52YWx1ZSwgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWUpO1xufTtcblxuY29uc3QgdXBkYXRlUmVxdWlyZWRTdGF0dXMgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHJvb3Q7XG4gICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIHdoZW4gbW9yZSB0aGFuIHplcm8gaXRlbXNcbiAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPiAwKSB7XG4gICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgdHJ1ZSwgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgaWYgKHNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhZGQgcmVxdWlyZWQgaWYgdGhlIGZpZWxkIGhhcyBiZWVuIGRlZW1lZCByZXF1aXJlZFxuICAgICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1JFUVVJUkVEJykpIHtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgIGlmICghc2hvdWxkQ2hlY2tWYWxpZGl0eSkgcmV0dXJuO1xuICAgIHJvb3QuZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eShyb290LnF1ZXJ5KCdHRVRfTEFCRUxfSU5WQUxJRF9GSUVMRCcpKTtcbn07XG5cbmNvbnN0IGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdpbnB1dCcsXG4gICAgbmFtZTogJ2Jyb3dzZXInLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlJGEsXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMsXG5cbiAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgICAgRElEX1NFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZOiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIsXG4gICAgICAgIERJRF9TRVRfQUxMT1dfTVVMVElQTEU6IHRvZ2dsZUFsbG93TXVsdGlwbGUsXG4gICAgICAgIERJRF9TRVRfQUNDRVBURURfRklMRV9UWVBFUzogc2V0QWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgIERJRF9TRVRfQ0FQVFVSRV9NRVRIT0Q6IHNldENhcHR1cmVNZXRob2QsXG4gICAgICAgIERJRF9TRVRfUkVRVUlSRUQ6IHRvZ2dsZVJlcXVpcmVkLFxuICAgIH0pLFxufSk7XG5cbmNvbnN0IEtleSA9IHtcbiAgICBFTlRFUjogMTMsXG4gICAgU1BBQ0U6IDMyLFxufTtcblxuY29uc3QgY3JlYXRlJGIgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gY3JlYXRlIHRoZSBsYWJlbCBhbmQgbGluayBpdCB0byB0aGUgZmlsZSBicm93c2VyXG4gICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgYXR0cihsYWJlbCwgJ2ZvcicsIGBmaWxlcG9uZC0tYnJvd3Nlci0ke3Byb3BzLmlkfWApO1xuXG4gICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICBhdHRyKGxhYmVsLCAnaWQnLCBgZmlsZXBvbmQtLWRyb3AtbGFiZWwtJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIGhhbmRsZSBrZXlzXG4gICAgcm9vdC5yZWYuaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgICAgICBjb25zdCBpc0FjdGl2YXRpb25LZXkgPSBlLmtleUNvZGUgPT09IEtleS5FTlRFUiB8fCBlLmtleUNvZGUgPT09IEtleS5TUEFDRTtcbiAgICAgICAgaWYgKCFpc0FjdGl2YXRpb25LZXkpIHJldHVybjtcbiAgICAgICAgLy8gc3RvcHMgZnJvbSB0cmlnZ2VyaW5nIHRoZSBlbGVtZW50IGEgc2Vjb25kIHRpbWVcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbGljayB0d2ljZVxuICAgICAgICBpZiAoaXNMYWJlbENsaWNrKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCBwcm9wcy5jYXB0aW9uKTtcblxuICAgIC8vIGFkZCFcbiAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICByb290LnJlZi5sYWJlbCA9IGxhYmVsO1xufTtcblxuY29uc3QgdXBkYXRlTGFiZWxWYWx1ZSA9IChsYWJlbCwgdmFsdWUpID0+IHtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICBjb25zdCBjbGlja2FibGUgPSBsYWJlbC5xdWVyeVNlbGVjdG9yKCcuZmlsZXBvbmQtLWxhYmVsLWFjdGlvbicpO1xuICAgIGlmIChjbGlja2FibGUpIHtcbiAgICAgICAgYXR0cihjbGlja2FibGUsICd0YWJpbmRleCcsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IGRyb3BMYWJlbCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdkcm9wLWxhYmVsJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZTogY3JlYXRlJGIsXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1NFVF9MQUJFTF9JRExFOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDE1MCB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJpcC1ibG9iJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGFkZEJsb2IgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHJvb3QucmVjdC5lbGVtZW50LmhlaWdodCAqIDAuNTtcblxuICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYmxvYiwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHNjYWxlWDogMi41LFxuICAgICAgICAgICAgc2NhbGVZOiAyLjUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBjZW50ZXJYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogY2VudGVyWSxcbiAgICAgICAgfSlcbiAgICApO1xufTtcblxuY29uc3QgbW92ZUJsb2IgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGlmICghcm9vdC5yZWYuYmxvYikge1xuICAgICAgICBhZGRCbG9iKHsgcm9vdCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVZID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wO1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMTtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMTtcbn07XG5cbmNvbnN0IGhpZGVCbG9iID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbn07XG5cbmNvbnN0IGV4cGxvZGVCbG9iID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbn07XG5cbmNvbnN0IHdyaXRlJDcgPSAoeyByb290LCBwcm9wcywgYWN0aW9ucyB9KSA9PiB7XG4gICAgcm91dGUkNCh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pO1xuXG4gICAgY29uc3QgeyBibG9iIH0gPSByb290LnJlZjtcblxuICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBibG9iICYmIGJsb2Iub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYiA9IG51bGw7XG4gICAgfVxufTtcblxuY29uc3Qgcm91dGUkNCA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgRElEX0RST1A6IGV4cGxvZGVCbG9iLFxuICAgIERJRF9FTkRfRFJBRzogaGlkZUJsb2IsXG59KTtcblxuY29uc3QgZHJpcCA9IGNyZWF0ZVZpZXcoe1xuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZHJpcCcsXG4gICAgd3JpdGU6IHdyaXRlJDcsXG59KTtcblxuY29uc3Qgc2V0SW5wdXRGaWxlcyA9IChlbGVtZW50LCBmaWxlcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIERhdGFUcmFuc2ZlciBpbnN0YW5jZSBhbmQgYWRkIGEgbmV3bHkgY3JlYXRlZCBmaWxlXG4gICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlKFtmaWxlXSwgZmlsZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXNzaWduIHRoZSBEYXRhVHJhbnNmZXIgZmlsZXMgbGlzdCB0byB0aGUgZmlsZSBpbnB1dFxuICAgICAgICBlbGVtZW50LmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgY3JlYXRlJGMgPSAoeyByb290IH0pID0+IHtcbiAgICByb290LnJlZi5maWVsZHMgPSB7fTtcbiAgICBjb25zdCBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICBsZWdlbmQudGV4dENvbnRlbnQgPSAnRmlsZXMnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChsZWdlbmQpO1xufTtcblxuY29uc3QgZ2V0RmllbGQgPSAocm9vdCwgaWQpID0+IHJvb3QucmVmLmZpZWxkc1tpZF07XG5cbmNvbnN0IHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyA9IHJvb3QgPT4ge1xuICAgIHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmllbGRzW2l0ZW0uaWRdKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGRpZFJlb3JkZXJJdGVtcyA9ICh7IHJvb3QgfSkgPT4gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuXG5jb25zdCBkaWRBZGRJdGVtID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCBmaWxlSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBpc0xvY2FsRmlsZSA9IGZpbGVJdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTDtcbiAgICBjb25zdCBzaG91bGRVc2VGaWxlSW5wdXQgPSAhaXNMb2NhbEZpbGUgJiYgcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJyk7XG4gICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQkMSgnaW5wdXQnKTtcbiAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSBzaG91bGRVc2VGaWxlSW5wdXQgPyAnZmlsZScgOiAnaGlkZGVuJztcbiAgICBkYXRhQ29udGFpbmVyLm5hbWUgPSByb290LnF1ZXJ5KCdHRVRfTkFNRScpO1xuICAgIHJvb3QucmVmLmZpZWxkc1thY3Rpb24uaWRdID0gZGF0YUNvbnRhaW5lcjtcbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG59O1xuXG5jb25zdCBkaWRMb2FkSXRlbSQxID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuXG4gICAgLy8gc3RvcmUgc2VydmVyIHJlZiBpbiBoaWRkZW4gaW5wdXRcbiAgICBpZiAoYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGwpIGZpZWxkLnZhbHVlID0gYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAvLyBzdG9yZSBmaWxlIGl0ZW0gaW4gZmlsZSBpbnB1dFxuICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcblxuICAgIGNvbnN0IGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHNldElucHV0RmlsZXMoZmllbGQsIFtmaWxlSXRlbS5maWxlXSk7XG59O1xuXG5jb25zdCBkaWRQcmVwYXJlT3V0cHV0ID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAvLyB0aGlzIHRpbWVvdXQgcHVzaGVzIHRoZSBoYW5kbGVyIGFmdGVyICdsb2FkJ1xuICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgIHNldElucHV0RmlsZXMoZmllbGQsIFthY3Rpb24uZmlsZV0pO1xuICAgIH0sIDApO1xufTtcblxuY29uc3QgZGlkU2V0RGlzYWJsZWQgPSAoeyByb290IH0pID0+IHtcbiAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbn07XG5cbmNvbnN0IGRpZFJlbW92ZUl0ZW0gPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGZpZWxkLnBhcmVudE5vZGUpIGZpZWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmllbGQpO1xuICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbn07XG5cbi8vIG9ubHkgcnVucyBmb3Igc2VydmVyIGZpbGVzLiB3aWxsIHJlZnVzZSB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIHRoZSBmaWVsZFxuLy8gaXMgYSBmaWxlIGZpZWxkXG5jb25zdCBkaWREZWZpbmVWYWx1ZSA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICBpZiAoYWN0aW9uLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNsZWFyIGZpZWxkIHZhbHVlXG4gICAgICAgIGZpZWxkLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgZmllbGQgdmFsdWVcbiAgICAgICAgaWYgKGZpZWxkLnR5cGUgIT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBmaWVsZC52YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG59O1xuXG5jb25zdCB3cml0ZSQ4ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfRElTQUJMRUQ6IGRpZFNldERpc2FibGVkLFxuICAgIERJRF9BRERfSVRFTTogZGlkQWRkSXRlbSxcbiAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbSQxLFxuICAgIERJRF9SRU1PVkVfSVRFTTogZGlkUmVtb3ZlSXRlbSxcbiAgICBESURfREVGSU5FX1ZBTFVFOiBkaWREZWZpbmVWYWx1ZSxcbiAgICBESURfUFJFUEFSRV9PVVRQVVQ6IGRpZFByZXBhcmVPdXRwdXQsXG4gICAgRElEX1JFT1JERVJfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICBESURfU09SVF9JVEVNUzogZGlkUmVvcmRlckl0ZW1zLFxufSk7XG5cbmNvbnN0IGRhdGEgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGNyZWF0ZTogY3JlYXRlJGMsXG4gICAgd3JpdGU6IHdyaXRlJDgsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbn0pO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9IGVsZW1lbnQgPT4gKCdnZXRSb290Tm9kZScgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50KTtcblxuY29uc3QgaW1hZ2VzID0gWydqcGcnLCAnanBlZycsICdwbmcnLCAnZ2lmJywgJ2JtcCcsICd3ZWJwJywgJ3N2ZycsICd0aWZmJ107XG5jb25zdCB0ZXh0JDEgPSBbJ2NzcycsICdjc3YnLCAnaHRtbCcsICd0eHQnXTtcbmNvbnN0IG1hcCA9IHtcbiAgICB6aXA6ICd6aXB8Y29tcHJlc3NlZCcsXG4gICAgZXB1YjogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbn07XG5cbmNvbnN0IGd1ZXNzdGltYXRlTWltZVR5cGUgPSAoZXh0ZW5zaW9uID0gJycpID0+IHtcbiAgICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaW1hZ2VzLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdpbWFnZS8nICsgKGV4dGVuc2lvbiA9PT0gJ2pwZycgPyAnanBlZycgOiBleHRlbnNpb24gPT09ICdzdmcnID8gJ3N2Zyt4bWwnIDogZXh0ZW5zaW9uKVxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAodGV4dCQxLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuICd0ZXh0LycgKyBleHRlbnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xufTtcblxuY29uc3QgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zID0gZGF0YVRyYW5zZmVyID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB0cnkgdG8gZ2V0IGxpbmtzIGZyb20gdHJhbnNmZXIsIGlmIGZvdW5kIHdlJ2xsIGV4aXQgaW1tZWRpYXRlbHkgKHVubGVzcyBhIGZpbGUgaXMgaW4gdGhlIGRhdGFUcmFuc2ZlciBhcyB3ZWxsLCB0aGlzIGlzIGJlY2F1c2UgRmlyZWZveCBjb3VsZCByZXByZXNlbnQgdGhlIGZpbGUgYXMgYSBVUkwgYW5kIGEgZmlsZSBvYmplY3QgYXQgdGhlIHNhbWUgdGltZSlcbiAgICAgICAgY29uc3QgbGlua3MgPSBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpO1xuICAgICAgICBpZiAobGlua3MubGVuZ3RoICYmICFoYXNGaWxlcyhkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgICBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpLnRoZW4ocmVzb2x2ZSk7XG4gICAgfSk7XG5cbi8qKlxuICogVGVzdCBpZiBkYXRhdHJhbnNmZXIgaGFzIGZpbGVzXG4gKi9cbmNvbnN0IGhhc0ZpbGVzID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgICBpZiAoZGF0YVRyYW5zZmVyLmZpbGVzKSByZXR1cm4gZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBmaWxlcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5jb25zdCBnZXRGaWxlcyA9IGRhdGFUcmFuc2ZlciA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFuc2ZlciBpdGVtcyBhcyBwcm9taXNlc1xuICAgICAgICBjb25zdCBwcm9taXNlZEZpbGVzID0gKGRhdGFUcmFuc2Zlci5pdGVtcyA/IEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLml0ZW1zKSA6IFtdKVxuXG4gICAgICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pKVxuXG4gICAgICAgICAgICAvLyBtYXAgZWFjaCBpdGVtIHRvIHByb21pc2VcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pKTtcblxuICAgICAgICAvLyBpZiBpcyBlbXB0eSwgc2VlIGlmIHdlIGNhbiBleHRyYWN0IHNvbWUgaW5mbyBmcm9tIHRoZSBmaWxlcyBwcm9wZXJ0eSBhcyBhIGZhbGxiYWNrXG4gICAgICAgIGlmICghcHJvbWlzZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRlc3QgZm9yIGRpcmVjdG9yaWVzIChzaG91bGQgbm90IGJlIGFsbG93ZWQpXG4gICAgICAgICAgICAvLyBVc2UgRmlsZVJlYWRlciwgcHJvYmxlbSBpcyB0aGF0IHRoZSBmaWxlcyBwcm9wZXJ0eSBnZXRzIGxvc3QgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YVRyYW5zZmVyLmZpbGVzID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuZmlsZXMpIDogW10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZWRGaWxlcylcbiAgICAgICAgICAgIC50aGVuKHJldHVybmVkRmlsZUdyb3VwcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBncm91cHNcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybmVkRmlsZUdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaC5hcHBseShmaWxlcywgZ3JvdXApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uZSAoZmlsdGVyIG91dCBlbXB0eSBmaWxlcykhXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUuX3JlbGF0aXZlUGF0aCkgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH0pO1xuXG5jb25zdCBpc0ZpbGVTeXN0ZW1JdGVtID0gaXRlbSA9PiB7XG4gICAgaWYgKGlzRW50cnkoaXRlbSkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBnZXRBc0VudHJ5KGl0ZW0pO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5pc0ZpbGUgfHwgZW50cnkuaXNEaXJlY3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ2ZpbGUnO1xufTtcblxuY29uc3QgZ2V0RmlsZXNGcm9tSXRlbSA9IGl0ZW0gPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGdldEFzRW50cnkoaXRlbSkpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoW2l0ZW0uZ2V0QXNGaWxlKCldKTtcbiAgICB9KTtcblxuY29uc3QgZ2V0RmlsZXNJbkRpcmVjdG9yeSA9IGVudHJ5ID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuXG4gICAgICAgIC8vIHRoZSB0b3RhbCBlbnRyaWVzIHRvIHJlYWRcbiAgICAgICAgbGV0IGRpckNvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgZmlsZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGNvbnN0IHJlc29sdmVJZkRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZUNvdW50ZXIgPT09IDAgJiYgZGlyQ291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoZSByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVhZEVudHJpZXMgPSBkaXJFbnRyeSA9PiB7XG4gICAgICAgICAgICBkaXJDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdG9yeVJlYWRlciA9IGRpckVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAvLyBkaXJlY3RvcmllcyBhcmUgcmV0dXJuZWQgaW4gYmF0Y2hlcywgd2UgbmVlZCB0byBwcm9jZXNzIGFsbCBiYXRjaGVzIGJlZm9yZSB3ZSdyZSBkb25lXG4gICAgICAgICAgICBjb25zdCByZWFkQmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpckNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSByZWFkIG1vcmUgZGlyZWN0b3JpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBhcyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZEZpbGUgPSBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZnVsbFBhdGgpIGNvcnJlY3RlZEZpbGUuX3JlbGF0aXZlUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvcnJlY3RlZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgbmV4dCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ28hXG4gICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICB9KTtcblxuY29uc3QgY29ycmVjdE1pc3NpbmdGaWxlVHlwZSA9IGZpbGUgPT4ge1xuICAgIGlmIChmaWxlLnR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICBjb25zdCBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIGNvbnN0IG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgY29uc3QgdHlwZSA9IGd1ZXNzdGltYXRlTWltZVR5cGUoZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGUubmFtZSkpO1xuICAgIGlmICghdHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgdHlwZSk7XG4gICAgZmlsZS5uYW1lID0gbmFtZTtcbiAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBkYXRlO1xuICAgIHJldHVybiBmaWxlO1xufTtcblxuY29uc3QgaXNEaXJlY3RvcnlFbnRyeSA9IGl0ZW0gPT4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG5cbmNvbnN0IGlzRW50cnkgPSBpdGVtID0+ICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBpdGVtO1xuXG5jb25zdCBnZXRBc0VudHJ5ID0gaXRlbSA9PiBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBsaW5rcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5jb25zdCBnZXRMaW5rcyA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgbGV0IGxpbmtzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gbG9vayBpbiBtZXRhIGRhdGEgcHJvcGVydHlcbiAgICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm9wZSBub3BlIG5vcGUgKHByb2JhYmx5IElFIHRyb3VibGUpXG4gICAgfVxuICAgIHJldHVybiBsaW5rcztcbn07XG5cbmNvbnN0IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgbGV0IGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG5jb25zdCBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgICBsZXQgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbWF0Y2hlc1sxXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuY29uc3QgZHJhZ05Ecm9wT2JzZXJ2ZXJzID0gW107XG5cbmNvbnN0IGV2ZW50UG9zaXRpb24gPSBlID0+ICh7XG4gICAgcGFnZUxlZnQ6IGUucGFnZVgsXG4gICAgcGFnZVRvcDogZS5wYWdlWSxcbiAgICBzY29wZUxlZnQ6IGUub2Zmc2V0WCB8fCBlLmxheWVyWCxcbiAgICBzY29wZVRvcDogZS5vZmZzZXRZIHx8IGUubGF5ZXJZLFxufSk7XG5cbmNvbnN0IGNyZWF0ZURyYWdORHJvcENsaWVudCA9IChlbGVtZW50LCBzY29wZVRvT2JzZXJ2ZSwgZmlsdGVyRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG9ic2VydmVyID0gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoc2NvcGVUb09ic2VydmUpO1xuXG4gICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBmaWx0ZXJFbGVtZW50LFxuICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgb25kcm9wOiAoKSA9PiB7fSxcbiAgICAgICAgb25lbnRlcjogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZzogKCkgPT4ge30sXG4gICAgICAgIG9uZXhpdDogKCkgPT4ge30sXG4gICAgICAgIG9ubG9hZDogKCkgPT4ge30sXG4gICAgICAgIGFsbG93ZHJvcDogKCkgPT4ge30sXG4gICAgfTtcblxuICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgIHJldHVybiBjbGllbnQ7XG59O1xuXG5jb25zdCBnZXREcmFnTkRyb3BPYnNlcnZlciA9IGVsZW1lbnQgPT4ge1xuICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgIGNvbnN0IG9ic2VydmVyID0gZHJhZ05Ecm9wT2JzZXJ2ZXJzLmZpbmQoaXRlbSA9PiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZlciwgZG9lcyBub3QgeWV0IGV4aXN0IGZvciB0aGlzIGVsZW1lbnRcbiAgICBjb25zdCBuZXdPYnNlcnZlciA9IGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpO1xuICAgIGRyYWdORHJvcE9ic2VydmVycy5wdXNoKG5ld09ic2VydmVyKTtcbiAgICByZXR1cm4gbmV3T2JzZXJ2ZXI7XG59O1xuXG5jb25zdCBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGNsaWVudHMgPSBbXTtcblxuICAgIGNvbnN0IHJvdXRlcyA9IHtcbiAgICAgICAgZHJhZ2VudGVyLFxuICAgICAgICBkcmFnb3ZlcixcbiAgICAgICAgZHJhZ2xlYXZlLFxuICAgICAgICBkcm9wLFxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHt9O1xuXG4gICAgZm9yaW4ocm91dGVzLCAoZXZlbnQsIGNyZWF0ZUhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0ge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBhZGRMaXN0ZW5lcjogY2xpZW50ID0+IHtcbiAgICAgICAgICAgIC8vIGFkZCBhcyBjbGllbnRcbiAgICAgICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gcmVtb3ZlTGlzdGVuZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNsaWVudFxuICAgICAgICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1vcmUgY2xpZW50cywgY2xlYW4gdXAgb2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnNwbGljZShkcmFnTkRyb3BPYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcmluKHJvdXRlcywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG9ic2VydmVyO1xufTtcblxuY29uc3QgZWxlbWVudEZyb21Qb2ludCA9IChyb290LCBwb2ludCkgPT4ge1xuICAgIGlmICghKCdlbGVtZW50RnJvbVBvaW50JyBpbiByb290KSkge1xuICAgICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiByb290LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG59O1xuXG5jb25zdCBpc0V2ZW50VGFyZ2V0ID0gKGUsIHRhcmdldCkgPT4ge1xuICAgIC8vIGdldCByb290XG4gICAgY29uc3Qgcm9vdCA9IGdldFJvb3ROb2RlKHRhcmdldCk7XG5cbiAgICAvLyBnZXQgZWxlbWVudCBhdCBwb3NpdGlvblxuICAgIC8vIGlmIHJvb3QgaXMgbm90IGFjdHVhbCBzaGFkb3cgRE9NIGFuZCBkb2VzIG5vdCBoYXZlIGVsZW1lbnRGcm9tUG9pbnQgbWV0aG9kLCB1c2UgdGhlIG9uZSBvbiBkb2N1bWVudFxuICAgIGNvbnN0IGVsZW1lbnRBdFBvc2l0aW9uID0gZWxlbWVudEZyb21Qb2ludChyb290LCB7XG4gICAgICAgIHg6IGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIHk6IGUucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgfSk7XG5cbiAgICAvLyB0ZXN0IGlmIHRhcmdldCBpcyB0aGUgZWxlbWVudCBvciBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbn07XG5cbmxldCBpbml0aWFsVGFyZ2V0ID0gbnVsbDtcblxuY29uc3Qgc2V0RHJvcEVmZmVjdCA9IChkYXRhVHJhbnNmZXIsIGVmZmVjdCkgPT4ge1xuICAgIC8vIGlzIGluIHRyeSBjYXRjaCBhcyBJRTExIHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfSBjYXRjaCAoZSkge31cbn07XG5cbmNvbnN0IGRyYWdlbnRlciA9IChyb290LCBjbGllbnRzKSA9PiBlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpbml0aWFsVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICBjbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBvbmVudGVyIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmNvbnN0IGRyYWdvdmVyID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihpdGVtcyA9PiB7XG4gICAgICAgIGxldCBvdmVyRHJvcFRhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgIGNsaWVudHMuc29tZShjbGllbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXJFbGVtZW50LCBlbGVtZW50LCBvbmVudGVyLCBvbmV4aXQsIG9uZHJhZywgYWxsb3dkcm9wIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnY29weScpO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyB0cmFuc2ZlciBvZiB0aGVzZSBpdGVtc1xuICAgICAgICAgICAgY29uc3QgYWxsb3dzVHJhbnNmZXIgPSBhbGxvd2Ryb3AoaXRlbXMpO1xuXG4gICAgICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBjYW4gYmUgZHJvcHBlZCBvbiBwYWdlXG4gICAgICAgICAgICBpZiAoIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0YXJnZXR0aW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICBpZiAoaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIG92ZXJEcm9wVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGhhZCBubyBwcmV2aW91cyBzdGF0ZSwgbWVhbnMgd2UgYXJlIGVudGVyaW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IG92ZXIgZWxlbWVudCAobm8gbWF0dGVyIGlmIGl0IGFsbG93cyB0aGUgZHJvcCBvciBub3QpXG4gICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ292ZXInO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYWxsb3cgdHJhbnNmZXJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIG9uZHJhZyhldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG92ZXIgYW4gZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIW92ZXJEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUganVzdCBsZWZ0IHRoaXMgY2xpZW50P1xuICAgICAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBkcm9wID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihpdGVtcyA9PiB7XG4gICAgICAgIGNsaWVudHMuZm9yRWFjaChjbGllbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXJFbGVtZW50LCBlbGVtZW50LCBvbmRyb3AsIG9uZXhpdCwgYWxsb3dkcm9wIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZpbHRlcmluZyBvbiBlbGVtZW50IHdlIG5lZWQgdG8gYmUgb3ZlciB0aGUgZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBubyB0cmFuc2ZlciBmb3IgdGhpcyBjbGllbnRcbiAgICAgICAgICAgIGlmICghYWxsb3dkcm9wKGl0ZW1zKSkgcmV0dXJuIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcblxuICAgICAgICAgICAgLy8gd2UgY2FuIGRyb3AgdGhlc2UgaXRlbXMgb24gdGhpcyBjbGllbnRcbiAgICAgICAgICAgIG9uZHJvcChldmVudFBvc2l0aW9uKGUpLCBpdGVtcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuY29uc3QgZHJhZ2xlYXZlID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGlmIChpbml0aWFsVGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xpZW50cy5mb3JFYWNoKGNsaWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25leGl0IH0gPSBjbGllbnQ7XG5cbiAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVIb3BwZXIgPSAoc2NvcGUsIHZhbGlkYXRlSXRlbXMsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBpcyBub3cgaG9wcGVyIHNjb3BlXG4gICAgc2NvcGUuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWhvcHBlcicpO1xuXG4gICAgLy8gc2hvcnRjdXRzXG4gICAgY29uc3QgeyBjYXRjaGVzRHJvcHNPblBhZ2UsIHJlcXVpcmVzRHJvcE9uRWxlbWVudCwgZmlsdGVySXRlbXMgPSBpdGVtcyA9PiBpdGVtcyB9ID0gb3B0aW9ucztcblxuICAgIC8vIGNyZWF0ZSBhIGRuZCBjbGllbnRcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBjYXRjaGVzRHJvcHNPblBhZ2UgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBzY29wZSxcbiAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50XG4gICAgKTtcblxuICAgIC8vIGN1cnJlbnQgY2xpZW50IHN0YXRlXG4gICAgbGV0IGxhc3RTdGF0ZSA9ICcnO1xuICAgIGxldCBjdXJyZW50U3RhdGUgPSAnJztcblxuICAgIC8vIGRldGVybWluZXMgaWYgYSBmaWxlIG1heSBiZSBkcm9wcGVkXG4gICAgY2xpZW50LmFsbG93ZHJvcCA9IGl0ZW1zID0+IHtcbiAgICAgICAgLy8gVE9ETzogaWYgd2UgY2FuLCB0aHJvdyBlcnJvciB0byBpbmRpY2F0ZSB0aGUgaXRlbXMgY2Fubm90IGJ5IGRyb3BwZWRcblxuICAgICAgICByZXR1cm4gdmFsaWRhdGVJdGVtcyhmaWx0ZXJJdGVtcyhpdGVtcykpO1xuICAgIH07XG5cbiAgICBjbGllbnQub25kcm9wID0gKHBvc2l0aW9uLCBpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICAgIGlmICghdmFsaWRhdGVJdGVtcyhmaWx0ZXJlZEl0ZW1zKSkge1xuICAgICAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1kcm9wJztcblxuICAgICAgICBhcGkub25sb2FkKGZpbHRlcmVkSXRlbXMsIHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZHJhZyA9IHBvc2l0aW9uID0+IHtcbiAgICAgICAgYXBpLm9uZHJhZyhwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmVudGVyID0gcG9zaXRpb24gPT4ge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1vdmVyJztcblxuICAgICAgICBhcGkub25kcmFnc3RhcnQocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25leGl0ID0gcG9zaXRpb24gPT4ge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1leGl0JztcblxuICAgICAgICBhcGkub25kcmFnZW5kKHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAhPT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuZGF0YXNldC5ob3BwZXJTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICBsYXN0U3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9ubG9hZDogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZ3N0YXJ0OiAoKSA9PiB7fSxcbiAgICAgICAgb25kcmFnOiAoKSA9PiB7fSxcbiAgICAgICAgb25kcmFnZW5kOiAoKSA9PiB7fSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZGVzdHJveSBjbGllbnRcbiAgICAgICAgICAgIGNsaWVudC5kZXN0cm95KCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5sZXQgbGlzdGVuaW5nID0gZmFsc2U7XG5jb25zdCBsaXN0ZW5lcnMkMSA9IFtdO1xuXG5jb25zdCBoYW5kbGVQYXN0ZSA9IGUgPT4ge1xuICAgIC8vIGlmIGlzIHBhc3RpbmcgaW4gaW5wdXQgb3IgdGV4dGFyZWEgYW5kIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiBhIGZpbGVwb25kIHNjb3BlLCBpZ25vcmVcbiAgICBjb25zdCBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgaXNBY3RpdmVFbGVtZW50RWRpdGFibGUgPVxuICAgICAgICBhY3RpdmVFbCAmJlxuICAgICAgICAoL3RleHRhcmVhfGlucHV0L2kudGVzdChhY3RpdmVFbC5ub2RlTmFtZSkgfHxcbiAgICAgICAgICAgIGFjdGl2ZUVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJyk7XG5cbiAgICBpZiAoaXNBY3RpdmVFbGVtZW50RWRpdGFibGUpIHtcbiAgICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgICBsZXQgaW5TY29wZSA9IGZhbHNlO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGFjdGl2ZUVsO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlcG9uZC0tcm9vdCcpKSB7XG4gICAgICAgICAgICAgICAgaW5TY29wZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblNjb3BlKSByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGUuY2xpcGJvYXJkRGF0YSkudGhlbihmaWxlcyA9PiB7XG4gICAgICAgIC8vIG5vIGZpbGVzIHJlY2VpdmVkXG4gICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICAgIGxpc3RlbmVycyQxLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZmlsZXMpKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGxpc3RlbiA9IGNiID0+IHtcbiAgICAvLyBjYW4ndCBhZGQgdHdpY2VcbiAgICBpZiAobGlzdGVuZXJzJDEuaW5jbHVkZXMoY2IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZGQgaW5pdGlhbCBsaXN0ZW5lclxuICAgIGxpc3RlbmVycyQxLnB1c2goY2IpO1xuXG4gICAgLy8gc2V0dXAgcGFzdGUgbGlzdGVuZXIgZm9yIGVudGlyZSBwYWdlXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGhhbmRsZVBhc3RlKTtcbn07XG5cbmNvbnN0IHVubGlzdGVuID0gbGlzdGVuZXIgPT4ge1xuICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAvLyBjbGVhbiB1cFxuICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgICAgIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVBhc3RlciA9ICgpID0+IHtcbiAgICBjb25zdCBjYiA9IGZpbGVzID0+IHtcbiAgICAgICAgYXBpLm9ubG9hZChmaWxlcyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvbmxvYWQ6ICgpID0+IHt9LFxuICAgIH07XG5cbiAgICBsaXN0ZW4oY2IpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSRkID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIHJvb3QuZWxlbWVudC5pZCA9IGBmaWxlcG9uZC0tYXNzaXN0YW50LSR7cHJvcHMuaWR9YDtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG59O1xuXG5sZXQgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbmxldCBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBudWxsO1xuXG5jb25zdCBmaWxlbmFtZXMgPSBbXTtcblxuY29uc3QgYXNzaXN0ID0gKHJvb3QsIG1lc3NhZ2UpID0+IHtcbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xufTtcblxuY29uc3QgY2xlYXIkMSA9IHJvb3QgPT4ge1xuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xufTtcblxuY29uc3QgbGlzdE1vZGlmaWVkID0gKHJvb3QsIGZpbGVuYW1lLCBsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHRvdGFsID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgYXNzaXN0KFxuICAgICAgICByb290LFxuICAgICAgICBgJHtsYWJlbH0gJHtmaWxlbmFtZX0sICR7dG90YWx9ICR7XG4gICAgICAgICAgICB0b3RhbCA9PT0gMVxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfU0lOR1VMQVInKVxuICAgICAgICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfUExVUkFMJylcbiAgICAgICAgfWBcbiAgICApO1xuXG4gICAgLy8gY2xlYXIgZ3JvdXAgYWZ0ZXIgc2V0IGFtb3VudCBvZiB0aW1lIHNvIHRoZSBzdGF0dXMgaXMgbm90IHJlYWQgdHdpY2VcbiAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0KTtcbiAgICBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYXIkMShyb290KTtcbiAgICB9LCAxNTAwKTtcbn07XG5cbmNvbnN0IGlzVXNpbmdGaWxlUG9uZCA9IHJvb3QgPT4gcm9vdC5lbGVtZW50LnBhcmVudE5vZGUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cbmNvbnN0IGl0ZW1BZGRlZCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgZmlsZW5hbWVzLnB1c2goaXRlbS5maWxlbmFtZSk7XG5cbiAgICBjbGVhclRpbWVvdXQoYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICBhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGlzdE1vZGlmaWVkKHJvb3QsIGZpbGVuYW1lcy5qb2luKCcsICcpLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9BRERFRCcpKTtcbiAgICAgICAgZmlsZW5hbWVzLmxlbmd0aCA9IDA7XG4gICAgfSwgNzUwKTtcbn07XG5cbmNvbnN0IGl0ZW1SZW1vdmVkID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbSA9IGFjdGlvbi5pdGVtO1xuICAgIGxpc3RNb2RpZmllZChyb290LCBpdGVtLmZpbGVuYW1lLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9SRU1PVkVEJykpO1xufTtcblxuY29uc3QgaXRlbVByb2Nlc3NlZCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgY29uc3QgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgYCR7ZmlsZW5hbWV9ICR7bGFiZWx9YCk7XG59O1xuXG5jb25zdCBpdGVtUHJvY2Vzc2VkVW5kbyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgY29uc3QgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgIGFzc2lzdChyb290LCBgJHtmaWxlbmFtZX0gJHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IGl0ZW1FcnJvciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICBhc3Npc3Qocm9vdCwgYCR7YWN0aW9uLnN0YXR1cy5tYWlufSAke2ZpbGVuYW1lfSAke2FjdGlvbi5zdGF0dXMuc3VifWApO1xufTtcblxuY29uc3QgYXNzaXN0YW50ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkZCxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogaXRlbUFkZGVkLFxuICAgICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBpdGVtUHJvY2Vzc2VkLFxuXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiBpdGVtRXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBpdGVtRXJyb3IsXG4gICAgfSksXG4gICAgdGFnOiAnc3BhbicsXG4gICAgbmFtZTogJ2Fzc2lzdGFudCcsXG59KTtcblxuY29uc3QgdG9DYW1lbHMgPSAoc3RyaW5nLCBzZXBhcmF0b3IgPSAnLScpID0+XG4gICAgc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtzZXBhcmF0b3J9LmAsICdnJyksIHN1YiA9PiBzdWIuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCkpO1xuXG5jb25zdCBkZWJvdW5jZSA9IChmdW5jLCBpbnRlcnZhbCA9IDE2LCBpbW1pZGlhdGVPbmx5ID0gdHJ1ZSkgPT4ge1xuICAgIGxldCBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgdGltZW91dCA9IG51bGw7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgIGNvbnN0IGRpc3QgPSBEYXRlLm5vdygpIC0gbGFzdDtcblxuICAgICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGlzdCA8IGludGVydmFsKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gaW50ZXJ2YWwgYW5kIGRpc3RcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYW4gYWRkaXRpb25hbCA2bXMgYmVmb3JlIGNhbGxpbmcgdGhlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgaWYgKCFpbW1pZGlhdGVPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGludGVydmFsIC0gZGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBnbyFcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgTUFYX0ZJTEVTX0xJTUlUID0gMTAwMDAwMDtcblxuY29uc3QgcHJldmVudCA9IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5jb25zdCBjcmVhdGUkZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBBZGQgaWRcbiAgICBjb25zdCBpZCA9IHJvb3QucXVlcnkoJ0dFVF9JRCcpO1xuICAgIGlmIChpZCkge1xuICAgICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgY29uc3QgY2xhc3NOYW1lID0gcm9vdC5xdWVyeSgnR0VUX0NMQVNTX05BTUUnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLmxlbmd0aClcbiAgICAgICAgICAgIC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmllbGQgbGFiZWxcbiAgICByb290LnJlZi5sYWJlbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhkcm9wTGFiZWwsIHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgIGNhcHRpb246IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JRExFJyksXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIExpc3Qgb2YgaXRlbXNcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdFNjcm9sbGVyLCB7IHRyYW5zbGF0ZVk6IG51bGwgfSkpO1xuXG4gICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ3BhbmVsLXJvb3QnIH0pKTtcblxuICAgIC8vIEFzc2lzdGFudCBub3RpZmllcyBhc3Npc3RpdmUgdGVjaCB3aGVuIGNvbnRlbnQgY2hhbmdlc1xuICAgIHJvb3QucmVmLmFzc2lzdGFudCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGFzc2lzdGFudCwgeyAuLi5wcm9wcyB9KSk7XG5cbiAgICAvLyBEYXRhXG4gICAgcm9vdC5yZWYuZGF0YSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIHsgLi4ucHJvcHMgfSkpO1xuXG4gICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgLy8gRE9DVFlQRSBuZWVkcyB0byBiZSBzZXQgZm9yIHRoaXMgdG8gd29ya1xuICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcblxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgIC8vIGFwcGx5IGluaXRpYWwgc3R5bGUgcHJvcGVydGllc1xuICAgIHJvb3QucXVlcnkoJ0dFVF9TVFlMRVMnKVxuICAgICAgICAuZmlsdGVyKHN0eWxlID0+ICFpc0VtcHR5KHN0eWxlLnZhbHVlKSlcbiAgICAgICAgLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB3aWR0aCBjaGFuZ2VkXG4gICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IG51bGw7XG4gICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRVNJWkVfUk9PVCcpO1xuICAgIH0sIDI1MCk7XG5cbiAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gbnVsbDtcbiAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICBjb25zdCBjYW5Ib3ZlciA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogZmluZSkgYW5kIChob3ZlcjogaG92ZXIpJykubWF0Y2hlcztcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93O1xuICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpICYmIGhhc1BvaW50ZXJFdmVudHMgJiYgIWNhbkhvdmVyKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNyZWRpdHNcbiAgICBjb25zdCBjcmVkaXRzID0gcm9vdC5xdWVyeSgnR0VUX0NSRURJVFMnKTtcbiAgICBjb25zdCBoYXNDcmVkaXRzID0gY3JlZGl0cy5sZW5ndGggPT09IDI7XG4gICAgaWYgKGhhc0NyZWRpdHMpIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgZnJhZy5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWNyZWRpdHMnO1xuICAgICAgICBmcmFnLmhyZWYgPSBjcmVkaXRzWzBdO1xuICAgICAgICBmcmFnLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIGZyYWcudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIGZyYWcucmVsID0gJ25vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3cnO1xuICAgICAgICBmcmFnLnRleHRDb250ZW50ID0gY3JlZGl0c1sxXTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICByb290LnJlZi5jcmVkaXRzID0gZnJhZztcbiAgICB9XG59O1xuXG5jb25zdCB3cml0ZSQ5ID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSkgPT4ge1xuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQ1KHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSk7XG5cbiAgICAvLyBhcHBseSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiAvXkRJRF9TRVRfU1RZTEVfLy50ZXN0KGFjdGlvbi50eXBlKSlcbiAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gIWlzRW1wdHkoYWN0aW9uLmRhdGEudmFsdWUpKVxuICAgICAgICAubWFwKCh7IHR5cGUsIGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxzKHR5cGUuc3Vic3RyaW5nKDgpLnRvTG93ZXJDYXNlKCksICdfJyk7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICByb290LmludmFsaWRhdGVMYXlvdXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICByb290LnJlZi53aWR0aFVwZGF0ZWQoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYm94IGJvdW5kcywgd2UgZG8gdGhpcyBvbmx5IG9uY2VcbiAgICBsZXQgYm91bmRzID0gcm9vdC5yZWYuYm91bmRzO1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcyA9IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KTtcblxuICAgICAgICAvLyBkZXN0cm95IG1lYXN1cmUgZWxlbWVudFxuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICBjb25zdCB7IGhvcHBlciwgbGFiZWwsIGxpc3QsIHBhbmVsIH0gPSByb290LnJlZjtcblxuICAgIC8vIHNldHMgY29ycmVjdCBzdGF0ZSB0byBob3BwZXIgc2NvcGVcbiAgICBpZiAoaG9wcGVyKSB7XG4gICAgICAgIGhvcHBlci51cGRhdGVIb3BwZXJTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIGJvb2wgdG8gaW5kaWNhdGUgaWYgd2UncmUgZnVsbCBvciBub3RcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICBjb25zdCBpc011bHRpSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICBjb25zdCBtYXhJdGVtcyA9IGlzTXVsdGlJdGVtID8gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpIHx8IE1BWF9GSUxFU19MSU1JVCA6IDE7XG4gICAgY29uc3QgYXRNYXhDYXBhY2l0eSA9IHRvdGFsSXRlbXMgPT09IG1heEl0ZW1zO1xuXG4gICAgLy8gYWN0aW9uIHVzZWQgdG8gYWRkIGl0ZW1cbiAgICBjb25zdCBhZGRBY3Rpb24gPSBhY3Rpb25zLmZpbmQoYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnRElEX0FERF9JVEVNJyk7XG5cbiAgICAvLyBpZiByZWFjaGVkIG1heCBjYXBhY2l0eSBhbmQgd2UndmUganVzdCByZWFjaGVkIGl0XG4gICAgaWYgKGF0TWF4Q2FwYWNpdHkgJiYgYWRkQWN0aW9uKSB7XG4gICAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0eXBlXG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uTWV0aG9kID0gYWRkQWN0aW9uLmRhdGEuaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICAgICAgLy8gaGlkZSBsYWJlbFxuICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMDtcblxuICAgICAgICBpZiAoaXNNdWx0aUl0ZW0pIHtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSA0MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDMwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghYXRNYXhDYXBhY2l0eSkge1xuICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMTtcbiAgICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RJdGVtTWFyZ2luID0gY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4ocm9vdCk7XG5cbiAgICBjb25zdCBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gbGFiZWwucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICBjb25zdCBjdXJyZW50TGFiZWxIZWlnaHQgPSAhaXNNdWx0aUl0ZW0gfHwgYXRNYXhDYXBhY2l0eSA/IDAgOiBsYWJlbEhlaWdodDtcblxuICAgIGNvbnN0IGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICBjb25zdCBsaXN0TWFyZ2luQm90dG9tID0gdG90YWxJdGVtcyA9PT0gMCA/IDAgOiBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b207XG5cbiAgICBjb25zdCB2aXN1YWxIZWlnaHQgPSBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC52aXN1YWwgKyBsaXN0TWFyZ2luQm90dG9tO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LmJvdW5kcyArIGxpc3RNYXJnaW5Cb3R0b207XG5cbiAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgbGlzdC50cmFuc2xhdGVZID1cbiAgICAgICAgTWF0aC5tYXgoMCwgY3VycmVudExhYmVsSGVpZ2h0IC0gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wKSAtIGxpc3RJdGVtTWFyZ2luLnRvcDtcblxuICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAvLyBmaXhlZCBhc3BlY3QgcmF0aW9cblxuICAgICAgICAvLyBjYWxjdWxhdGUgaGVpZ2h0IGJhc2VkIG9uIHdpZHRoXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG5cbiAgICAgICAgLy8gY2xlYXIgaGlzdG9yeSBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvICE9PSByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1lbWJlciB0aGlzIHdpZHRoXG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSByb290LnJlZi51cGRhdGVIaXN0b3J5O1xuICAgICAgICBoaXN0b3J5LnB1c2god2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IE1BWF9CT1VOQ0VTID0gMjtcbiAgICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID4gTUFYX0JPVU5DRVMgKiAyKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gaGlzdG9yeS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsIC0gMTA7XG4gICAgICAgICAgICBsZXQgYm91bmNlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbDsgaSA+PSBib3R0b207IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChoaXN0b3J5W2ldID09PSBoaXN0b3J5W2kgLSAyXSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuY2VzKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5jZXMgPj0gTUFYX0JPVU5DRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9udCBhZGp1c3QgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsIHNvIGl0IGFkaGVyZXMgdG8gYXNwZWN0IHJhdGlvXG4gICAgICAgIHBhbmVsLnNjYWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHBhbmVsLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgIGNvbnN0IGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgaGVpZ2h0IC1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChib3VuZHMuZml4ZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gZml4ZWQgaGVpZ2h0XG5cbiAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbFxuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgY29uc3QgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0XG4gICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBuZWVkIHRvIHNldCBjb250YWluZXIgYm91bmRzIGFzIHRoZXNlIGFyZSBoYW5kbGVzIGJ5IENTUyBmaXhlZCBoZWlnaHRcbiAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gbWF4LWhlaWdodFxuXG4gICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICBjb25zdCBpc0NhcHBlZEhlaWdodCA9IHZpc3VhbEhlaWdodCA+PSBib3VuZHMuY2FwcGVkSGVpZ2h0O1xuICAgICAgICBjb25zdCBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICAgIHBhbmVsLnNjYWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgcGFuZWwuaGVpZ2h0ID0gaXNDYXBwZWRIZWlnaHRcbiAgICAgICAgICAgID8gcGFuZWxIZWlnaHRcbiAgICAgICAgICAgIDogcGFuZWxIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICBjb25zdCBsaXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgIHBhbmVsSGVpZ2h0IC1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgIC8vIHNldCBsaXN0IGhlaWdodCAoaWYgaXMgb3ZlcmZsb3dpbmcpXG4gICAgICAgIGlmICh2aXN1YWxIZWlnaHQgPiBib3VuZHMuY2FwcGVkSGVpZ2h0ICYmIGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IGxpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICByb290LmhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICAgICAgYm91bmRzLmNhcHBlZEhlaWdodCxcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCAtIGxpc3RJdGVtTWFyZ2luLnRvcCAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICBjb25zdCBpdGVtTWFyZ2luID0gdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgIHBhbmVsLmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCB2aXN1YWxIZWlnaHQgLSBpdGVtTWFyZ2luKTtcblxuICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgYm91bmRzSGVpZ2h0IC0gaXRlbU1hcmdpbik7XG4gICAgfVxuXG4gICAgLy8gbW92ZSBjcmVkaXRzIHRvIGJvdHRvbVxuICAgIGlmIChyb290LnJlZi5jcmVkaXRzICYmIHBhbmVsLmhlaWdodEN1cnJlbnQpXG4gICAgICAgIHJvb3QucmVmLmNyZWRpdHMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHtwYW5lbC5oZWlnaHRDdXJyZW50fXB4KWA7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF0uY2hpbGRWaWV3c1swXTtcbiAgICByZXR1cm4gaXRlbVxuICAgICAgICA/IHtcbiAgICAgICAgICAgICAgdG9wOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIGJvdHRvbTogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIH07XG59O1xuXG5jb25zdCBjYWxjdWxhdGVMaXN0SGVpZ2h0ID0gcm9vdCA9PiB7XG4gICAgbGV0IHZpc3VhbCA9IDA7XG4gICAgbGV0IGJvdW5kcyA9IDA7XG5cbiAgICAvLyBnZXQgZmlsZSBsaXN0IHJlZmVyZW5jZVxuICAgIGNvbnN0IHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgIGNvbnN0IGl0ZW1MaXN0ID0gc2Nyb2xsTGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IGl0ZW1MaXN0LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAubWFwKGl0ZW0gPT4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGl0ZW0uaWQpKVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAvLyBubyBjaGlsZHJlbiwgZG9uZSFcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4geyB2aXN1YWwsIGJvdW5kcyB9O1xuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gaXRlbUxpc3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgIGNvbnN0IGRyYWdJbmRleCA9IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCBzY3JvbGxMaXN0LmRyYWdDb29yZGluYXRlcyk7XG5cbiAgICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG5cbiAgICBjb25zdCBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICBjb25zdCBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuXG4gICAgY29uc3QgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICBjb25zdCBuZXdJdGVtID0gdHlwZW9mIGRyYWdJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZHJhZ0luZGV4ID49IDAgPyAxIDogMDtcbiAgICBjb25zdCByZW1vdmVkSXRlbSA9IGNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NSlcbiAgICAgICAgPyAtMVxuICAgICAgICA6IDA7XG4gICAgY29uc3QgdmVydGljYWxJdGVtQ291bnQgPSBjaGlsZHJlbi5sZW5ndGggKyBuZXdJdGVtICsgcmVtb3ZlZEl0ZW07XG4gICAgY29uc3QgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICAgICAgYm91bmRzICs9IGhlaWdodDtcbiAgICAgICAgICAgIHZpc3VhbCArPSBoZWlnaHQgKiBpdGVtLm9wYWNpdHk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBncmlkXG4gICAgZWxzZSB7XG4gICAgICAgIGJvdW5kcyA9IE1hdGguY2VpbCh2ZXJ0aWNhbEl0ZW1Db3VudCAvIGl0ZW1zUGVyUm93KSAqIGl0ZW1IZWlnaHQ7XG4gICAgICAgIHZpc3VhbCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aXN1YWwsIGJvdW5kcyB9O1xufTtcblxuY29uc3QgY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0ID0gcm9vdCA9PiB7XG4gICAgY29uc3QgaGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZUhlaWdodCB8fCBudWxsO1xuICAgIGNvbnN0IGNhcHBlZEhlaWdodCA9IHBhcnNlSW50KHJvb3Quc3R5bGUubWF4SGVpZ2h0LCAxMCkgfHwgbnVsbDtcbiAgICBjb25zdCBmaXhlZEhlaWdodCA9IGhlaWdodCA9PT0gMCA/IG51bGwgOiBoZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjYXBwZWRIZWlnaHQsXG4gICAgICAgIGZpeGVkSGVpZ2h0LFxuICAgIH07XG59O1xuXG5jb25zdCBleGNlZWRzTWF4RmlsZXMgPSAocm9vdCwgaXRlbXMpID0+IHtcbiAgICBjb25zdCBhbGxvd1JlcGxhY2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVQTEFDRScpO1xuICAgIGNvbnN0IGFsbG93TXVsdGlwbGUgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgbGV0IG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgLy8gdG90YWwgYW1vdW50IG9mIGl0ZW1zIGJlaW5nIGRyYWdnZWRcbiAgICBjb25zdCB0b3RhbEJyb3dzZUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgLy8gaWYgZG9lcyBub3QgYWxsb3cgbXVsdGlwbGUgaXRlbXMgYW5kIGRyYWdnaW5nIG1vcmUgdGhhbiBvbmUgaXRlbVxuICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiB0b3RhbEJyb3dzZUl0ZW1zID4gMSkge1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfVEhST1dfTUFYX0ZJTEVTJywge1xuICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgIG1heEl0ZW1zID0gYWxsb3dNdWx0aXBsZSA/IG1heEl0ZW1zIDogMTtcblxuICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiBhbGxvd1JlcGxhY2UpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgaXRlbSwgc28gdGhlcmUgaXMgcm9vbSB0byByZXBsYWNlIG9yIGFkZCBhbiBpdGVtXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20/XG4gICAgY29uc3QgaGFzTWF4SXRlbXMgPSBpc0ludChtYXhJdGVtcyk7XG4gICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgIHNvdXJjZTogaXRlbXMsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBnZXREcmFnSW5kZXggPSAobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgaXRlbUxpc3QgPSBsaXN0LmNoaWxkVmlld3NbMF07XG4gICAgcmV0dXJuIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCB7XG4gICAgICAgIGxlZnQ6IHBvc2l0aW9uLnNjb3BlTGVmdCAtIGl0ZW1MaXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgICB0b3A6XG4gICAgICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAobGlzdC5yZWN0Lm91dGVyLnRvcCArIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCArIGxpc3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcCksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbGUgZHJvcCBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IHRvZ2dsZURyb3AgPSByb290ID0+IHtcbiAgICBjb25zdCBpc0FsbG93ZWQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRFJPUCcpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgY29uc3QgaG9wcGVyID0gY3JlYXRlSG9wcGVyKFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgaXRlbXMgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHF1aWNrIHZhbGlkYXRpb24gb2YgZHJvcHBlZCBpdGVtc1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZURyb3BGaWxlID0gcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fCAoKCkgPT4gdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhbGwgaXRlbXMgc2hvdWxkIGJlIHZhbGlkYXRlZCBieSBhbGwgZmlsdGVycyBhcyB2YWxpZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRyb3BWYWxpZGF0aW9uID0gcm9vdC5xdWVyeSgnR0VUX0RST1BfVkFMSURBVElPTicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wVmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGl0ZW1zLmV2ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0FMTE9XX0hPUFBFUl9JVEVNJywgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByb290LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCA9PT0gdHJ1ZSkgJiYgYmVmb3JlRHJvcEZpbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmlsdGVySXRlbXM6IGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlZEZpbGVzID0gcm9vdC5xdWVyeSgnR0VUX0lHTk9SRURfRklMRVMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYXRjaGVzRHJvcHNPblBhZ2U6IHJvb3QucXVlcnkoJ0dFVF9EUk9QX09OX1BBR0UnKSxcbiAgICAgICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQ6IHJvb3QucXVlcnkoJ0dFVF9EUk9QX09OX0VMRU1FTlQnKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBob3BwZXIub25sb2FkID0gKGl0ZW1zLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGl0ZW0gY2hpbGRyZW4gZWxlbWVudHMgYW5kIHNvcnQgYmFzZWQgb24gbGlzdCBzb3J0XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IHZpc2libGVDaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmlkID09PSBpdGVtLmlkKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4ocXVldWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gZ29cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldERyYWdJbmRleChyb290LnJlZi5saXN0LCBjaGlsZHJlbiwgcG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuRFJPUCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJPUCcsIHsgcG9zaXRpb24gfSk7XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9FTkRfRFJBRycsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaG9wcGVyLm9uZHJhZ3N0YXJ0ID0gcG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1NUQVJUX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhvcHBlci5vbmRyYWcgPSBkZWJvdW5jZShwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBRycsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhvcHBlci5vbmRyYWdlbmQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QucmVmLmhvcHBlciA9IGhvcHBlcjtcblxuICAgICAgICByb290LnJlZi5kcmlwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZHJpcCkpO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHJvb3QucmVmLmhvcHBlciA9IG51bGw7XG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYnJvd3NlIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgdG9nZ2xlQnJvd3NlID0gKHJvb3QsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5icm93c2VyKSB7XG4gICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJyb3dzZXIsIHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBvbmxvYWQ6IGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiByb290LmRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHF1ZXVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5icm93c2VyKTtcbiAgICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IHRvZ2dsZVBhc3RlID0gcm9vdCA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BBU1RFJyk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBjcmVhdGVQYXN0ZXIoKTtcbiAgICAgICAgcm9vdC5yZWYucGFzdGVyLm9ubG9hZCA9IGl0ZW1zID0+IHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4ocXVldWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgIHJvb3QucmVmLnBhc3Rlci5kZXN0cm95KCk7XG4gICAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb25zXG4gKi9cbmNvbnN0IHJvdXRlJDUgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9BTExPV19CUk9XU0U6ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICB9LFxuICAgIERJRF9TRVRfQUxMT1dfRFJPUDogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0FMTE9XX1BBU1RFOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0RJU0FCTEVEOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgICB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpO1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQ7IDw9IHRoaXMgZG9lcyBub3Qgd29yayBvbiBpT1MgMTBcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuY29uc3Qgcm9vdCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdyb290JyxcbiAgICByZWFkOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgPSByb290LnJlZi5tZWFzdXJlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkZSxcbiAgICB3cml0ZTogd3JpdGUkOSxcbiAgICBkZXN0cm95OiAoeyByb290IH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIHN0eWxlczogWydoZWlnaHQnXSxcbiAgICB9LFxufSk7XG5cbi8vIGNyZWF0ZXMgdGhlIGFwcFxuY29uc3QgY3JlYXRlQXBwID0gKGluaXRpYWxPcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBsZXQgZWxlbWVudFxuICAgIGxldCBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgICAgY3JlYXRlSW5pdGlhbFN0YXRlKGRlZmF1bHRPcHRpb25zKSxcblxuICAgICAgICAvLyBxdWVyaWVzXG4gICAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgICAgLy8gYWN0aW9uIGhhbmRsZXJzXG4gICAgICAgIFthY3Rpb25zLCBjcmVhdGVPcHRpb25BY3Rpb25zKGRlZmF1bHRPcHRpb25zKV1cbiAgICApO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgb3B0aW9uc1xuICAgIHN0b3JlLmRpc3BhdGNoKCdTRVRfT1BUSU9OUycsIHsgb3B0aW9uczogaW5pdGlhbE9wdGlvbnMgfSk7XG5cbiAgICAvLyBraWNrIHRocmVhZCBpZiB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgICBjb25zdCB2aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikgcmV0dXJuO1xuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICBsZXQgcmVzaXplRG9uZVRpbWVyID0gbnVsbDtcbiAgICBsZXQgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIGxldCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgbGV0IGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplRG9uZVRpbWVyKTtcbiAgICAgICAgcmVzaXplRG9uZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcblxuICAgIC8vIHJlbmRlciBpbml0aWFsIHZpZXdcbiAgICBjb25zdCB2aWV3ID0gcm9vdChzdG9yZSwgeyBpZDogZ2V0VW5pcXVlSWQoKSB9KTtcblxuICAgIC8vXG4gICAgLy8gUFJJVkFURSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgbGV0IGlzUmVzdGluZyA9IGZhbHNlO1xuICAgIGxldCBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgcmVhZFdyaXRlQXBpID0ge1xuICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGZyb20gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlYWQ6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVzaXppbmcgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICAgICAgaWYgKGlzUmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBjdXJyZW50V2luZG93V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ICYmIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RBUlRfUkVTSVpFJyk7XG4gICAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmdIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuICYmIGlzUmVzdGluZykge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gcmVhZCB2aWV3IGRhdGFcbiAgICAgICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAgICAgLy8gaWYgaXMgaGlkZGVuIHdlIG5lZWQgdG8ga25vdyBzbyB3ZSBleGl0IHJlc3QgbW9kZSB3aGVuIHJldmVhbGVkXG4gICAgICAgICAgICBpc0hpZGRlbiA9IHZpZXcucmVjdC5lbGVtZW50LmhpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRvIGRvbSAobmV2ZXIgY2FsbCBtYW51YWxseSlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF93cml0ZTogdHMgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGFsbCBhY3Rpb25zIGZyb20gc3RvcmVcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBzdG9yZVxuICAgICAgICAgICAgICAgIC5wcm9jZXNzQWN0aW9uUXVldWUoKVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiAhL15TRVRfLy50ZXN0KGFjdGlvbi50eXBlKSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHdhcyBpZGxpbmcgYW5kIG5vIGFjdGlvbnMgc3RvcCBoZXJlXG4gICAgICAgICAgICBpZiAoaXNSZXN0aW5nICYmICFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgIHJvdXRlQWN0aW9uc1RvRXZlbnRzKGFjdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdcbiAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAgICAgLy8gd2lsbCBjbGVhbiB1cCBhbGwgYXJjaGl2ZWQgaXRlbXNcbiAgICAgICAgICAgIHJlbW92ZVJlbGVhc2VkSXRlbXMoc3RvcmUucXVlcnkoJ0dFVF9JVEVNUycpKTtcblxuICAgICAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICAgICAgaWYgKGlzUmVzdGluZykge1xuICAgICAgICAgICAgICAgIHN0b3JlLnByb2Nlc3NEaXNwYXRjaFF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gRVhQT1NFIEVWRU5UUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICBjb25zdCBjcmVhdGVFdmVudCA9IG5hbWUgPT4gZGF0YSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IHsgLi4uZGF0YS5lcnJvciB9IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgZXZlbnQuc3RhdHVzID0geyAuLi5kYXRhLnN0YXR1cyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgICAgICAgZXZlbnQub3V0cHV0ID0gZGF0YS5maWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzb3VyY2UgaXMgYXZhaWxhYmxlLCBlbHNlIGFkZCBpdGVtIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmIChkYXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgZXZlbnQuZmlsZSA9IGRhdGEuc291cmNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaXRlbSB8fCBkYXRhLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YS5pdGVtID8gZGF0YS5pdGVtIDogc3RvcmUucXVlcnkoJ0dFVF9JVEVNJywgZGF0YS5pZCk7XG4gICAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwIGFsbCBpdGVtcyBpbiBhIHBvc3NpYmxlIGl0ZW1zIGFycmF5XG4gICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICBldmVudC5pdGVtcyA9IGRhdGEuaXRlbXMubWFwKGNyZWF0ZUl0ZW1BUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgIGlmICgvcHJvZ3Jlc3MvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByb2dyZXNzID0gZGF0YS5wcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ29yaWdpbicpICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ3RhcmdldCcpKSB7XG4gICAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBjb25zdCBldmVudFJvdXRlcyA9IHtcbiAgICAgICAgRElEX0RFU1RST1k6IGNyZWF0ZUV2ZW50KCdkZXN0cm95JyksXG5cbiAgICAgICAgRElEX0lOSVQ6IGNyZWF0ZUV2ZW50KCdpbml0JyksXG5cbiAgICAgICAgRElEX1RIUk9XX01BWF9GSUxFUzogY3JlYXRlRXZlbnQoJ3dhcm5pbmcnKSxcblxuICAgICAgICBESURfSU5JVF9JVEVNOiBjcmVhdGVFdmVudCgnaW5pdGZpbGUnKSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogY3JlYXRlRXZlbnQoJ2FkZGZpbGVzdGFydCcpLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ2FkZGZpbGVwcm9ncmVzcycpLFxuICAgICAgICBESURfTE9BRF9JVEVNOiBjcmVhdGVFdmVudCgnYWRkZmlsZScpLFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgnYWRkZmlsZScpXSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKV0sXG5cbiAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBjcmVhdGVFdmVudCgncHJlcGFyZWZpbGUnKSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzdGFydCcpLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlYWJvcnQnKSxcbiAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlJyksXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzJyksXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVyZXZlcnQnKSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpXSxcblxuICAgICAgICBESURfUkVNT1ZFX0lURU06IGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyksXG5cbiAgICAgICAgRElEX1VQREFURV9JVEVNUzogY3JlYXRlRXZlbnQoJ3VwZGF0ZWZpbGVzJyksXG5cbiAgICAgICAgRElEX0FDVElWQVRFX0lURU06IGNyZWF0ZUV2ZW50KCdhY3RpdmF0ZWZpbGUnKSxcblxuICAgICAgICBESURfUkVPUkRFUl9JVEVNUzogY3JlYXRlRXZlbnQoJ3Jlb3JkZXJmaWxlcycpLFxuICAgIH07XG5cbiAgICBjb25zdCBleHBvc2VFdmVudCA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHsgcG9uZDogZXhwb3J0cywgLi4uZXZlbnQgfTtcbiAgICAgICAgZGVsZXRlIGRldGFpbC50eXBlO1xuICAgICAgICB2aWV3LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChgRmlsZVBvbmQ6JHtldmVudC50eXBlfWAsIHtcbiAgICAgICAgICAgICAgICAvLyBldmVudCBpbmZvXG4gICAgICAgICAgICAgICAgZGV0YWlsLFxuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgYmVoYXZpb3VyXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLCAvLyB0cmlnZ2VycyBsaXN0ZW5lcnMgb3V0c2lkZSBvZiBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBldmVudCBvYmplY3QgdG8gcGFyYW1zIHVzZWQgZm9yIGBvbigpYCBldmVudCBoYW5kbGVycyBhbmQgY2FsbGJhY2tzIGBvbmluaXQoKWBcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG5cbiAgICAgICAgLy8gaWYgaXMgcG9zc2libGUgZXJyb3IgZXZlbnQsIG1ha2UgaXQgdGhlIGZpcnN0IHBhcmFtXG4gICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ2ZpbGUnKSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgb3RoZXIgcHJvcHNcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbJ3R5cGUnLCAnZXJyb3InLCAnZmlsZSddO1xuICAgICAgICBPYmplY3Qua2V5cyhldmVudClcbiAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+ICFmaWx0ZXJlZC5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHBhcmFtcy5wdXNoKGV2ZW50W2tleV0pKTtcblxuICAgICAgICAvLyBvbih0eXBlLCAoKSA9PiB7IH0pXG4gICAgICAgIGV4cG9ydHMuZmlyZShldmVudC50eXBlLCAuLi5wYXJhbXMpO1xuXG4gICAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBzdG9yZS5xdWVyeShgR0VUX09OJHtldmVudC50eXBlLnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgcm91dGVBY3Rpb25zVG9FdmVudHMgPSBhY3Rpb25zID0+IHtcbiAgICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiBldmVudFJvdXRlc1thY3Rpb24udHlwZV0pXG4gICAgICAgICAgICAuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyb3V0ZXMpID8gcm91dGVzIDogW3JvdXRlc10pLmZvckVhY2gocm91dGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdESURfSU5JVF9JVEVNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZUV2ZW50KHJvdXRlKGFjdGlvbi5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gUFVCTElDIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICBjb25zdCBzZXRPcHRpb25zID0gb3B0aW9ucyA9PiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnMgfSk7XG5cbiAgICBjb25zdCBnZXRGaWxlID0gcXVlcnkgPT4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcblxuICAgIGNvbnN0IHByZXBhcmVGaWxlID0gcXVlcnkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUkVQQVJFJywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBhZGRGaWxlID0gKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSA9PlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhZGRGaWxlcyhbeyBzb3VyY2UsIG9wdGlvbnMgfV0sIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggfSlcbiAgICAgICAgICAgICAgICAudGhlbihpdGVtcyA9PiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBpc0ZpbGVQb25kRmlsZSA9IG9iaiA9PiBvYmouZmlsZSAmJiBvYmouaWQ7XG5cbiAgICBjb25zdCByZW1vdmVGaWxlID0gKHF1ZXJ5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIC8vIGlmIG9ubHkgcGFzc2VkIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgIWlzRmlsZVBvbmRGaWxlKHF1ZXJ5KSAmJiAhb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHF1ZXJ5O1xuICAgICAgICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IC4uLm9wdGlvbnMsIHF1ZXJ5IH0pO1xuXG4gICAgICAgIC8vIHNlZSBpZiBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSkgPT09IG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZEZpbGVzID0gKC4uLmFyZ3MpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgYSBzb3VyY2VzIGFycmF5XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHBhc3NlZCBzb3VyY2VzIGFzIGFyZ3VtZW50cywgbGFzdCBvbmUgbWlnaHQgYmUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJndW1lbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0QXJndW1lbnQgPT09ICdvYmplY3QnICYmICEobGFzdEFyZ3VtZW50IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgcmVzdCB0byBzb3VyY2VzXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgICAgICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5BUEksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBnZXRGaWxlcyA9ICgpID0+IHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG5cbiAgICBjb25zdCBwcm9jZXNzRmlsZSA9IHF1ZXJ5ID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgcHJlcGFyZUZpbGVzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgICAgY29uc3QgaXRlbXMgPSBxdWVyaWVzLmxlbmd0aCA/IHF1ZXJpZXMgOiBnZXRGaWxlcygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKHByZXBhcmVGaWxlKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHByb2Nlc3NGaWxlcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZ2V0RmlsZXMoKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgaXRlbSA9PlxuICAgICAgICAgICAgICAgICAgICAhKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLklETEUgJiYgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzICE9PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcmllcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVtb3ZlRmlsZXMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXNbcXVlcmllcy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyaWVzLnBvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlcygpO1xuXG4gICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAoZmlsZSA9PiByZW1vdmVGaWxlKGZpbGUsIG9wdGlvbnMpKSk7XG5cbiAgICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgICAgY29uc3QgbWFwcGVkUXVlcmllcyA9IHF1ZXJpZXNcbiAgICAgICAgICAgIC5tYXAocXVlcnkgPT4gKGlzTnVtYmVyKHF1ZXJ5KSA/IChmaWxlc1txdWVyeV0gPyBmaWxlc1txdWVyeV0uaWQgOiBudWxsKSA6IHF1ZXJ5KSlcbiAgICAgICAgICAgIC5maWx0ZXIocXVlcnkgPT4gcXVlcnkpO1xuXG4gICAgICAgIHJldHVybiBtYXBwZWRRdWVyaWVzLm1hcChxID0+IHJlbW92ZUZpbGUocSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICBjb25zdCBleHBvcnRzID0ge1xuICAgICAgICAvLyBzdXBwb3J0cyBldmVudHNcbiAgICAgICAgLi4ub24oKSxcblxuICAgICAgICAvLyBpbmplY3QgcHJpdmF0ZSBhcGkgbWV0aG9kc1xuICAgICAgICAuLi5yZWFkV3JpdGVBcGksXG5cbiAgICAgICAgLy8gaW5qZWN0IGFsbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIC4uLmNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgZGVmYXVsdE9wdGlvbnMpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBvcHRpb25zIGRlZmluZWQgaW4gb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHNldE9wdGlvbnMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgKGVpdGhlciBhIEZpbGUsIGJhc2U2NCBkYXRhIHVyaSBvciB1cmwpXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVzXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgb2YgdGhlIGZpbGVzIHRvIGxvYWRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZpbGUgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIGZpbGUgd2l0aCBnaXZlbiBuYW1lXG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgZmlsZSBieSBpdHMgbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRmlsZTogKHF1ZXJ5LCBpbmRleCkgPT4gc3RvcmUuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnksIGluZGV4IH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBmaWxlcyAod3JhcHBlZCBpbiBwdWJsaWMgYXBpKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyB1cGxvYWRpbmcgYWxsIGZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBwcmVwYXJpbmcgb3V0cHV0IG9mIGFsbCBmaWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IGNvbXBhcmUgPT4gc3RvcmUuZGlzcGF0Y2goJ1NPUlQnLCB7IGNvbXBhcmUgfSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb3dzZSB0aGUgZmlsZSBzeXN0ZW0gZm9yIGEgZmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvd3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBuZWVkcyB0byBiZSB0cmlnZ2VyIGRpcmVjdGx5IGFzIHVzZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRyYWNlYWJsZSAoaXMgbm90IHRyYWNlYWJsZSBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB2aWV3LmVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGFwcFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBkZXN0cnVjdGlvblxuICAgICAgICAgICAgZXhwb3J0cy5maXJlKCdkZXN0cm95Jywgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBpdGVtcyBhbmQgZGVwZW5kaW5nIG9uIHN0YXRlcyBjYWxsIGFib3J0IGZvciBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0FCT1JUX0FMTCcpO1xuXG4gICAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICAgIHZpZXcuX2Rlc3Ryb3koKTtcblxuICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gcmVzaXplXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHRoZSB2aXNpYmxpdHljaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5SGFuZGxlcik7XG5cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfREVTVFJPWScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIHRoZSBwbHVnaW4gYmVmb3JlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBlbGVtZW50ID0+IGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIHRoZSBwbHVnaW4gYWZ0ZXIgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRBZnRlcjogZWxlbWVudCA9PiBpbnNlcnRBZnRlcih2aWV3LmVsZW1lbnQsIGVsZW1lbnQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwbHVnaW4gdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbzogZWxlbWVudCA9PiBlbGVtZW50LmFwcGVuZENoaWxkKHZpZXcuZWxlbWVudCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlRWxlbWVudDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFwcCBiZWZvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RvcmVFbGVtZW50OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gZWxlbWVudCB0byByZXN0b3JlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIob3JpZ2luYWxFbGVtZW50LCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgb3VyIGVsZW1lbnRcbiAgICAgICAgICAgIHZpZXcuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHJvb3QgaXMgYXR0YWNoZWQgdG8gZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaXNBdHRhY2hlZFRvOiBlbGVtZW50ID0+IHZpZXcuZWxlbWVudCA9PT0gZWxlbWVudCB8fCBvcmlnaW5hbEVsZW1lbnQgPT09IGVsZW1lbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiB2aWV3LmVsZW1lbnQsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzdG9yZS5xdWVyeSgnR0VUX1NUQVRVUycpLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBEb25lIVxuICAgIHN0b3JlLmRpc3BhdGNoKCdESURfSU5JVCcpO1xuXG4gICAgLy8gY3JlYXRlIGFjdHVhbCBhcGkgb2JqZWN0XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHBvcnRzKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUFwcE9iamVjdCA9IChjdXN0b21PcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIGZvcmluKGdldE9wdGlvbnMoKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XSA9IHZhbHVlWzBdO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGFwcCBvcHRpb25zXG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwKHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuXG4gICAgICAgIC8vIGN1c3RvbSBvcHRpb25zXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIHJldHVybiBhcHA7XG59O1xuXG5jb25zdCBsb3dlckNhc2VGaXJzdExldHRlciA9IHN0cmluZyA9PiBzdHJpbmcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG5cbmNvbnN0IGF0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZU5hbWUgPT4gdG9DYW1lbHMoYXR0cmlidXRlTmFtZS5yZXBsYWNlKC9eZGF0YS0vLCAnJykpO1xuXG5jb25zdCBtYXBPYmplY3QgPSAob2JqZWN0LCBwcm9wZXJ0eU1hcCkgPT4ge1xuICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgIGZvcmluKHByb3BlcnR5TWFwLCAoc2VsZWN0b3IsIG1hcHBpbmcpID0+IHtcbiAgICAgICAgZm9yaW4ob2JqZWN0LCAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVnZXhwIHNob3J0Y3V0XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvclJlZ0V4cCA9IG5ldyBSZWdFeHAoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAvLyB0ZXN0cyBpZlxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAvLyBubyBtYXRjaCwgc2tpcFxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgbWFwcGluZywgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGlzIGFsd2F5cyByZW1vdmVkXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gc2hvdWxkIG9ubHkgcmVtb3ZlLCB3ZSBkb25lIVxuICAgICAgICAgICAgaWYgKG1hcHBpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHZhbHVlIHRvIG5ldyBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W21hcHBpbmddID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHRvIGdyb3VwXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWFwcGluZykgJiYgIW9iamVjdFtncm91cF0pIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdFtncm91cF1bbG93ZXJDYXNlRmlyc3RMZXR0ZXIocHJvcGVydHkucmVwbGFjZShzZWxlY3RvclJlZ0V4cCwgJycpKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgICBpZiAobWFwcGluZy5tYXBwaW5nKSB7XG4gICAgICAgICAgICBtYXBPYmplY3Qob2JqZWN0W21hcHBpbmcuZ3JvdXBdLCBtYXBwaW5nLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBnZXRBdHRyaWJ1dGVzQXNPYmplY3QgPSAobm9kZSwgYXR0cmlidXRlTWFwcGluZyA9IHt9KSA9PiB7XG4gICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIGZvcmluKG5vZGUuYXR0cmlidXRlcywgaW5kZXggPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBhdHRyaWJ1dGVzXG4gICAgICAgIC5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5uYW1lKVxuICAgICAgICAucmVkdWNlKChvYmosIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyKG5vZGUsIGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgb2JqW2F0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGUubmFtZSldID1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gYXR0cmlidXRlLm5hbWUgPyB0cnVlIDogdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG5cbiAgICAvLyBkbyBtYXBwaW5nIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgY3JlYXRlQXBwQXRFbGVtZW50ID0gKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIC8vIGhvdyBhdHRyaWJ1dGVzIG9mIHRoZSBpbnB1dCBlbGVtZW50IGFyZSBtYXBwZWQgdG8gdGhlIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW5cbiAgICBjb25zdCBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgICAvLyB0cmFuc2xhdGUgdG8gb3RoZXIgbmFtZVxuICAgICAgICAnXmNsYXNzJCc6ICdjbGFzc05hbWUnLFxuICAgICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICAgJ15jYXB0dXJlJCc6ICdjYXB0dXJlTWV0aG9kJyxcbiAgICAgICAgJ153ZWJraXRkaXJlY3RvcnkkJzogJ2FsbG93RGlyZWN0b3JpZXNPbmx5JyxcblxuICAgICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICAgJ15zZXJ2ZXInOiB7XG4gICAgICAgICAgICBncm91cDogJ3NlcnZlcicsXG4gICAgICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAgICAgJ15wcm9jZXNzJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncmV2ZXJ0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdeZmV0Y2gnOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15yZXN0b3JlJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ2xvYWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGRvbid0IGluY2x1ZGUgaW4gb2JqZWN0XG4gICAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICAgJ15maWxlcyQnOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgYXBwbHlGaWx0ZXJzKCdTRVRfQVRUUklCVVRFX1RPX09QVElPTl9NQVAnLCBhdHRyaWJ1dGVNYXBwaW5nKTtcblxuICAgIC8vIGNyZWF0ZSBmaW5hbCBvcHRpb25zIG9iamVjdCBieSBzZXR0aW5nIG9wdGlvbnMgb2JqZWN0IGFuZCB0aGVuIG92ZXJyaWRpbmcgb3B0aW9ucyBzdXBwbGllZCBvbiBlbGVtZW50XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgICAgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0ZJRUxEU0VUJyA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpIDogZWxlbWVudCxcbiAgICAgICAgYXR0cmlidXRlTWFwcGluZ1xuICAgICk7XG5cbiAgICAvLyBtZXJnZSB3aXRoIG9wdGlvbnMgb2JqZWN0XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoaXNPYmplY3QoYXR0cmlidXRlT3B0aW9uc1trZXldKSkge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChtZXJnZWRPcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZE9wdGlvbnNba2V5XSwgYXR0cmlidXRlT3B0aW9uc1trZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IGF0dHJpYnV0ZU9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgcGFyZW50IGlzIGEgZmllbGRzZXQsIGdldCBmaWxlcyBmcm9tIHBhcmVudCBieSBzZWxlY3RpbmcgYWxsIGlucHV0IGZpZWxkcyB0aGF0IGFyZSBub3QgZmlsZSB1cGxvYWQgZmllbGRzXG4gICAgLy8gdGhlc2Ugd2lsbCB0aGVuIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSBpbml0aWFsIGZpbGVzXG4gICAgbWVyZ2VkT3B0aW9ucy5maWxlcyA9IChvcHRpb25zLmZpbGVzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpub3QoW3R5cGU9ZmlsZV0pJykpLm1hcChpbnB1dCA9PiAoe1xuICAgICAgICAgICAgc291cmNlOiBpbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSlcbiAgICApO1xuXG4gICAgLy8gYnVpbGQgcGx1Z2luXG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwT2JqZWN0KG1lcmdlZE9wdGlvbnMpO1xuXG4gICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICBpZiAoZWxlbWVudC5maWxlcykge1xuICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQuZmlsZXMpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBhcHAuYWRkRmlsZShmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBhcHAucmVwbGFjZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBleHBvc2VcbiAgICByZXR1cm4gYXBwO1xufTtcblxuLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuY29uc3QgY3JlYXRlQXBwJDEgPSAoLi4uYXJncykgPT5cbiAgICBpc05vZGUoYXJnc1swXSkgPyBjcmVhdGVBcHBBdEVsZW1lbnQoLi4uYXJncykgOiBjcmVhdGVBcHBPYmplY3QoLi4uYXJncyk7XG5cbmNvbnN0IFBSSVZBVEVfTUVUSE9EUyA9IFsnZmlyZScsICdfcmVhZCcsICdfd3JpdGUnXTtcblxuY29uc3QgY3JlYXRlQXBwQVBJID0gYXBwID0+IHtcbiAgICBjb25zdCBhcGkgPSB7fTtcblxuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoYXBwLCBhcGksIFBSSVZBVEVfTUVUSE9EUyk7XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlcyBwbGFjZWhvbGRlcnMgaW4gZ2l2ZW4gc3RyaW5nIHdpdGggcmVwbGFjZW1lbnRzXG4gKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gKiBAcGFyYW0gcmVwbGFjZW1lbnRzIC0geyBcImJhclwiOiAxMCB9XG4gKi9cbmNvbnN0IHJlcGxhY2VJblN0cmluZyA9IChzdHJpbmcsIHJlcGxhY2VtZW50cykgPT5cbiAgICBzdHJpbmcucmVwbGFjZSgvKD86eyhbYS16QS1aXSspfSkvZywgKG1hdGNoLCBncm91cCkgPT4gcmVwbGFjZW1lbnRzW2dyb3VwXSk7XG5cbmNvbnN0IGNyZWF0ZVdvcmtlciA9IGZuID0+IHtcbiAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoWycoJywgZm4udG9TdHJpbmcoKSwgJykoKSddLCB7XG4gICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zZmVyOiAobWVzc2FnZSwgY2IpID0+IHt9LFxuICAgICAgICBwb3N0OiAobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJMaXN0XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgbG9hZEltYWdlID0gdXJsID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9KTtcblxuY29uc3QgcmVuYW1lRmlsZSA9IChmaWxlLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgcmVuYW1lZEZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgZmlsZS50eXBlKTtcbiAgICByZW5hbWVkRmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiByZW5hbWVkRmlsZTtcbn07XG5cbmNvbnN0IGNvcHlGaWxlID0gZmlsZSA9PiByZW5hbWVGaWxlKGZpbGUsIGZpbGUubmFtZSk7XG5cbi8vIGFscmVhZHkgcmVnaXN0ZXJlZCBwbHVnaW5zIChjYW4ndCByZWdpc3RlciB0d2ljZSlcbmNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5zID0gW107XG5cbi8vIHBhc3MgdXRpbHMgdG8gcGx1Z2luXG5jb25zdCBjcmVhdGVBcHBQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIGlmIChyZWdpc3RlcmVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1lbWJlciB0aGlzIHBsdWdpblxuICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgIC8vIHNldHVwIVxuICAgIGNvbnN0IHBsdWdpbk91dGxpbmUgPSBwbHVnaW4oe1xuICAgICAgICBhZGRGaWx0ZXIsXG4gICAgICAgIHV0aWxzOiB7XG4gICAgICAgICAgICBUeXBlLFxuICAgICAgICAgICAgZm9yaW4sXG4gICAgICAgICAgICBpc1N0cmluZyxcbiAgICAgICAgICAgIGlzRmlsZSxcbiAgICAgICAgICAgIHRvTmF0dXJhbEZpbGVTaXplLFxuICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nLFxuICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lLFxuICAgICAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgICAgIGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgIGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgICAgIGNyZWF0ZVJvdXRlLFxuICAgICAgICAgICAgY3JlYXRlV29ya2VyLFxuICAgICAgICAgICAgY3JlYXRlVmlldyxcbiAgICAgICAgICAgIGNyZWF0ZUl0ZW1BUEksXG4gICAgICAgICAgICBsb2FkSW1hZ2UsXG4gICAgICAgICAgICBjb3B5RmlsZSxcbiAgICAgICAgICAgIHJlbmFtZUZpbGUsXG4gICAgICAgICAgICBjcmVhdGVCbG9iLFxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nLFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgZmlsZUFjdGlvbkJ1dHRvbixcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIGFkZCBwbHVnaW4gb3B0aW9ucyB0byBkZWZhdWx0IG9wdGlvbnNcbiAgICBleHRlbmREZWZhdWx0T3B0aW9ucyhwbHVnaW5PdXRsaW5lLm9wdGlvbnMpO1xufTtcblxuLy8gZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBzdXBwb3J0ZWQoKSBtZXRob2RcbmNvbnN0IGlzT3BlcmFNaW5pID0gKCkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYW1pbmkpID09PSAnW29iamVjdCBPcGVyYU1pbmldJztcbmNvbnN0IGhhc1Byb21pc2VzID0gKCkgPT4gJ1Byb21pc2UnIGluIHdpbmRvdztcbmNvbnN0IGhhc0Jsb2JTbGljZSA9ICgpID0+ICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG5jb25zdCBoYXNDcmVhdGVPYmplY3RVUkwgPSAoKSA9PiAnVVJMJyBpbiB3aW5kb3cgJiYgJ2NyZWF0ZU9iamVjdFVSTCcgaW4gd2luZG93LlVSTDtcbmNvbnN0IGhhc1Zpc2liaWxpdHkgPSAoKSA9PiAndmlzaWJpbGl0eVN0YXRlJyBpbiBkb2N1bWVudDtcbmNvbnN0IGhhc1RpbWluZyA9ICgpID0+ICdwZXJmb3JtYW5jZScgaW4gd2luZG93OyAvLyBpT1MgOC54XG5jb25zdCBoYXNDU1NTdXBwb3J0cyA9ICgpID0+ICdzdXBwb3J0cycgaW4gKHdpbmRvdy5DU1MgfHwge30pOyAvLyB1c2UgdG8gZGV0ZWN0IFNhZmFyaSA5K1xuY29uc3QgaXNJRTExID0gKCkgPT4gL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmNvbnN0IHN1cHBvcnRlZCA9ICgoKSA9PiB7XG4gICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgY29uc3QgaXNTdXBwb3J0ZWQgPVxuICAgICAgICAvLyBIYXMgdG8gYmUgYSBicm93c2VyXG4gICAgICAgIGlzQnJvd3NlcigpICYmXG4gICAgICAgIC8vIENhbid0IHJ1biBvbiBPcGVyYSBNaW5pIGR1ZSB0byBsYWNrIG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgIWlzT3BlcmFNaW5pKCkgJiZcbiAgICAgICAgLy8gUmVxdWlyZSB0aGVzZSBBUElzIHRvIGZlYXR1cmUgZGV0ZWN0IGEgbW9kZXJuIGJyb3dzZXJcbiAgICAgICAgaGFzVmlzaWJpbGl0eSgpICYmXG4gICAgICAgIGhhc1Byb21pc2VzKCkgJiZcbiAgICAgICAgaGFzQmxvYlNsaWNlKCkgJiZcbiAgICAgICAgaGFzQ3JlYXRlT2JqZWN0VVJMKCkgJiZcbiAgICAgICAgaGFzVGltaW5nKCkgJiZcbiAgICAgICAgLy8gZG9lc24ndCBuZWVkIENTU1N1cHBvcnRzIGJ1dCBpcyBhIGdvb2Qgd2F5IHRvIGRldGVjdCBTYWZhcmkgOSsgKHdlIGRvIHdhbnQgdG8gc3VwcG9ydCBJRTExIHRob3VnaClcbiAgICAgICAgKGhhc0NTU1N1cHBvcnRzKCkgfHwgaXNJRTExKCkpO1xuXG4gICAgcmV0dXJuICgpID0+IGlzU3VwcG9ydGVkO1xufSkoKTtcblxuLyoqXG4gKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAqL1xuY29uc3Qgc3RhdGUgPSB7XG4gICAgLy8gYWN0aXZlIGFwcCBpbnN0YW5jZXMsIHVzZWQgdG8gcmVkcmF3IHRoZSBhcHBzIGFuZCB0byBmaW5kIHRoZSBsYXRlclxuICAgIGFwcHM6IFtdLFxufTtcblxuLy8gcGx1Z2luIG5hbWVcbmNvbnN0IG5hbWUgPSAnZmlsZXBvbmQnO1xuXG4vKipcbiAqIFB1YmxpYyBQbHVnaW4gbWV0aG9kc1xuICovXG5jb25zdCBmbiA9ICgpID0+IHt9O1xubGV0IFN0YXR1cyQxID0ge307XG5sZXQgRmlsZVN0YXR1cyA9IHt9O1xubGV0IEZpbGVPcmlnaW4kMSA9IHt9O1xubGV0IE9wdGlvblR5cGVzID0ge307XG5sZXQgY3JlYXRlJGYgPSBmbjtcbmxldCBkZXN0cm95ID0gZm47XG5sZXQgcGFyc2UgPSBmbjtcbmxldCBmaW5kID0gZm47XG5sZXQgcmVnaXN0ZXJQbHVnaW4gPSBmbjtcbmxldCBnZXRPcHRpb25zJDEgPSBmbjtcbmxldCBzZXRPcHRpb25zJDEgPSBmbjtcblxuLy8gaWYgbm90IHN1cHBvcnRlZCwgbm8gQVBJXG5pZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAvLyBzdGFydCBwYWludGVyIGFuZCBmaXJlIGxvYWQgZXZlbnRcbiAgICBjcmVhdGVQYWludGVyKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goYXBwID0+IGFwcC5fcmVhZCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHMgPT4ge1xuICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGFwcCA9PiBhcHAuX3dyaXRlKHRzKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gZmlyZSBsb2FkZWQgZXZlbnQgc28gd2Uga25vdyB3aGVuIEZpbGVQb25kIGlzIGF2YWlsYWJsZVxuICAgIGNvbnN0IGRpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOmxvYWRlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IGNyZWF0ZSRmLFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95LFxuICAgICAgICAgICAgICAgICAgICBwYXJzZSxcbiAgICAgICAgICAgICAgICAgICAgZmluZCxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbnM6IHNldE9wdGlvbnMkMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjbGVhbiB1cCBldmVudFxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgIH07XG5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRpc3BhdGNoKCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkaXNwYXRjaCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlcyB0aGUgT3B0aW9uVHlwZXMgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IG9wdGlvbnNcbiAgICBjb25zdCB1cGRhdGVPcHRpb25UeXBlcyA9ICgpID0+XG4gICAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIE9wdGlvblR5cGVzW2tleV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgfSk7XG5cbiAgICBTdGF0dXMkMSA9IHsgLi4uU3RhdHVzIH07XG4gICAgRmlsZU9yaWdpbiQxID0geyAuLi5GaWxlT3JpZ2luIH07XG4gICAgRmlsZVN0YXR1cyA9IHsgLi4uSXRlbVN0YXR1cyB9O1xuXG4gICAgT3B0aW9uVHlwZXMgPSB7fTtcbiAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgLy8gY3JlYXRlIG1ldGhvZCwgY3JlYXRlcyBhcHBzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGFwcCBhcnJheVxuICAgIGNyZWF0ZSRmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY3JlYXRlQXBwJDEoLi4uYXJncyk7XG4gICAgICAgIGFwcC5vbignZGVzdHJveScsIGRlc3Ryb3kpO1xuICAgICAgICBzdGF0ZS5hcHBzLnB1c2goYXBwKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgIH07XG5cbiAgICAvLyBkZXN0cm95cyBhcHBzIGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgYXBwIGFycmF5XG4gICAgZGVzdHJveSA9IGhvb2sgPT4ge1xuICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgdGhlIGFwcCB3YXMgZGVzdHJveWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBjb25zdCBpbmRleFRvUmVtb3ZlID0gc3RhdGUuYXBwcy5maW5kSW5kZXgoYXBwID0+IGFwcC5pc0F0dGFjaGVkVG8oaG9vaykpO1xuICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBhcHBzXG4gICAgICAgICAgICBjb25zdCBhcHAgPSBzdGF0ZS5hcHBzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKVswXTtcblxuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBkb20gZWxlbWVudFxuICAgICAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBwYXJzZXMgdGhlIGdpdmVuIGNvbnRleHQgZm9yIHBsdWdpbnMgKGRvZXMgbm90IGluY2x1ZGUgdGhlIGNvbnRleHQgZWxlbWVudCBpdHNlbGYpXG4gICAgcGFyc2UgPSBjb250ZXh0ID0+IHtcbiAgICAgICAgLy8gZ2V0IGFsbCBwb3NzaWJsZSBob29rc1xuICAgICAgICBjb25zdCBtYXRjaGVkSG9va3MgPSBBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChgLiR7bmFtZX1gKSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBhbHJlYWR5IGFjdGl2ZSBob29rc1xuICAgICAgICBjb25zdCBuZXdIb29rcyA9IG1hdGNoZWRIb29rcy5maWx0ZXIoXG4gICAgICAgICAgICBuZXdIb29rID0+ICFzdGF0ZS5hcHBzLmZpbmQoYXBwID0+IGFwcC5pc0F0dGFjaGVkVG8obmV3SG9vaykpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBmb3IgZWFjaCBob29rXG4gICAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoaG9vayA9PiBjcmVhdGUkZihob29rKSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgYW4gYXBwIGJhc2VkIG9uIHRoZSBnaXZlbiBlbGVtZW50IGhvb2tcbiAgICBmaW5kID0gaG9vayA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IHN0YXRlLmFwcHMuZmluZChhcHAgPT4gYXBwLmlzQXR0YWNoZWRUbyhob29rKSk7XG4gICAgICAgIGlmICghYXBwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQXBwQVBJKGFwcCk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgcmVnaXN0ZXJQbHVnaW4gPSAoLi4ucGx1Z2lucykgPT4ge1xuICAgICAgICAvLyByZWdpc3RlciBwbHVnaW5zXG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBPcHRpb25UeXBlcywgZWFjaCBwbHVnaW4gbWlnaHQgaGF2ZSBleHRlbmRlZCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHVwZGF0ZU9wdGlvblR5cGVzKCk7XG4gICAgfTtcblxuICAgIGdldE9wdGlvbnMkMSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBmb3JpbihnZXRPcHRpb25zKCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvcHRzW2tleV0gPSB2YWx1ZVswXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG5cbiAgICBzZXRPcHRpb25zJDEgPSBvcHRzID0+IHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdHMpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcGx1Z2luc1xuICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGFwcCA9PiB7XG4gICAgICAgICAgICAgICAgYXBwLnNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gbmV3IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIGdldE9wdGlvbnMkMSgpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7XG4gICAgRmlsZU9yaWdpbiQxIGFzIEZpbGVPcmlnaW4sXG4gICAgRmlsZVN0YXR1cyxcbiAgICBPcHRpb25UeXBlcyxcbiAgICBTdGF0dXMkMSBhcyBTdGF0dXMsXG4gICAgY3JlYXRlJGYgYXMgY3JlYXRlLFxuICAgIGRlc3Ryb3ksXG4gICAgZmluZCxcbiAgICBnZXRPcHRpb25zJDEgYXMgZ2V0T3B0aW9ucyxcbiAgICBwYXJzZSxcbiAgICByZWdpc3RlclBsdWdpbixcbiAgICBzZXRPcHRpb25zJDEgYXMgc2V0T3B0aW9ucyxcbiAgICBzdXBwb3J0ZWQsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ad56d68715ff\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJIOlxcS0FOSEFJWUFcXE1haW5Qcm9cXExlYXJuUHJvXFxjbGllbnRcXG5vZGVfbW9kdWxlc1xcZmlsZXBvbmRcXGRpc3RcXGZpbGVwb25kLm1pbi5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhZDU2ZDY4NzE1ZmZcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.min.css\n");

/***/ })

};
;